Sync intel with gnu wrapper. The only difference should be in [cz]dot[uc]; without
these wrapper_blas_intel.c won't compile.

Bart Oldeman <bart.oldeman@calculquebec.ca>
diff -ur flexiblas-3.0.4/src/wrapper_blas_intel.c flexiblas-3.0.4.new/src/wrapper_blas_intel.c
--- flexiblas-3.0.4/src/wrapper_blas_intel.c	2020-10-22 09:07:55.000000000 +0000
+++ flexiblas-3.0.4.new/src/wrapper_blas_intel.c	2021-10-03 22:52:02.359617295 +0000
@@ -235,6 +235,8 @@
 			return 0;
 }
 
+static TLS_STORE uint8_t hook_pos_caxpy = 0;
+
 void FC_GLOBAL(caxpy,CAXPY)(blasint* n, float complex* ca, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
 {
 	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cy, void* incy);
@@ -261,6 +263,40 @@
 
 
 
+void flexiblas_real_caxpy_(void* n, void* ca, void* cx, void* incx, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cy, void* incy);
+
+	fn = current_backend->blas.caxpy.f77_blas_function;
+	fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_caxpy(void* n, void* ca, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_real_caxpy_")));
+
+
+void flexiblas_chain_caxpy_(void* n, void* ca, void* cx, void* incx, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cy, void* incy);
+
+
+
+    hook_pos_caxpy++;
+    if ( hook_pos_caxpy < __flexiblas_hooks->caxpy.nhook ) {
+        fn = __flexiblas_hooks->caxpy.f77_hook_function[hook_pos_caxpy];
+    } else {
+        hook_pos_caxpy = 0;
+        fn = current_backend->blas.caxpy.f77_blas_function;
+    }
+	fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_caxpy(void* n, void* ca, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_chain_caxpy_")));
+
+
+static TLS_STORE uint8_t hook_pos_ccopy = 0;
+
 void FC_GLOBAL(ccopy,CCOPY)(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
 {
 	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
@@ -287,6 +323,40 @@
 
 
 
+void flexiblas_real_ccopy_(void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+
+	fn = current_backend->blas.ccopy.f77_blas_function;
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_ccopy(void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_real_ccopy_")));
+
+
+void flexiblas_chain_ccopy_(void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+
+
+
+    hook_pos_ccopy++;
+    if ( hook_pos_ccopy < __flexiblas_hooks->ccopy.nhook ) {
+        fn = __flexiblas_hooks->ccopy.f77_hook_function[hook_pos_ccopy];
+    } else {
+        hook_pos_ccopy = 0;
+        fn = current_backend->blas.ccopy.f77_blas_function;
+    }
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_ccopy(void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_chain_ccopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_cdotc = 0;
+
 void FC_GLOBAL(cdotc,CDOTC)( float complex* returnvalue, blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
 {
 	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
@@ -327,6 +397,56 @@
 
 
 
+void flexiblas_real_cdotc_( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
+	float complex ret;
+
+	fn = current_backend->blas.cdotc.f77_blas_function;	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		}
+
+	*((float complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_real_cdotc( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_real_cdotc_")));
+
+
+void flexiblas_chain_cdotc_( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
+	float complex ret;
+
+
+
+    hook_pos_cdotc++;
+    if ( hook_pos_cdotc < __flexiblas_hooks->cdotc.nhook ) {
+        fn = __flexiblas_hooks->cdotc.f77_hook_function[hook_pos_cdotc];
+    } else {
+        hook_pos_cdotc = 0;
+        fn = current_backend->blas.cdotc.f77_blas_function;
+    }	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		}
+
+	*((float complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_chain_cdotc( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_chain_cdotc_")));
+
+
+static TLS_STORE uint8_t hook_pos_cdotu = 0;
+
 void FC_GLOBAL(cdotu,CDOTU)( float complex* returnvalue, blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
 {
 	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
@@ -367,6 +487,56 @@
 
 
 
+void flexiblas_real_cdotu_( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
+	float complex ret;
+
+	fn = current_backend->blas.cdotu.f77_blas_function;	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		}
+
+	*((float complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_real_cdotu( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_real_cdotu_")));
+
+
+void flexiblas_chain_cdotu_( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
+	float complex ret;
+
+
+
+    hook_pos_cdotu++;
+    if ( hook_pos_cdotu < __flexiblas_hooks->cdotu.nhook ) {
+        fn = __flexiblas_hooks->cdotu.f77_hook_function[hook_pos_cdotu];
+    } else {
+        hook_pos_cdotu = 0;
+        fn = current_backend->blas.cdotu.f77_blas_function;
+    }	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+		}
+
+	*((float complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_chain_cdotu( void * returnvalue, void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_chain_cdotu_")));
+
+
+static TLS_STORE uint8_t hook_pos_cgbmv = 0;
+
 void FC_GLOBAL(cgbmv,CGBMV)(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -393,6 +563,40 @@
 
 
 
+void flexiblas_real_cgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.cgbmv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_cgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_cgbmv_")));
+
+
+void flexiblas_chain_cgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_cgbmv++;
+    if ( hook_pos_cgbmv < __flexiblas_hooks->cgbmv.nhook ) {
+        fn = __flexiblas_hooks->cgbmv.f77_hook_function[hook_pos_cgbmv];
+    } else {
+        hook_pos_cgbmv = 0;
+        fn = current_backend->blas.cgbmv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_cgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_cgbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_cgemm = 0;
+
 void FC_GLOBAL(cgemm,CGEMM)(char* transa, char* transb, blasint* m, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -419,6 +623,40 @@
 
 
 
+void flexiblas_real_cgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.cgemm.f77_blas_function;
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_cgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_cgemm_")));
+
+
+void flexiblas_chain_cgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_cgemm++;
+    if ( hook_pos_cgemm < __flexiblas_hooks->cgemm.nhook ) {
+        fn = __flexiblas_hooks->cgemm.f77_hook_function[hook_pos_cgemm];
+    } else {
+        hook_pos_cgemm = 0;
+        fn = current_backend->blas.cgemm.f77_blas_function;
+    }
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_cgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_cgemm_")));
+
+
+static TLS_STORE uint8_t hook_pos_cgemv = 0;
+
 void FC_GLOBAL(cgemv,CGEMV)(char* trans, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -445,6 +683,40 @@
 
 
 
+void flexiblas_real_cgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.cgemv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_cgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_cgemv_")));
+
+
+void flexiblas_chain_cgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_cgemv++;
+    if ( hook_pos_cgemv < __flexiblas_hooks->cgemv.nhook ) {
+        fn = __flexiblas_hooks->cgemv.f77_hook_function[hook_pos_cgemv];
+    } else {
+        hook_pos_cgemv = 0;
+        fn = current_backend->blas.cgemv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_cgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_cgemv_")));
+
+
+static TLS_STORE uint8_t hook_pos_cgerc = 0;
+
 void FC_GLOBAL(cgerc,CGERC)(blasint* m, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -471,6 +743,40 @@
 
 
 
+void flexiblas_real_cgerc_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.cgerc.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_cgerc(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_cgerc_")));
+
+
+void flexiblas_chain_cgerc_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_cgerc++;
+    if ( hook_pos_cgerc < __flexiblas_hooks->cgerc.nhook ) {
+        fn = __flexiblas_hooks->cgerc.f77_hook_function[hook_pos_cgerc];
+    } else {
+        hook_pos_cgerc = 0;
+        fn = current_backend->blas.cgerc.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_cgerc(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_cgerc_")));
+
+
+static TLS_STORE uint8_t hook_pos_cgeru = 0;
+
 void FC_GLOBAL(cgeru,CGERU)(blasint* m, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -497,6 +803,40 @@
 
 
 
+void flexiblas_real_cgeru_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.cgeru.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_cgeru(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_cgeru_")));
+
+
+void flexiblas_chain_cgeru_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_cgeru++;
+    if ( hook_pos_cgeru < __flexiblas_hooks->cgeru.nhook ) {
+        fn = __flexiblas_hooks->cgeru.f77_hook_function[hook_pos_cgeru];
+    } else {
+        hook_pos_cgeru = 0;
+        fn = current_backend->blas.cgeru.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_cgeru(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_cgeru_")));
+
+
+static TLS_STORE uint8_t hook_pos_chbmv = 0;
+
 void FC_GLOBAL(chbmv,CHBMV)(char* uplo, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -523,6 +863,40 @@
 
 
 
+void flexiblas_real_chbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.chbmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_chbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_chbmv_")));
+
+
+void flexiblas_chain_chbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_chbmv++;
+    if ( hook_pos_chbmv < __flexiblas_hooks->chbmv.nhook ) {
+        fn = __flexiblas_hooks->chbmv.f77_hook_function[hook_pos_chbmv];
+    } else {
+        hook_pos_chbmv = 0;
+        fn = current_backend->blas.chbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_chbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_chbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_chemm = 0;
+
 void FC_GLOBAL(chemm,CHEMM)(char* side, char* uplo, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -549,6 +923,40 @@
 
 
 
+void flexiblas_real_chemm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.chemm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_chemm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_chemm_")));
+
+
+void flexiblas_chain_chemm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_chemm++;
+    if ( hook_pos_chemm < __flexiblas_hooks->chemm.nhook ) {
+        fn = __flexiblas_hooks->chemm.f77_hook_function[hook_pos_chemm];
+    } else {
+        hook_pos_chemm = 0;
+        fn = current_backend->blas.chemm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_chemm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_chemm_")));
+
+
+static TLS_STORE uint8_t hook_pos_chemv = 0;
+
 void FC_GLOBAL(chemv,CHEMV)(char* uplo, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -575,6 +983,40 @@
 
 
 
+void flexiblas_real_chemv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.chemv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_chemv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_chemv_")));
+
+
+void flexiblas_chain_chemv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_chemv++;
+    if ( hook_pos_chemv < __flexiblas_hooks->chemv.nhook ) {
+        fn = __flexiblas_hooks->chemv.f77_hook_function[hook_pos_chemv];
+    } else {
+        hook_pos_chemv = 0;
+        fn = current_backend->blas.chemv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_chemv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_chemv_")));
+
+
+static TLS_STORE uint8_t hook_pos_cher = 0;
+
 void FC_GLOBAL(cher,CHER)(char* uplo, blasint* n, float* alpha, float complex* x, blasint* incx, float complex* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
@@ -601,6 +1043,40 @@
 
 
 
+void flexiblas_real_cher_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+	fn = current_backend->blas.cher.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_cher(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_real_cher_")));
+
+
+void flexiblas_chain_cher_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+
+
+    hook_pos_cher++;
+    if ( hook_pos_cher < __flexiblas_hooks->cher.nhook ) {
+        fn = __flexiblas_hooks->cher.f77_hook_function[hook_pos_cher];
+    } else {
+        hook_pos_cher = 0;
+        fn = current_backend->blas.cher.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_cher(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_chain_cher_")));
+
+
+static TLS_STORE uint8_t hook_pos_cher2 = 0;
+
 void FC_GLOBAL(cher2,CHER2)(char* uplo, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -627,6 +1103,40 @@
 
 
 
+void flexiblas_real_cher2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.cher2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_cher2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_cher2_")));
+
+
+void flexiblas_chain_cher2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_cher2++;
+    if ( hook_pos_cher2 < __flexiblas_hooks->cher2.nhook ) {
+        fn = __flexiblas_hooks->cher2.f77_hook_function[hook_pos_cher2];
+    } else {
+        hook_pos_cher2 = 0;
+        fn = current_backend->blas.cher2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_cher2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_cher2_")));
+
+
+static TLS_STORE uint8_t hook_pos_cher2k = 0;
+
 void FC_GLOBAL(cher2k,CHER2K)(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -653,6 +1163,40 @@
 
 
 
+void flexiblas_real_cher2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.cher2k.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_cher2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_cher2k_")));
+
+
+void flexiblas_chain_cher2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_cher2k++;
+    if ( hook_pos_cher2k < __flexiblas_hooks->cher2k.nhook ) {
+        fn = __flexiblas_hooks->cher2k.f77_hook_function[hook_pos_cher2k];
+    } else {
+        hook_pos_cher2k = 0;
+        fn = current_backend->blas.cher2k.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_cher2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_cher2k_")));
+
+
+static TLS_STORE uint8_t hook_pos_cherk = 0;
+
 void FC_GLOBAL(cherk,CHERK)(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float complex* a, blasint* lda, float* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
@@ -679,6 +1223,40 @@
 
 
 
+void flexiblas_real_cherk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.cherk.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_cherk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_cherk_")));
+
+
+void flexiblas_chain_cherk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_cherk++;
+    if ( hook_pos_cherk < __flexiblas_hooks->cherk.nhook ) {
+        fn = __flexiblas_hooks->cherk.f77_hook_function[hook_pos_cherk];
+    } else {
+        hook_pos_cherk = 0;
+        fn = current_backend->blas.cherk.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_cherk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_cherk_")));
+
+
+static TLS_STORE uint8_t hook_pos_chpmv = 0;
+
 void FC_GLOBAL(chpmv,CHPMV)(char* uplo, blasint* n, float complex* alpha, float complex* ap, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
@@ -705,6 +1283,40 @@
 
 
 
+void flexiblas_real_chpmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.chpmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_chpmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_chpmv_")));
+
+
+void flexiblas_chain_chpmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_chpmv++;
+    if ( hook_pos_chpmv < __flexiblas_hooks->chpmv.nhook ) {
+        fn = __flexiblas_hooks->chpmv.f77_hook_function[hook_pos_chpmv];
+    } else {
+        hook_pos_chpmv = 0;
+        fn = current_backend->blas.chpmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_chpmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_chpmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_chpr = 0;
+
 void FC_GLOBAL(chpr,CHPR)(char* uplo, blasint* n, float* alpha, float complex* x, blasint* incx, float complex* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
@@ -731,6 +1343,40 @@
 
 
 
+void flexiblas_real_chpr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+	fn = current_backend->blas.chpr.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_real_chpr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_real_chpr_")));
+
+
+void flexiblas_chain_chpr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+
+
+    hook_pos_chpr++;
+    if ( hook_pos_chpr < __flexiblas_hooks->chpr.nhook ) {
+        fn = __flexiblas_hooks->chpr.f77_hook_function[hook_pos_chpr];
+    } else {
+        hook_pos_chpr = 0;
+        fn = current_backend->blas.chpr.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_chpr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_chain_chpr_")));
+
+
+static TLS_STORE uint8_t hook_pos_chpr2 = 0;
+
 void FC_GLOBAL(chpr2,CHPR2)(char* uplo, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
@@ -757,6 +1403,40 @@
 
 
 
+void flexiblas_real_chpr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+	fn = current_backend->blas.chpr2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_real_chpr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_real_chpr2_")));
+
+
+void flexiblas_chain_chpr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+
+
+    hook_pos_chpr2++;
+    if ( hook_pos_chpr2 < __flexiblas_hooks->chpr2.nhook ) {
+        fn = __flexiblas_hooks->chpr2.f77_hook_function[hook_pos_chpr2];
+    } else {
+        hook_pos_chpr2 = 0;
+        fn = current_backend->blas.chpr2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_chpr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_chain_chpr2_")));
+
+
+static TLS_STORE uint8_t hook_pos_crotg = 0;
+
 void FC_GLOBAL(crotg,CROTG)(float complex* ca, float complex* cb, float* c, float complex* s)
 {
 	void (*fn) (void* ca, void* cb, void* c, void* s);
@@ -783,6 +1463,40 @@
 
 
 
+void flexiblas_real_crotg_(void* ca, void* cb, void* c, void* s)
+{
+	void (*fn) (void* ca, void* cb, void* c, void* s);
+
+	fn = current_backend->blas.crotg.f77_blas_function;
+	fn((void*) ca, (void*) cb, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_crotg(void* ca, void* cb, void* c, void* s) __attribute__((alias("flexiblas_real_crotg_")));
+
+
+void flexiblas_chain_crotg_(void* ca, void* cb, void* c, void* s)
+{
+	void (*fn) (void* ca, void* cb, void* c, void* s);
+
+
+
+    hook_pos_crotg++;
+    if ( hook_pos_crotg < __flexiblas_hooks->crotg.nhook ) {
+        fn = __flexiblas_hooks->crotg.f77_hook_function[hook_pos_crotg];
+    } else {
+        hook_pos_crotg = 0;
+        fn = current_backend->blas.crotg.f77_blas_function;
+    }
+	fn((void*) ca, (void*) cb, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_crotg(void* ca, void* cb, void* c, void* s) __attribute__((alias("flexiblas_chain_crotg_")));
+
+
+static TLS_STORE uint8_t hook_pos_cscal = 0;
+
 void FC_GLOBAL(cscal,CSCAL)(blasint* n, float complex* ca, float complex* cx, blasint* incx)
 {
 	void (*fn) (void* n, void* ca, void* cx, void* incx);
@@ -809,6 +1523,40 @@
 
 
 
+void flexiblas_real_cscal_(void* n, void* ca, void* cx, void* incx)
+{
+	void (*fn) (void* n, void* ca, void* cx, void* incx);
+
+	fn = current_backend->blas.cscal.f77_blas_function;
+	fn((void*) n, (void*) ca, (void*) cx, (void*) incx);
+
+	return;
+}
+void flexiblas_real_cscal(void* n, void* ca, void* cx, void* incx) __attribute__((alias("flexiblas_real_cscal_")));
+
+
+void flexiblas_chain_cscal_(void* n, void* ca, void* cx, void* incx)
+{
+	void (*fn) (void* n, void* ca, void* cx, void* incx);
+
+
+
+    hook_pos_cscal++;
+    if ( hook_pos_cscal < __flexiblas_hooks->cscal.nhook ) {
+        fn = __flexiblas_hooks->cscal.f77_hook_function[hook_pos_cscal];
+    } else {
+        hook_pos_cscal = 0;
+        fn = current_backend->blas.cscal.f77_blas_function;
+    }
+	fn((void*) n, (void*) ca, (void*) cx, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_cscal(void* n, void* ca, void* cx, void* incx) __attribute__((alias("flexiblas_chain_cscal_")));
+
+
+static TLS_STORE uint8_t hook_pos_csrot = 0;
+
 void FC_GLOBAL(csrot,CSROT)(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy, float* c, float* s)
 {
 	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
@@ -835,6 +1583,40 @@
 
 
 
+void flexiblas_real_csrot_(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
+
+	fn = current_backend->blas.csrot.f77_blas_function;
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_csrot(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_real_csrot_")));
+
+
+void flexiblas_chain_csrot_(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
+
+
+
+    hook_pos_csrot++;
+    if ( hook_pos_csrot < __flexiblas_hooks->csrot.nhook ) {
+        fn = __flexiblas_hooks->csrot.f77_hook_function[hook_pos_csrot];
+    } else {
+        hook_pos_csrot = 0;
+        fn = current_backend->blas.csrot.f77_blas_function;
+    }
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_csrot(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_chain_csrot_")));
+
+
+static TLS_STORE uint8_t hook_pos_csscal = 0;
+
 void FC_GLOBAL(csscal,CSSCAL)(blasint* n, float* sa, float complex* cx, blasint* incx)
 {
 	void (*fn) (void* n, void* sa, void* cx, void* incx);
@@ -861,6 +1643,40 @@
 
 
 
+void flexiblas_real_csscal_(void* n, void* sa, void* cx, void* incx)
+{
+	void (*fn) (void* n, void* sa, void* cx, void* incx);
+
+	fn = current_backend->blas.csscal.f77_blas_function;
+	fn((void*) n, (void*) sa, (void*) cx, (void*) incx);
+
+	return;
+}
+void flexiblas_real_csscal(void* n, void* sa, void* cx, void* incx) __attribute__((alias("flexiblas_real_csscal_")));
+
+
+void flexiblas_chain_csscal_(void* n, void* sa, void* cx, void* incx)
+{
+	void (*fn) (void* n, void* sa, void* cx, void* incx);
+
+
+
+    hook_pos_csscal++;
+    if ( hook_pos_csscal < __flexiblas_hooks->csscal.nhook ) {
+        fn = __flexiblas_hooks->csscal.f77_hook_function[hook_pos_csscal];
+    } else {
+        hook_pos_csscal = 0;
+        fn = current_backend->blas.csscal.f77_blas_function;
+    }
+	fn((void*) n, (void*) sa, (void*) cx, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_csscal(void* n, void* sa, void* cx, void* incx) __attribute__((alias("flexiblas_chain_csscal_")));
+
+
+static TLS_STORE uint8_t hook_pos_cswap = 0;
+
 void FC_GLOBAL(cswap,CSWAP)(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
 {
 	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
@@ -887,6 +1703,40 @@
 
 
 
+void flexiblas_real_cswap_(void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+
+	fn = current_backend->blas.cswap.f77_blas_function;
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_cswap(void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_real_cswap_")));
+
+
+void flexiblas_chain_cswap_(void* n, void* cx, void* incx, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
+
+
+
+    hook_pos_cswap++;
+    if ( hook_pos_cswap < __flexiblas_hooks->cswap.nhook ) {
+        fn = __flexiblas_hooks->cswap.f77_hook_function[hook_pos_cswap];
+    } else {
+        hook_pos_cswap = 0;
+        fn = current_backend->blas.cswap.f77_blas_function;
+    }
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_cswap(void* n, void* cx, void* incx, void* cy, void* incy) __attribute__((alias("flexiblas_chain_cswap_")));
+
+
+static TLS_STORE uint8_t hook_pos_csymm = 0;
+
 void FC_GLOBAL(csymm,CSYMM)(char* side, char* uplo, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -913,6 +1763,40 @@
 
 
 
+void flexiblas_real_csymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.csymm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_csymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_csymm_")));
+
+
+void flexiblas_chain_csymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_csymm++;
+    if ( hook_pos_csymm < __flexiblas_hooks->csymm.nhook ) {
+        fn = __flexiblas_hooks->csymm.f77_hook_function[hook_pos_csymm];
+    } else {
+        hook_pos_csymm = 0;
+        fn = current_backend->blas.csymm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_csymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_csymm_")));
+
+
+static TLS_STORE uint8_t hook_pos_csyr2k = 0;
+
 void FC_GLOBAL(csyr2k,CSYR2K)(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -939,6 +1823,40 @@
 
 
 
+void flexiblas_real_csyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.csyr2k.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_csyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_csyr2k_")));
+
+
+void flexiblas_chain_csyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_csyr2k++;
+    if ( hook_pos_csyr2k < __flexiblas_hooks->csyr2k.nhook ) {
+        fn = __flexiblas_hooks->csyr2k.f77_hook_function[hook_pos_csyr2k];
+    } else {
+        hook_pos_csyr2k = 0;
+        fn = current_backend->blas.csyr2k.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_csyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_csyr2k_")));
+
+
+static TLS_STORE uint8_t hook_pos_csyrk = 0;
+
 void FC_GLOBAL(csyrk,CSYRK)(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* beta, float complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
@@ -965,6 +1883,40 @@
 
 
 
+void flexiblas_real_csyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.csyrk.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_csyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_csyrk_")));
+
+
+void flexiblas_chain_csyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_csyrk++;
+    if ( hook_pos_csyrk < __flexiblas_hooks->csyrk.nhook ) {
+        fn = __flexiblas_hooks->csyrk.f77_hook_function[hook_pos_csyrk];
+    } else {
+        hook_pos_csyrk = 0;
+        fn = current_backend->blas.csyrk.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_csyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_csyrk_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctbmv = 0;
+
 void FC_GLOBAL(ctbmv,CTBMV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float complex* a, blasint* lda, float complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -991,6 +1943,40 @@
 
 
 
+void flexiblas_real_ctbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ctbmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ctbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ctbmv_")));
+
+
+void flexiblas_chain_ctbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ctbmv++;
+    if ( hook_pos_ctbmv < __flexiblas_hooks->ctbmv.nhook ) {
+        fn = __flexiblas_hooks->ctbmv.f77_hook_function[hook_pos_ctbmv];
+    } else {
+        hook_pos_ctbmv = 0;
+        fn = current_backend->blas.ctbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ctbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ctbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctbsv = 0;
+
 void FC_GLOBAL(ctbsv,CTBSV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float complex* a, blasint* lda, float complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -1017,6 +2003,40 @@
 
 
 
+void flexiblas_real_ctbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ctbsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ctbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ctbsv_")));
+
+
+void flexiblas_chain_ctbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ctbsv++;
+    if ( hook_pos_ctbsv < __flexiblas_hooks->ctbsv.nhook ) {
+        fn = __flexiblas_hooks->ctbsv.f77_hook_function[hook_pos_ctbsv];
+    } else {
+        hook_pos_ctbsv = 0;
+        fn = current_backend->blas.ctbsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ctbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ctbsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctpmv = 0;
+
 void FC_GLOBAL(ctpmv,CTPMV)(char* uplo, char* trans, char* diag, blasint* n, float complex* ap, float complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -1043,6 +2063,40 @@
 
 
 
+void flexiblas_real_ctpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.ctpmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ctpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_ctpmv_")));
+
+
+void flexiblas_chain_ctpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_ctpmv++;
+    if ( hook_pos_ctpmv < __flexiblas_hooks->ctpmv.nhook ) {
+        fn = __flexiblas_hooks->ctpmv.f77_hook_function[hook_pos_ctpmv];
+    } else {
+        hook_pos_ctpmv = 0;
+        fn = current_backend->blas.ctpmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ctpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_ctpmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctpsv = 0;
+
 void FC_GLOBAL(ctpsv,CTPSV)(char* uplo, char* trans, char* diag, blasint* n, float complex* ap, float complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -1069,6 +2123,40 @@
 
 
 
+void flexiblas_real_ctpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.ctpsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ctpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_ctpsv_")));
+
+
+void flexiblas_chain_ctpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_ctpsv++;
+    if ( hook_pos_ctpsv < __flexiblas_hooks->ctpsv.nhook ) {
+        fn = __flexiblas_hooks->ctpsv.f77_hook_function[hook_pos_ctpsv];
+    } else {
+        hook_pos_ctpsv = 0;
+        fn = current_backend->blas.ctpsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ctpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_ctpsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctrmm = 0;
+
 void FC_GLOBAL(ctrmm,CTRMM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -1095,6 +2183,40 @@
 
 
 
+void flexiblas_real_ctrmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.ctrmm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_ctrmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_ctrmm_")));
+
+
+void flexiblas_chain_ctrmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_ctrmm++;
+    if ( hook_pos_ctrmm < __flexiblas_hooks->ctrmm.nhook ) {
+        fn = __flexiblas_hooks->ctrmm.f77_hook_function[hook_pos_ctrmm];
+    } else {
+        hook_pos_ctrmm = 0;
+        fn = current_backend->blas.ctrmm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_ctrmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_ctrmm_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctrmv = 0;
+
 void FC_GLOBAL(ctrmv,CTRMV)(char* uplo, char* trans, char* diag, blasint* n, float complex* a, blasint* lda, float complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -1121,6 +2243,40 @@
 
 
 
+void flexiblas_real_ctrmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ctrmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ctrmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ctrmv_")));
+
+
+void flexiblas_chain_ctrmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ctrmv++;
+    if ( hook_pos_ctrmv < __flexiblas_hooks->ctrmv.nhook ) {
+        fn = __flexiblas_hooks->ctrmv.f77_hook_function[hook_pos_ctrmv];
+    } else {
+        hook_pos_ctrmv = 0;
+        fn = current_backend->blas.ctrmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ctrmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ctrmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctrsm = 0;
+
 void FC_GLOBAL(ctrsm,CTRSM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -1147,6 +2303,40 @@
 
 
 
+void flexiblas_real_ctrsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.ctrsm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_ctrsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_ctrsm_")));
+
+
+void flexiblas_chain_ctrsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_ctrsm++;
+    if ( hook_pos_ctrsm < __flexiblas_hooks->ctrsm.nhook ) {
+        fn = __flexiblas_hooks->ctrsm.f77_hook_function[hook_pos_ctrsm];
+    } else {
+        hook_pos_ctrsm = 0;
+        fn = current_backend->blas.ctrsm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_ctrsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_ctrsm_")));
+
+
+static TLS_STORE uint8_t hook_pos_ctrsv = 0;
+
 void FC_GLOBAL(ctrsv,CTRSV)(char* uplo, char* trans, char* diag, blasint* n, float complex* a, blasint* lda, float complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -1173,6 +2363,40 @@
 
 
 
+void flexiblas_real_ctrsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ctrsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ctrsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ctrsv_")));
+
+
+void flexiblas_chain_ctrsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ctrsv++;
+    if ( hook_pos_ctrsv < __flexiblas_hooks->ctrsv.nhook ) {
+        fn = __flexiblas_hooks->ctrsv.f77_hook_function[hook_pos_ctrsv];
+    } else {
+        hook_pos_ctrsv = 0;
+        fn = current_backend->blas.ctrsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ctrsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ctrsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dasum = 0;
+
 double FC_GLOBAL(dasum,DASUM)(blasint* n, double* dx, blasint* incx)
 {
 	double (*fn) (void* n, void* dx, void* incx);
@@ -1200,6 +2424,42 @@
 
 
 
+double flexiblas_real_dasum_(void* n, void* dx, void* incx)
+{
+	double (*fn) (void* n, void* dx, void* incx);
+	double ret;
+
+	fn = current_backend->blas.dasum.f77_blas_function;
+	ret = fn((void*) n, (void*) dx, (void*) incx);
+
+	return ret;
+}
+double flexiblas_real_dasum(void* n, void* dx, void* incx) __attribute__((alias("flexiblas_real_dasum_")));
+
+
+double flexiblas_chain_dasum_(void* n, void* dx, void* incx)
+{
+	double (*fn) (void* n, void* dx, void* incx);
+	double ret;
+
+
+
+    hook_pos_dasum++;
+    if ( hook_pos_dasum < __flexiblas_hooks->dasum.nhook ) {
+        fn = __flexiblas_hooks->dasum.f77_hook_function[hook_pos_dasum];
+    } else {
+        hook_pos_dasum = 0;
+        fn = current_backend->blas.dasum.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) dx, (void*) incx);
+
+	return ret;
+}
+double flexiblas_chain_dasum(void* n, void* dx, void* incx) __attribute__((alias("flexiblas_chain_dasum_")));
+
+
+static TLS_STORE uint8_t hook_pos_daxpy = 0;
+
 void FC_GLOBAL(daxpy,DAXPY)(blasint* n, double* da, double* dx, blasint* incx, double* dy, blasint* incy)
 {
 	void (*fn) (void* n, void* da, void* dx, void* incx, void* dy, void* incy);
@@ -1226,6 +2486,40 @@
 
 
 
+void flexiblas_real_daxpy_(void* n, void* da, void* dx, void* incx, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* da, void* dx, void* incx, void* dy, void* incy);
+
+	fn = current_backend->blas.daxpy.f77_blas_function;
+	fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_daxpy(void* n, void* da, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_real_daxpy_")));
+
+
+void flexiblas_chain_daxpy_(void* n, void* da, void* dx, void* incx, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* da, void* dx, void* incx, void* dy, void* incy);
+
+
+
+    hook_pos_daxpy++;
+    if ( hook_pos_daxpy < __flexiblas_hooks->daxpy.nhook ) {
+        fn = __flexiblas_hooks->daxpy.f77_hook_function[hook_pos_daxpy];
+    } else {
+        hook_pos_daxpy = 0;
+        fn = current_backend->blas.daxpy.f77_blas_function;
+    }
+	fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_daxpy(void* n, void* da, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_chain_daxpy_")));
+
+
+static TLS_STORE uint8_t hook_pos_dcopy = 0;
+
 void FC_GLOBAL(dcopy,DCOPY)(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy)
 {
 	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
@@ -1252,6 +2546,40 @@
 
 
 
+void flexiblas_real_dcopy_(void* n, void* dx, void* incx, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
+
+	fn = current_backend->blas.dcopy.f77_blas_function;
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dcopy(void* n, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_real_dcopy_")));
+
+
+void flexiblas_chain_dcopy_(void* n, void* dx, void* incx, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
+
+
+
+    hook_pos_dcopy++;
+    if ( hook_pos_dcopy < __flexiblas_hooks->dcopy.nhook ) {
+        fn = __flexiblas_hooks->dcopy.f77_hook_function[hook_pos_dcopy];
+    } else {
+        hook_pos_dcopy = 0;
+        fn = current_backend->blas.dcopy.f77_blas_function;
+    }
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dcopy(void* n, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_chain_dcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_ddot = 0;
+
 double FC_GLOBAL(ddot,DDOT)(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy)
 {
 	double (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
@@ -1279,6 +2607,42 @@
 
 
 
+double flexiblas_real_ddot_(void* n, void* dx, void* incx, void* dy, void* incy)
+{
+	double (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
+	double ret;
+
+	fn = current_backend->blas.ddot.f77_blas_function;
+	ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return ret;
+}
+double flexiblas_real_ddot(void* n, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_real_ddot_")));
+
+
+double flexiblas_chain_ddot_(void* n, void* dx, void* incx, void* dy, void* incy)
+{
+	double (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
+	double ret;
+
+
+
+    hook_pos_ddot++;
+    if ( hook_pos_ddot < __flexiblas_hooks->ddot.nhook ) {
+        fn = __flexiblas_hooks->ddot.f77_hook_function[hook_pos_ddot];
+    } else {
+        hook_pos_ddot = 0;
+        fn = current_backend->blas.ddot.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return ret;
+}
+double flexiblas_chain_ddot(void* n, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_chain_ddot_")));
+
+
+static TLS_STORE uint8_t hook_pos_dgbmv = 0;
+
 void FC_GLOBAL(dgbmv,DGBMV)(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -1305,6 +2669,40 @@
 
 
 
+void flexiblas_real_dgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.dgbmv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_dgbmv_")));
+
+
+void flexiblas_chain_dgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_dgbmv++;
+    if ( hook_pos_dgbmv < __flexiblas_hooks->dgbmv.nhook ) {
+        fn = __flexiblas_hooks->dgbmv.f77_hook_function[hook_pos_dgbmv];
+    } else {
+        hook_pos_dgbmv = 0;
+        fn = current_backend->blas.dgbmv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_dgbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dgemm = 0;
+
 void FC_GLOBAL(dgemm,DGEMM)(char* transa, char* transb, blasint* m, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc)
 {
 	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -1331,6 +2729,40 @@
 
 
 
+void flexiblas_real_dgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.dgemm.f77_blas_function;
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_dgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_dgemm_")));
+
+
+void flexiblas_chain_dgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_dgemm++;
+    if ( hook_pos_dgemm < __flexiblas_hooks->dgemm.nhook ) {
+        fn = __flexiblas_hooks->dgemm.f77_hook_function[hook_pos_dgemm];
+    } else {
+        hook_pos_dgemm = 0;
+        fn = current_backend->blas.dgemm.f77_blas_function;
+    }
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_dgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_dgemm_")));
+
+
+static TLS_STORE uint8_t hook_pos_dgemv = 0;
+
 void FC_GLOBAL(dgemv,DGEMV)(char* trans, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -1357,6 +2789,40 @@
 
 
 
+void flexiblas_real_dgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.dgemv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_dgemv_")));
+
+
+void flexiblas_chain_dgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_dgemv++;
+    if ( hook_pos_dgemv < __flexiblas_hooks->dgemv.nhook ) {
+        fn = __flexiblas_hooks->dgemv.f77_hook_function[hook_pos_dgemv];
+    } else {
+        hook_pos_dgemv = 0;
+        fn = current_backend->blas.dgemv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_dgemv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dger = 0;
+
 void FC_GLOBAL(dger,DGER)(blasint* m, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* a, blasint* lda)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -1383,6 +2849,40 @@
 
 
 
+void flexiblas_real_dger_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.dger.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_dger(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_dger_")));
+
+
+void flexiblas_chain_dger_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_dger++;
+    if ( hook_pos_dger < __flexiblas_hooks->dger.nhook ) {
+        fn = __flexiblas_hooks->dger.f77_hook_function[hook_pos_dger];
+    } else {
+        hook_pos_dger = 0;
+        fn = current_backend->blas.dger.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_dger(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_dger_")));
+
+
+static TLS_STORE uint8_t hook_pos_dnrm2 = 0;
+
 double FC_GLOBAL(dnrm2,DNRM2)(blasint* n, double* x, blasint* incx)
 {
 	double (*fn) (void* n, void* x, void* incx);
@@ -1410,6 +2910,42 @@
 
 
 
+double flexiblas_real_dnrm2_(void* n, void* x, void* incx)
+{
+	double (*fn) (void* n, void* x, void* incx);
+	double ret;
+
+	fn = current_backend->blas.dnrm2.f77_blas_function;
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+double flexiblas_real_dnrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_real_dnrm2_")));
+
+
+double flexiblas_chain_dnrm2_(void* n, void* x, void* incx)
+{
+	double (*fn) (void* n, void* x, void* incx);
+	double ret;
+
+
+
+    hook_pos_dnrm2++;
+    if ( hook_pos_dnrm2 < __flexiblas_hooks->dnrm2.nhook ) {
+        fn = __flexiblas_hooks->dnrm2.f77_hook_function[hook_pos_dnrm2];
+    } else {
+        hook_pos_dnrm2 = 0;
+        fn = current_backend->blas.dnrm2.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+double flexiblas_chain_dnrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_chain_dnrm2_")));
+
+
+static TLS_STORE uint8_t hook_pos_drot = 0;
+
 void FC_GLOBAL(drot,DROT)(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy, double* c, double* s)
 {
 	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s);
@@ -1436,6 +2972,40 @@
 
 
 
+void flexiblas_real_drot_(void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s);
+
+	fn = current_backend->blas.drot.f77_blas_function;
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_drot(void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_real_drot_")));
+
+
+void flexiblas_chain_drot_(void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s);
+
+
+
+    hook_pos_drot++;
+    if ( hook_pos_drot < __flexiblas_hooks->drot.nhook ) {
+        fn = __flexiblas_hooks->drot.f77_hook_function[hook_pos_drot];
+    } else {
+        hook_pos_drot = 0;
+        fn = current_backend->blas.drot.f77_blas_function;
+    }
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_drot(void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_chain_drot_")));
+
+
+static TLS_STORE uint8_t hook_pos_drotg = 0;
+
 void FC_GLOBAL(drotg,DROTG)(double* da, double* db, double* c, double* s)
 {
 	void (*fn) (void* da, void* db, void* c, void* s);
@@ -1462,6 +3032,40 @@
 
 
 
+void flexiblas_real_drotg_(void* da, void* db, void* c, void* s)
+{
+	void (*fn) (void* da, void* db, void* c, void* s);
+
+	fn = current_backend->blas.drotg.f77_blas_function;
+	fn((void*) da, (void*) db, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_drotg(void* da, void* db, void* c, void* s) __attribute__((alias("flexiblas_real_drotg_")));
+
+
+void flexiblas_chain_drotg_(void* da, void* db, void* c, void* s)
+{
+	void (*fn) (void* da, void* db, void* c, void* s);
+
+
+
+    hook_pos_drotg++;
+    if ( hook_pos_drotg < __flexiblas_hooks->drotg.nhook ) {
+        fn = __flexiblas_hooks->drotg.f77_hook_function[hook_pos_drotg];
+    } else {
+        hook_pos_drotg = 0;
+        fn = current_backend->blas.drotg.f77_blas_function;
+    }
+	fn((void*) da, (void*) db, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_drotg(void* da, void* db, void* c, void* s) __attribute__((alias("flexiblas_chain_drotg_")));
+
+
+static TLS_STORE uint8_t hook_pos_drotm = 0;
+
 void FC_GLOBAL(drotm,DROTM)(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy, double* dparam)
 {
 	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* dparam);
@@ -1488,6 +3092,40 @@
 
 
 
+void flexiblas_real_drotm_(void* n, void* dx, void* incx, void* dy, void* incy, void* dparam)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* dparam);
+
+	fn = current_backend->blas.drotm.f77_blas_function;
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam);
+
+	return;
+}
+void flexiblas_real_drotm(void* n, void* dx, void* incx, void* dy, void* incy, void* dparam) __attribute__((alias("flexiblas_real_drotm_")));
+
+
+void flexiblas_chain_drotm_(void* n, void* dx, void* incx, void* dy, void* incy, void* dparam)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* dparam);
+
+
+
+    hook_pos_drotm++;
+    if ( hook_pos_drotm < __flexiblas_hooks->drotm.nhook ) {
+        fn = __flexiblas_hooks->drotm.f77_hook_function[hook_pos_drotm];
+    } else {
+        hook_pos_drotm = 0;
+        fn = current_backend->blas.drotm.f77_blas_function;
+    }
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam);
+
+	return;
+}
+void flexiblas_chain_drotm(void* n, void* dx, void* incx, void* dy, void* incy, void* dparam) __attribute__((alias("flexiblas_chain_drotm_")));
+
+
+static TLS_STORE uint8_t hook_pos_drotmg = 0;
+
 void FC_GLOBAL(drotmg,DROTMG)(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam)
 {
 	void (*fn) (void* dd1, void* dd2, void* dx1, void* dy1, void* dparam);
@@ -1514,6 +3152,40 @@
 
 
 
+void flexiblas_real_drotmg_(void* dd1, void* dd2, void* dx1, void* dy1, void* dparam)
+{
+	void (*fn) (void* dd1, void* dd2, void* dx1, void* dy1, void* dparam);
+
+	fn = current_backend->blas.drotmg.f77_blas_function;
+	fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam);
+
+	return;
+}
+void flexiblas_real_drotmg(void* dd1, void* dd2, void* dx1, void* dy1, void* dparam) __attribute__((alias("flexiblas_real_drotmg_")));
+
+
+void flexiblas_chain_drotmg_(void* dd1, void* dd2, void* dx1, void* dy1, void* dparam)
+{
+	void (*fn) (void* dd1, void* dd2, void* dx1, void* dy1, void* dparam);
+
+
+
+    hook_pos_drotmg++;
+    if ( hook_pos_drotmg < __flexiblas_hooks->drotmg.nhook ) {
+        fn = __flexiblas_hooks->drotmg.f77_hook_function[hook_pos_drotmg];
+    } else {
+        hook_pos_drotmg = 0;
+        fn = current_backend->blas.drotmg.f77_blas_function;
+    }
+	fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam);
+
+	return;
+}
+void flexiblas_chain_drotmg(void* dd1, void* dd2, void* dx1, void* dy1, void* dparam) __attribute__((alias("flexiblas_chain_drotmg_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsbmv = 0;
+
 void FC_GLOBAL(dsbmv,DSBMV)(char* uplo, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -1540,6 +3212,40 @@
 
 
 
+void flexiblas_real_dsbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.dsbmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dsbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_dsbmv_")));
+
+
+void flexiblas_chain_dsbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_dsbmv++;
+    if ( hook_pos_dsbmv < __flexiblas_hooks->dsbmv.nhook ) {
+        fn = __flexiblas_hooks->dsbmv.f77_hook_function[hook_pos_dsbmv];
+    } else {
+        hook_pos_dsbmv = 0;
+        fn = current_backend->blas.dsbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dsbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_dsbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dscal = 0;
+
 void FC_GLOBAL(dscal,DSCAL)(blasint* n, double* da, double* dx, blasint* incx)
 {
 	void (*fn) (void* n, void* da, void* dx, void* incx);
@@ -1566,6 +3272,40 @@
 
 
 
+void flexiblas_real_dscal_(void* n, void* da, void* dx, void* incx)
+{
+	void (*fn) (void* n, void* da, void* dx, void* incx);
+
+	fn = current_backend->blas.dscal.f77_blas_function;
+	fn((void*) n, (void*) da, (void*) dx, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dscal(void* n, void* da, void* dx, void* incx) __attribute__((alias("flexiblas_real_dscal_")));
+
+
+void flexiblas_chain_dscal_(void* n, void* da, void* dx, void* incx)
+{
+	void (*fn) (void* n, void* da, void* dx, void* incx);
+
+
+
+    hook_pos_dscal++;
+    if ( hook_pos_dscal < __flexiblas_hooks->dscal.nhook ) {
+        fn = __flexiblas_hooks->dscal.f77_hook_function[hook_pos_dscal];
+    } else {
+        hook_pos_dscal = 0;
+        fn = current_backend->blas.dscal.f77_blas_function;
+    }
+	fn((void*) n, (void*) da, (void*) dx, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dscal(void* n, void* da, void* dx, void* incx) __attribute__((alias("flexiblas_chain_dscal_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsdot = 0;
+
 double FC_GLOBAL(dsdot,DSDOT)(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
 {
 	double (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
@@ -1593,6 +3333,42 @@
 
 
 
+double flexiblas_real_dsdot_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	double (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+	double ret;
+
+	fn = current_backend->blas.dsdot.f77_blas_function;
+	ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return ret;
+}
+double flexiblas_real_dsdot(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_real_dsdot_")));
+
+
+double flexiblas_chain_dsdot_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	double (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+	double ret;
+
+
+
+    hook_pos_dsdot++;
+    if ( hook_pos_dsdot < __flexiblas_hooks->dsdot.nhook ) {
+        fn = __flexiblas_hooks->dsdot.f77_hook_function[hook_pos_dsdot];
+    } else {
+        hook_pos_dsdot = 0;
+        fn = current_backend->blas.dsdot.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return ret;
+}
+double flexiblas_chain_dsdot(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_chain_dsdot_")));
+
+
+static TLS_STORE uint8_t hook_pos_dspmv = 0;
+
 void FC_GLOBAL(dspmv,DSPMV)(char* uplo, blasint* n, double* alpha, double* ap, double* x, blasint* incx, double* beta, double* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
@@ -1619,6 +3395,40 @@
 
 
 
+void flexiblas_real_dspmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.dspmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dspmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_dspmv_")));
+
+
+void flexiblas_chain_dspmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_dspmv++;
+    if ( hook_pos_dspmv < __flexiblas_hooks->dspmv.nhook ) {
+        fn = __flexiblas_hooks->dspmv.f77_hook_function[hook_pos_dspmv];
+    } else {
+        hook_pos_dspmv = 0;
+        fn = current_backend->blas.dspmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dspmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_dspmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dspr = 0;
+
 void FC_GLOBAL(dspr,DSPR)(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
@@ -1645,6 +3455,40 @@
 
 
 
+void flexiblas_real_dspr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+	fn = current_backend->blas.dspr.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_real_dspr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_real_dspr_")));
+
+
+void flexiblas_chain_dspr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+
+
+    hook_pos_dspr++;
+    if ( hook_pos_dspr < __flexiblas_hooks->dspr.nhook ) {
+        fn = __flexiblas_hooks->dspr.f77_hook_function[hook_pos_dspr];
+    } else {
+        hook_pos_dspr = 0;
+        fn = current_backend->blas.dspr.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_dspr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_chain_dspr_")));
+
+
+static TLS_STORE uint8_t hook_pos_dspr2 = 0;
+
 void FC_GLOBAL(dspr2,DSPR2)(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
@@ -1671,6 +3515,40 @@
 
 
 
+void flexiblas_real_dspr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+	fn = current_backend->blas.dspr2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_real_dspr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_real_dspr2_")));
+
+
+void flexiblas_chain_dspr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+
+
+    hook_pos_dspr2++;
+    if ( hook_pos_dspr2 < __flexiblas_hooks->dspr2.nhook ) {
+        fn = __flexiblas_hooks->dspr2.f77_hook_function[hook_pos_dspr2];
+    } else {
+        hook_pos_dspr2 = 0;
+        fn = current_backend->blas.dspr2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_dspr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_chain_dspr2_")));
+
+
+static TLS_STORE uint8_t hook_pos_dswap = 0;
+
 void FC_GLOBAL(dswap,DSWAP)(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy)
 {
 	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
@@ -1697,6 +3575,40 @@
 
 
 
+void flexiblas_real_dswap_(void* n, void* dx, void* incx, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
+
+	fn = current_backend->blas.dswap.f77_blas_function;
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dswap(void* n, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_real_dswap_")));
+
+
+void flexiblas_chain_dswap_(void* n, void* dx, void* incx, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
+
+
+
+    hook_pos_dswap++;
+    if ( hook_pos_dswap < __flexiblas_hooks->dswap.nhook ) {
+        fn = __flexiblas_hooks->dswap.f77_hook_function[hook_pos_dswap];
+    } else {
+        hook_pos_dswap = 0;
+        fn = current_backend->blas.dswap.f77_blas_function;
+    }
+	fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dswap(void* n, void* dx, void* incx, void* dy, void* incy) __attribute__((alias("flexiblas_chain_dswap_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsymm = 0;
+
 void FC_GLOBAL(dsymm,DSYMM)(char* side, char* uplo, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc)
 {
 	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -1723,6 +3635,40 @@
 
 
 
+void flexiblas_real_dsymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.dsymm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_dsymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_dsymm_")));
+
+
+void flexiblas_chain_dsymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_dsymm++;
+    if ( hook_pos_dsymm < __flexiblas_hooks->dsymm.nhook ) {
+        fn = __flexiblas_hooks->dsymm.f77_hook_function[hook_pos_dsymm];
+    } else {
+        hook_pos_dsymm = 0;
+        fn = current_backend->blas.dsymm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_dsymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_dsymm_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsymv = 0;
+
 void FC_GLOBAL(dsymv,DSYMV)(char* uplo, blasint* n, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -1749,6 +3695,40 @@
 
 
 
+void flexiblas_real_dsymv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.dsymv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_dsymv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_dsymv_")));
+
+
+void flexiblas_chain_dsymv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_dsymv++;
+    if ( hook_pos_dsymv < __flexiblas_hooks->dsymv.nhook ) {
+        fn = __flexiblas_hooks->dsymv.f77_hook_function[hook_pos_dsymv];
+    } else {
+        hook_pos_dsymv = 0;
+        fn = current_backend->blas.dsymv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_dsymv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_dsymv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsyr = 0;
+
 void FC_GLOBAL(dsyr,DSYR)(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
@@ -1775,6 +3755,40 @@
 
 
 
+void flexiblas_real_dsyr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+	fn = current_backend->blas.dsyr.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_dsyr(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_real_dsyr_")));
+
+
+void flexiblas_chain_dsyr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+
+
+    hook_pos_dsyr++;
+    if ( hook_pos_dsyr < __flexiblas_hooks->dsyr.nhook ) {
+        fn = __flexiblas_hooks->dsyr.f77_hook_function[hook_pos_dsyr];
+    } else {
+        hook_pos_dsyr = 0;
+        fn = current_backend->blas.dsyr.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_dsyr(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_chain_dsyr_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsyr2 = 0;
+
 void FC_GLOBAL(dsyr2,DSYR2)(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -1801,6 +3815,40 @@
 
 
 
+void flexiblas_real_dsyr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.dsyr2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_dsyr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_dsyr2_")));
+
+
+void flexiblas_chain_dsyr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_dsyr2++;
+    if ( hook_pos_dsyr2 < __flexiblas_hooks->dsyr2.nhook ) {
+        fn = __flexiblas_hooks->dsyr2.f77_hook_function[hook_pos_dsyr2];
+    } else {
+        hook_pos_dsyr2 = 0;
+        fn = current_backend->blas.dsyr2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_dsyr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_dsyr2_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsyr2k = 0;
+
 void FC_GLOBAL(dsyr2k,DSYR2K)(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -1827,6 +3875,40 @@
 
 
 
+void flexiblas_real_dsyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.dsyr2k.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_dsyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_dsyr2k_")));
+
+
+void flexiblas_chain_dsyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_dsyr2k++;
+    if ( hook_pos_dsyr2k < __flexiblas_hooks->dsyr2k.nhook ) {
+        fn = __flexiblas_hooks->dsyr2k.f77_hook_function[hook_pos_dsyr2k];
+    } else {
+        hook_pos_dsyr2k = 0;
+        fn = current_backend->blas.dsyr2k.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_dsyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_dsyr2k_")));
+
+
+static TLS_STORE uint8_t hook_pos_dsyrk = 0;
+
 void FC_GLOBAL(dsyrk,DSYRK)(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* beta, double* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
@@ -1853,6 +3935,40 @@
 
 
 
+void flexiblas_real_dsyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.dsyrk.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_dsyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_dsyrk_")));
+
+
+void flexiblas_chain_dsyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_dsyrk++;
+    if ( hook_pos_dsyrk < __flexiblas_hooks->dsyrk.nhook ) {
+        fn = __flexiblas_hooks->dsyrk.f77_hook_function[hook_pos_dsyrk];
+    } else {
+        hook_pos_dsyrk = 0;
+        fn = current_backend->blas.dsyrk.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_dsyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_dsyrk_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtbmv = 0;
+
 void FC_GLOBAL(dtbmv,DTBMV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double* a, blasint* lda, double* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -1879,6 +3995,40 @@
 
 
 
+void flexiblas_real_dtbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.dtbmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dtbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_dtbmv_")));
+
+
+void flexiblas_chain_dtbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_dtbmv++;
+    if ( hook_pos_dtbmv < __flexiblas_hooks->dtbmv.nhook ) {
+        fn = __flexiblas_hooks->dtbmv.f77_hook_function[hook_pos_dtbmv];
+    } else {
+        hook_pos_dtbmv = 0;
+        fn = current_backend->blas.dtbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dtbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_dtbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtbsv = 0;
+
 void FC_GLOBAL(dtbsv,DTBSV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double* a, blasint* lda, double* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -1905,6 +4055,40 @@
 
 
 
+void flexiblas_real_dtbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.dtbsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dtbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_dtbsv_")));
+
+
+void flexiblas_chain_dtbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_dtbsv++;
+    if ( hook_pos_dtbsv < __flexiblas_hooks->dtbsv.nhook ) {
+        fn = __flexiblas_hooks->dtbsv.f77_hook_function[hook_pos_dtbsv];
+    } else {
+        hook_pos_dtbsv = 0;
+        fn = current_backend->blas.dtbsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dtbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_dtbsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtpmv = 0;
+
 void FC_GLOBAL(dtpmv,DTPMV)(char* uplo, char* trans, char* diag, blasint* n, double* ap, double* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -1931,6 +4115,40 @@
 
 
 
+void flexiblas_real_dtpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.dtpmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dtpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_dtpmv_")));
+
+
+void flexiblas_chain_dtpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_dtpmv++;
+    if ( hook_pos_dtpmv < __flexiblas_hooks->dtpmv.nhook ) {
+        fn = __flexiblas_hooks->dtpmv.f77_hook_function[hook_pos_dtpmv];
+    } else {
+        hook_pos_dtpmv = 0;
+        fn = current_backend->blas.dtpmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dtpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_dtpmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtpsv = 0;
+
 void FC_GLOBAL(dtpsv,DTPSV)(char* uplo, char* trans, char* diag, blasint* n, double* ap, double* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -1957,6 +4175,40 @@
 
 
 
+void flexiblas_real_dtpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.dtpsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dtpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_dtpsv_")));
+
+
+void flexiblas_chain_dtpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_dtpsv++;
+    if ( hook_pos_dtpsv < __flexiblas_hooks->dtpsv.nhook ) {
+        fn = __flexiblas_hooks->dtpsv.f77_hook_function[hook_pos_dtpsv];
+    } else {
+        hook_pos_dtpsv = 0;
+        fn = current_backend->blas.dtpsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dtpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_dtpsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtrmm = 0;
+
 void FC_GLOBAL(dtrmm,DTRMM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -1983,6 +4235,40 @@
 
 
 
+void flexiblas_real_dtrmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.dtrmm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_dtrmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_dtrmm_")));
+
+
+void flexiblas_chain_dtrmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_dtrmm++;
+    if ( hook_pos_dtrmm < __flexiblas_hooks->dtrmm.nhook ) {
+        fn = __flexiblas_hooks->dtrmm.f77_hook_function[hook_pos_dtrmm];
+    } else {
+        hook_pos_dtrmm = 0;
+        fn = current_backend->blas.dtrmm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_dtrmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_dtrmm_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtrmv = 0;
+
 void FC_GLOBAL(dtrmv,DTRMV)(char* uplo, char* trans, char* diag, blasint* n, double* a, blasint* lda, double* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -2009,6 +4295,40 @@
 
 
 
+void flexiblas_real_dtrmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.dtrmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dtrmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_dtrmv_")));
+
+
+void flexiblas_chain_dtrmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_dtrmv++;
+    if ( hook_pos_dtrmv < __flexiblas_hooks->dtrmv.nhook ) {
+        fn = __flexiblas_hooks->dtrmv.f77_hook_function[hook_pos_dtrmv];
+    } else {
+        hook_pos_dtrmv = 0;
+        fn = current_backend->blas.dtrmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dtrmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_dtrmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtrsm = 0;
+
 void FC_GLOBAL(dtrsm,DTRSM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -2035,6 +4355,40 @@
 
 
 
+void flexiblas_real_dtrsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.dtrsm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_dtrsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_dtrsm_")));
+
+
+void flexiblas_chain_dtrsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_dtrsm++;
+    if ( hook_pos_dtrsm < __flexiblas_hooks->dtrsm.nhook ) {
+        fn = __flexiblas_hooks->dtrsm.f77_hook_function[hook_pos_dtrsm];
+    } else {
+        hook_pos_dtrsm = 0;
+        fn = current_backend->blas.dtrsm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_dtrsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_dtrsm_")));
+
+
+static TLS_STORE uint8_t hook_pos_dtrsv = 0;
+
 void FC_GLOBAL(dtrsv,DTRSV)(char* uplo, char* trans, char* diag, blasint* n, double* a, blasint* lda, double* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -2061,6 +4415,40 @@
 
 
 
+void flexiblas_real_dtrsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.dtrsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_dtrsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_dtrsv_")));
+
+
+void flexiblas_chain_dtrsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_dtrsv++;
+    if ( hook_pos_dtrsv < __flexiblas_hooks->dtrsv.nhook ) {
+        fn = __flexiblas_hooks->dtrsv.f77_hook_function[hook_pos_dtrsv];
+    } else {
+        hook_pos_dtrsv = 0;
+        fn = current_backend->blas.dtrsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_dtrsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_dtrsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_dzasum = 0;
+
 double FC_GLOBAL(dzasum,DZASUM)(blasint* n, double complex* zx, blasint* incx)
 {
 	double (*fn) (void* n, void* zx, void* incx);
@@ -2088,6 +4476,42 @@
 
 
 
+double flexiblas_real_dzasum_(void* n, void* zx, void* incx)
+{
+	double (*fn) (void* n, void* zx, void* incx);
+	double ret;
+
+	fn = current_backend->blas.dzasum.f77_blas_function;
+	ret = fn((void*) n, (void*) zx, (void*) incx);
+
+	return ret;
+}
+double flexiblas_real_dzasum(void* n, void* zx, void* incx) __attribute__((alias("flexiblas_real_dzasum_")));
+
+
+double flexiblas_chain_dzasum_(void* n, void* zx, void* incx)
+{
+	double (*fn) (void* n, void* zx, void* incx);
+	double ret;
+
+
+
+    hook_pos_dzasum++;
+    if ( hook_pos_dzasum < __flexiblas_hooks->dzasum.nhook ) {
+        fn = __flexiblas_hooks->dzasum.f77_hook_function[hook_pos_dzasum];
+    } else {
+        hook_pos_dzasum = 0;
+        fn = current_backend->blas.dzasum.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) zx, (void*) incx);
+
+	return ret;
+}
+double flexiblas_chain_dzasum(void* n, void* zx, void* incx) __attribute__((alias("flexiblas_chain_dzasum_")));
+
+
+static TLS_STORE uint8_t hook_pos_dznrm2 = 0;
+
 double FC_GLOBAL(dznrm2,DZNRM2)(blasint* n, double complex* x, blasint* incx)
 {
 	double (*fn) (void* n, void* x, void* incx);
@@ -2115,6 +4539,42 @@
 
 
 
+double flexiblas_real_dznrm2_(void* n, void* x, void* incx)
+{
+	double (*fn) (void* n, void* x, void* incx);
+	double ret;
+
+	fn = current_backend->blas.dznrm2.f77_blas_function;
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+double flexiblas_real_dznrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_real_dznrm2_")));
+
+
+double flexiblas_chain_dznrm2_(void* n, void* x, void* incx)
+{
+	double (*fn) (void* n, void* x, void* incx);
+	double ret;
+
+
+
+    hook_pos_dznrm2++;
+    if ( hook_pos_dznrm2 < __flexiblas_hooks->dznrm2.nhook ) {
+        fn = __flexiblas_hooks->dznrm2.f77_hook_function[hook_pos_dznrm2];
+    } else {
+        hook_pos_dznrm2 = 0;
+        fn = current_backend->blas.dznrm2.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+double flexiblas_chain_dznrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_chain_dznrm2_")));
+
+
+static TLS_STORE uint8_t hook_pos_icamax = 0;
+
 int FC_GLOBAL(icamax,ICAMAX)(blasint* n, float complex* cx, blasint* incx)
 {
 	blasint (*fn) (void* n, void* cx, void* incx);
@@ -2142,6 +4602,42 @@
 
 
 
+blasint flexiblas_real_icamax_(void* n, void* cx, void* incx)
+{
+	blasint (*fn) (void* n, void* cx, void* incx);
+	blasint ret;
+
+	fn = current_backend->blas.icamax.f77_blas_function;
+	ret = fn((void*) n, (void*) cx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_real_icamax(void* n, void* cx, void* incx) __attribute__((alias("flexiblas_real_icamax_")));
+
+
+blasint flexiblas_chain_icamax_(void* n, void* cx, void* incx)
+{
+	blasint (*fn) (void* n, void* cx, void* incx);
+	blasint ret;
+
+
+
+    hook_pos_icamax++;
+    if ( hook_pos_icamax < __flexiblas_hooks->icamax.nhook ) {
+        fn = __flexiblas_hooks->icamax.f77_hook_function[hook_pos_icamax];
+    } else {
+        hook_pos_icamax = 0;
+        fn = current_backend->blas.icamax.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) cx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_chain_icamax(void* n, void* cx, void* incx) __attribute__((alias("flexiblas_chain_icamax_")));
+
+
+static TLS_STORE uint8_t hook_pos_idamax = 0;
+
 int FC_GLOBAL(idamax,IDAMAX)(blasint* n, double* dx, blasint* incx)
 {
 	blasint (*fn) (void* n, void* dx, void* incx);
@@ -2169,6 +4665,42 @@
 
 
 
+blasint flexiblas_real_idamax_(void* n, void* dx, void* incx)
+{
+	blasint (*fn) (void* n, void* dx, void* incx);
+	blasint ret;
+
+	fn = current_backend->blas.idamax.f77_blas_function;
+	ret = fn((void*) n, (void*) dx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_real_idamax(void* n, void* dx, void* incx) __attribute__((alias("flexiblas_real_idamax_")));
+
+
+blasint flexiblas_chain_idamax_(void* n, void* dx, void* incx)
+{
+	blasint (*fn) (void* n, void* dx, void* incx);
+	blasint ret;
+
+
+
+    hook_pos_idamax++;
+    if ( hook_pos_idamax < __flexiblas_hooks->idamax.nhook ) {
+        fn = __flexiblas_hooks->idamax.f77_hook_function[hook_pos_idamax];
+    } else {
+        hook_pos_idamax = 0;
+        fn = current_backend->blas.idamax.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) dx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_chain_idamax(void* n, void* dx, void* incx) __attribute__((alias("flexiblas_chain_idamax_")));
+
+
+static TLS_STORE uint8_t hook_pos_isamax = 0;
+
 int FC_GLOBAL(isamax,ISAMAX)(blasint* n, float* sx, blasint* incx)
 {
 	blasint (*fn) (void* n, void* sx, void* incx);
@@ -2196,6 +4728,42 @@
 
 
 
+blasint flexiblas_real_isamax_(void* n, void* sx, void* incx)
+{
+	blasint (*fn) (void* n, void* sx, void* incx);
+	blasint ret;
+
+	fn = current_backend->blas.isamax.f77_blas_function;
+	ret = fn((void*) n, (void*) sx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_real_isamax(void* n, void* sx, void* incx) __attribute__((alias("flexiblas_real_isamax_")));
+
+
+blasint flexiblas_chain_isamax_(void* n, void* sx, void* incx)
+{
+	blasint (*fn) (void* n, void* sx, void* incx);
+	blasint ret;
+
+
+
+    hook_pos_isamax++;
+    if ( hook_pos_isamax < __flexiblas_hooks->isamax.nhook ) {
+        fn = __flexiblas_hooks->isamax.f77_hook_function[hook_pos_isamax];
+    } else {
+        hook_pos_isamax = 0;
+        fn = current_backend->blas.isamax.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) sx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_chain_isamax(void* n, void* sx, void* incx) __attribute__((alias("flexiblas_chain_isamax_")));
+
+
+static TLS_STORE uint8_t hook_pos_izamax = 0;
+
 int FC_GLOBAL(izamax,IZAMAX)(blasint* n, double complex* zx, blasint* incx)
 {
 	blasint (*fn) (void* n, void* zx, void* incx);
@@ -2223,6 +4791,42 @@
 
 
 
+blasint flexiblas_real_izamax_(void* n, void* zx, void* incx)
+{
+	blasint (*fn) (void* n, void* zx, void* incx);
+	blasint ret;
+
+	fn = current_backend->blas.izamax.f77_blas_function;
+	ret = fn((void*) n, (void*) zx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_real_izamax(void* n, void* zx, void* incx) __attribute__((alias("flexiblas_real_izamax_")));
+
+
+blasint flexiblas_chain_izamax_(void* n, void* zx, void* incx)
+{
+	blasint (*fn) (void* n, void* zx, void* incx);
+	blasint ret;
+
+
+
+    hook_pos_izamax++;
+    if ( hook_pos_izamax < __flexiblas_hooks->izamax.nhook ) {
+        fn = __flexiblas_hooks->izamax.f77_hook_function[hook_pos_izamax];
+    } else {
+        hook_pos_izamax = 0;
+        fn = current_backend->blas.izamax.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) zx, (void*) incx);
+
+	return ret;
+}
+blasint flexiblas_chain_izamax(void* n, void* zx, void* incx) __attribute__((alias("flexiblas_chain_izamax_")));
+
+
+static TLS_STORE uint8_t hook_pos_sasum = 0;
+
 float FC_GLOBAL(sasum,SASUM)(blasint* n, float* sx, blasint* incx)
 {
 	float (*fn) (void* n, void* sx, void* incx);
@@ -2250,6 +4854,42 @@
 
 
 
+float flexiblas_real_sasum_(void* n, void* sx, void* incx)
+{
+	float (*fn) (void* n, void* sx, void* incx);
+	float ret;
+
+	fn = current_backend->blas.sasum.f77_blas_function;
+	ret = fn((void*) n, (void*) sx, (void*) incx);
+
+	return ret;
+}
+float flexiblas_real_sasum(void* n, void* sx, void* incx) __attribute__((alias("flexiblas_real_sasum_")));
+
+
+float flexiblas_chain_sasum_(void* n, void* sx, void* incx)
+{
+	float (*fn) (void* n, void* sx, void* incx);
+	float ret;
+
+
+
+    hook_pos_sasum++;
+    if ( hook_pos_sasum < __flexiblas_hooks->sasum.nhook ) {
+        fn = __flexiblas_hooks->sasum.f77_hook_function[hook_pos_sasum];
+    } else {
+        hook_pos_sasum = 0;
+        fn = current_backend->blas.sasum.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) sx, (void*) incx);
+
+	return ret;
+}
+float flexiblas_chain_sasum(void* n, void* sx, void* incx) __attribute__((alias("flexiblas_chain_sasum_")));
+
+
+static TLS_STORE uint8_t hook_pos_saxpy = 0;
+
 void FC_GLOBAL(saxpy,SAXPY)(blasint* n, float* sa, float* sx, blasint* incx, float* sy, blasint* incy)
 {
 	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sy, void* incy);
@@ -2276,6 +4916,40 @@
 
 
 
+void flexiblas_real_saxpy_(void* n, void* sa, void* sx, void* incx, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sy, void* incy);
+
+	fn = current_backend->blas.saxpy.f77_blas_function;
+	fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_saxpy(void* n, void* sa, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_real_saxpy_")));
+
+
+void flexiblas_chain_saxpy_(void* n, void* sa, void* sx, void* incx, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sy, void* incy);
+
+
+
+    hook_pos_saxpy++;
+    if ( hook_pos_saxpy < __flexiblas_hooks->saxpy.nhook ) {
+        fn = __flexiblas_hooks->saxpy.f77_hook_function[hook_pos_saxpy];
+    } else {
+        hook_pos_saxpy = 0;
+        fn = current_backend->blas.saxpy.f77_blas_function;
+    }
+	fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_saxpy(void* n, void* sa, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_chain_saxpy_")));
+
+
+static TLS_STORE uint8_t hook_pos_scasum = 0;
+
 float FC_GLOBAL(scasum,SCASUM)(blasint* n, float complex* cx, blasint* incx)
 {
 	float (*fn) (void* n, void* cx, void* incx);
@@ -2303,6 +4977,42 @@
 
 
 
+float flexiblas_real_scasum_(void* n, void* cx, void* incx)
+{
+	float (*fn) (void* n, void* cx, void* incx);
+	float ret;
+
+	fn = current_backend->blas.scasum.f77_blas_function;
+	ret = fn((void*) n, (void*) cx, (void*) incx);
+
+	return ret;
+}
+float flexiblas_real_scasum(void* n, void* cx, void* incx) __attribute__((alias("flexiblas_real_scasum_")));
+
+
+float flexiblas_chain_scasum_(void* n, void* cx, void* incx)
+{
+	float (*fn) (void* n, void* cx, void* incx);
+	float ret;
+
+
+
+    hook_pos_scasum++;
+    if ( hook_pos_scasum < __flexiblas_hooks->scasum.nhook ) {
+        fn = __flexiblas_hooks->scasum.f77_hook_function[hook_pos_scasum];
+    } else {
+        hook_pos_scasum = 0;
+        fn = current_backend->blas.scasum.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) cx, (void*) incx);
+
+	return ret;
+}
+float flexiblas_chain_scasum(void* n, void* cx, void* incx) __attribute__((alias("flexiblas_chain_scasum_")));
+
+
+static TLS_STORE uint8_t hook_pos_scnrm2 = 0;
+
 float FC_GLOBAL(scnrm2,SCNRM2)(blasint* n, float complex* x, blasint* incx)
 {
 	float (*fn) (void* n, void* x, void* incx);
@@ -2330,6 +5040,42 @@
 
 
 
+float flexiblas_real_scnrm2_(void* n, void* x, void* incx)
+{
+	float (*fn) (void* n, void* x, void* incx);
+	float ret;
+
+	fn = current_backend->blas.scnrm2.f77_blas_function;
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+float flexiblas_real_scnrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_real_scnrm2_")));
+
+
+float flexiblas_chain_scnrm2_(void* n, void* x, void* incx)
+{
+	float (*fn) (void* n, void* x, void* incx);
+	float ret;
+
+
+
+    hook_pos_scnrm2++;
+    if ( hook_pos_scnrm2 < __flexiblas_hooks->scnrm2.nhook ) {
+        fn = __flexiblas_hooks->scnrm2.f77_hook_function[hook_pos_scnrm2];
+    } else {
+        hook_pos_scnrm2 = 0;
+        fn = current_backend->blas.scnrm2.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+float flexiblas_chain_scnrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_chain_scnrm2_")));
+
+
+static TLS_STORE uint8_t hook_pos_scopy = 0;
+
 void FC_GLOBAL(scopy,SCOPY)(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
 {
 	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
@@ -2356,6 +5102,40 @@
 
 
 
+void flexiblas_real_scopy_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+
+	fn = current_backend->blas.scopy.f77_blas_function;
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_scopy(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_real_scopy_")));
+
+
+void flexiblas_chain_scopy_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+
+
+
+    hook_pos_scopy++;
+    if ( hook_pos_scopy < __flexiblas_hooks->scopy.nhook ) {
+        fn = __flexiblas_hooks->scopy.f77_hook_function[hook_pos_scopy];
+    } else {
+        hook_pos_scopy = 0;
+        fn = current_backend->blas.scopy.f77_blas_function;
+    }
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_scopy(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_chain_scopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_sdot = 0;
+
 float FC_GLOBAL(sdot,SDOT)(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
 {
 	float (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
@@ -2383,6 +5163,42 @@
 
 
 
+float flexiblas_real_sdot_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	float (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+	float ret;
+
+	fn = current_backend->blas.sdot.f77_blas_function;
+	ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return ret;
+}
+float flexiblas_real_sdot(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_real_sdot_")));
+
+
+float flexiblas_chain_sdot_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	float (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+	float ret;
+
+
+
+    hook_pos_sdot++;
+    if ( hook_pos_sdot < __flexiblas_hooks->sdot.nhook ) {
+        fn = __flexiblas_hooks->sdot.f77_hook_function[hook_pos_sdot];
+    } else {
+        hook_pos_sdot = 0;
+        fn = current_backend->blas.sdot.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return ret;
+}
+float flexiblas_chain_sdot(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_chain_sdot_")));
+
+
+static TLS_STORE uint8_t hook_pos_sdsdot = 0;
+
 float FC_GLOBAL(sdsdot,SDSDOT)(blasint* n, float* sb, float* sx, blasint* incx, float* sy, blasint* incy)
 {
 	float (*fn) (void* n, void* sb, void* sx, void* incx, void* sy, void* incy);
@@ -2410,6 +5226,42 @@
 
 
 
+float flexiblas_real_sdsdot_(void* n, void* sb, void* sx, void* incx, void* sy, void* incy)
+{
+	float (*fn) (void* n, void* sb, void* sx, void* incx, void* sy, void* incy);
+	float ret;
+
+	fn = current_backend->blas.sdsdot.f77_blas_function;
+	ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return ret;
+}
+float flexiblas_real_sdsdot(void* n, void* sb, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_real_sdsdot_")));
+
+
+float flexiblas_chain_sdsdot_(void* n, void* sb, void* sx, void* incx, void* sy, void* incy)
+{
+	float (*fn) (void* n, void* sb, void* sx, void* incx, void* sy, void* incy);
+	float ret;
+
+
+
+    hook_pos_sdsdot++;
+    if ( hook_pos_sdsdot < __flexiblas_hooks->sdsdot.nhook ) {
+        fn = __flexiblas_hooks->sdsdot.f77_hook_function[hook_pos_sdsdot];
+    } else {
+        hook_pos_sdsdot = 0;
+        fn = current_backend->blas.sdsdot.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return ret;
+}
+float flexiblas_chain_sdsdot(void* n, void* sb, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_chain_sdsdot_")));
+
+
+static TLS_STORE uint8_t hook_pos_sgbmv = 0;
+
 void FC_GLOBAL(sgbmv,SGBMV)(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -2436,6 +5288,40 @@
 
 
 
+void flexiblas_real_sgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.sgbmv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_sgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_sgbmv_")));
+
+
+void flexiblas_chain_sgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_sgbmv++;
+    if ( hook_pos_sgbmv < __flexiblas_hooks->sgbmv.nhook ) {
+        fn = __flexiblas_hooks->sgbmv.f77_hook_function[hook_pos_sgbmv];
+    } else {
+        hook_pos_sgbmv = 0;
+        fn = current_backend->blas.sgbmv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_sgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_sgbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_sgemm = 0;
+
 void FC_GLOBAL(sgemm,SGEMM)(char* transa, char* transb, blasint* m, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc)
 {
 	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -2462,6 +5348,40 @@
 
 
 
+void flexiblas_real_sgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.sgemm.f77_blas_function;
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_sgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_sgemm_")));
+
+
+void flexiblas_chain_sgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_sgemm++;
+    if ( hook_pos_sgemm < __flexiblas_hooks->sgemm.nhook ) {
+        fn = __flexiblas_hooks->sgemm.f77_hook_function[hook_pos_sgemm];
+    } else {
+        hook_pos_sgemm = 0;
+        fn = current_backend->blas.sgemm.f77_blas_function;
+    }
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_sgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_sgemm_")));
+
+
+static TLS_STORE uint8_t hook_pos_sgemv = 0;
+
 void FC_GLOBAL(sgemv,SGEMV)(char* trans, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -2488,6 +5408,40 @@
 
 
 
+void flexiblas_real_sgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.sgemv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_sgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_sgemv_")));
+
+
+void flexiblas_chain_sgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_sgemv++;
+    if ( hook_pos_sgemv < __flexiblas_hooks->sgemv.nhook ) {
+        fn = __flexiblas_hooks->sgemv.f77_hook_function[hook_pos_sgemv];
+    } else {
+        hook_pos_sgemv = 0;
+        fn = current_backend->blas.sgemv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_sgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_sgemv_")));
+
+
+static TLS_STORE uint8_t hook_pos_sger = 0;
+
 void FC_GLOBAL(sger,SGER)(blasint* m, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* a, blasint* lda)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -2514,6 +5468,40 @@
 
 
 
+void flexiblas_real_sger_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.sger.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_sger(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_sger_")));
+
+
+void flexiblas_chain_sger_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_sger++;
+    if ( hook_pos_sger < __flexiblas_hooks->sger.nhook ) {
+        fn = __flexiblas_hooks->sger.f77_hook_function[hook_pos_sger];
+    } else {
+        hook_pos_sger = 0;
+        fn = current_backend->blas.sger.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_sger(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_sger_")));
+
+
+static TLS_STORE uint8_t hook_pos_snrm2 = 0;
+
 float FC_GLOBAL(snrm2,SNRM2)(blasint* n, float* x, blasint* incx)
 {
 	float (*fn) (void* n, void* x, void* incx);
@@ -2541,6 +5529,42 @@
 
 
 
+float flexiblas_real_snrm2_(void* n, void* x, void* incx)
+{
+	float (*fn) (void* n, void* x, void* incx);
+	float ret;
+
+	fn = current_backend->blas.snrm2.f77_blas_function;
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+float flexiblas_real_snrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_real_snrm2_")));
+
+
+float flexiblas_chain_snrm2_(void* n, void* x, void* incx)
+{
+	float (*fn) (void* n, void* x, void* incx);
+	float ret;
+
+
+
+    hook_pos_snrm2++;
+    if ( hook_pos_snrm2 < __flexiblas_hooks->snrm2.nhook ) {
+        fn = __flexiblas_hooks->snrm2.f77_hook_function[hook_pos_snrm2];
+    } else {
+        hook_pos_snrm2 = 0;
+        fn = current_backend->blas.snrm2.f77_blas_function;
+    }
+	ret = fn((void*) n, (void*) x, (void*) incx);
+
+	return ret;
+}
+float flexiblas_chain_snrm2(void* n, void* x, void* incx) __attribute__((alias("flexiblas_chain_snrm2_")));
+
+
+static TLS_STORE uint8_t hook_pos_srot = 0;
+
 void FC_GLOBAL(srot,SROT)(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy, float* c, float* s)
 {
 	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s);
@@ -2567,6 +5591,40 @@
 
 
 
+void flexiblas_real_srot_(void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s);
+
+	fn = current_backend->blas.srot.f77_blas_function;
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_srot(void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_real_srot_")));
+
+
+void flexiblas_chain_srot_(void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s);
+
+
+
+    hook_pos_srot++;
+    if ( hook_pos_srot < __flexiblas_hooks->srot.nhook ) {
+        fn = __flexiblas_hooks->srot.f77_hook_function[hook_pos_srot];
+    } else {
+        hook_pos_srot = 0;
+        fn = current_backend->blas.srot.f77_blas_function;
+    }
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_srot(void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_chain_srot_")));
+
+
+static TLS_STORE uint8_t hook_pos_srotg = 0;
+
 void FC_GLOBAL(srotg,SROTG)(float* sa, float* sb, float* c, float* s)
 {
 	void (*fn) (void* sa, void* sb, void* c, void* s);
@@ -2593,6 +5651,40 @@
 
 
 
+void flexiblas_real_srotg_(void* sa, void* sb, void* c, void* s)
+{
+	void (*fn) (void* sa, void* sb, void* c, void* s);
+
+	fn = current_backend->blas.srotg.f77_blas_function;
+	fn((void*) sa, (void*) sb, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_srotg(void* sa, void* sb, void* c, void* s) __attribute__((alias("flexiblas_real_srotg_")));
+
+
+void flexiblas_chain_srotg_(void* sa, void* sb, void* c, void* s)
+{
+	void (*fn) (void* sa, void* sb, void* c, void* s);
+
+
+
+    hook_pos_srotg++;
+    if ( hook_pos_srotg < __flexiblas_hooks->srotg.nhook ) {
+        fn = __flexiblas_hooks->srotg.f77_hook_function[hook_pos_srotg];
+    } else {
+        hook_pos_srotg = 0;
+        fn = current_backend->blas.srotg.f77_blas_function;
+    }
+	fn((void*) sa, (void*) sb, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_srotg(void* sa, void* sb, void* c, void* s) __attribute__((alias("flexiblas_chain_srotg_")));
+
+
+static TLS_STORE uint8_t hook_pos_srotm = 0;
+
 void FC_GLOBAL(srotm,SROTM)(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy, float* sparam)
 {
 	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* sparam);
@@ -2619,6 +5711,40 @@
 
 
 
+void flexiblas_real_srotm_(void* n, void* sx, void* incx, void* sy, void* incy, void* sparam)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* sparam);
+
+	fn = current_backend->blas.srotm.f77_blas_function;
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam);
+
+	return;
+}
+void flexiblas_real_srotm(void* n, void* sx, void* incx, void* sy, void* incy, void* sparam) __attribute__((alias("flexiblas_real_srotm_")));
+
+
+void flexiblas_chain_srotm_(void* n, void* sx, void* incx, void* sy, void* incy, void* sparam)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* sparam);
+
+
+
+    hook_pos_srotm++;
+    if ( hook_pos_srotm < __flexiblas_hooks->srotm.nhook ) {
+        fn = __flexiblas_hooks->srotm.f77_hook_function[hook_pos_srotm];
+    } else {
+        hook_pos_srotm = 0;
+        fn = current_backend->blas.srotm.f77_blas_function;
+    }
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam);
+
+	return;
+}
+void flexiblas_chain_srotm(void* n, void* sx, void* incx, void* sy, void* incy, void* sparam) __attribute__((alias("flexiblas_chain_srotm_")));
+
+
+static TLS_STORE uint8_t hook_pos_srotmg = 0;
+
 void FC_GLOBAL(srotmg,SROTMG)(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam)
 {
 	void (*fn) (void* sd1, void* sd2, void* sx1, void* sy1, void* sparam);
@@ -2645,6 +5771,40 @@
 
 
 
+void flexiblas_real_srotmg_(void* sd1, void* sd2, void* sx1, void* sy1, void* sparam)
+{
+	void (*fn) (void* sd1, void* sd2, void* sx1, void* sy1, void* sparam);
+
+	fn = current_backend->blas.srotmg.f77_blas_function;
+	fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam);
+
+	return;
+}
+void flexiblas_real_srotmg(void* sd1, void* sd2, void* sx1, void* sy1, void* sparam) __attribute__((alias("flexiblas_real_srotmg_")));
+
+
+void flexiblas_chain_srotmg_(void* sd1, void* sd2, void* sx1, void* sy1, void* sparam)
+{
+	void (*fn) (void* sd1, void* sd2, void* sx1, void* sy1, void* sparam);
+
+
+
+    hook_pos_srotmg++;
+    if ( hook_pos_srotmg < __flexiblas_hooks->srotmg.nhook ) {
+        fn = __flexiblas_hooks->srotmg.f77_hook_function[hook_pos_srotmg];
+    } else {
+        hook_pos_srotmg = 0;
+        fn = current_backend->blas.srotmg.f77_blas_function;
+    }
+	fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam);
+
+	return;
+}
+void flexiblas_chain_srotmg(void* sd1, void* sd2, void* sx1, void* sy1, void* sparam) __attribute__((alias("flexiblas_chain_srotmg_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssbmv = 0;
+
 void FC_GLOBAL(ssbmv,SSBMV)(char* uplo, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -2671,6 +5831,40 @@
 
 
 
+void flexiblas_real_ssbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.ssbmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_ssbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_ssbmv_")));
+
+
+void flexiblas_chain_ssbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_ssbmv++;
+    if ( hook_pos_ssbmv < __flexiblas_hooks->ssbmv.nhook ) {
+        fn = __flexiblas_hooks->ssbmv.f77_hook_function[hook_pos_ssbmv];
+    } else {
+        hook_pos_ssbmv = 0;
+        fn = current_backend->blas.ssbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_ssbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_ssbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_sscal = 0;
+
 void FC_GLOBAL(sscal,SSCAL)(blasint* n, float* sa, float* sx, blasint* incx)
 {
 	void (*fn) (void* n, void* sa, void* sx, void* incx);
@@ -2697,6 +5891,40 @@
 
 
 
+void flexiblas_real_sscal_(void* n, void* sa, void* sx, void* incx)
+{
+	void (*fn) (void* n, void* sa, void* sx, void* incx);
+
+	fn = current_backend->blas.sscal.f77_blas_function;
+	fn((void*) n, (void*) sa, (void*) sx, (void*) incx);
+
+	return;
+}
+void flexiblas_real_sscal(void* n, void* sa, void* sx, void* incx) __attribute__((alias("flexiblas_real_sscal_")));
+
+
+void flexiblas_chain_sscal_(void* n, void* sa, void* sx, void* incx)
+{
+	void (*fn) (void* n, void* sa, void* sx, void* incx);
+
+
+
+    hook_pos_sscal++;
+    if ( hook_pos_sscal < __flexiblas_hooks->sscal.nhook ) {
+        fn = __flexiblas_hooks->sscal.f77_hook_function[hook_pos_sscal];
+    } else {
+        hook_pos_sscal = 0;
+        fn = current_backend->blas.sscal.f77_blas_function;
+    }
+	fn((void*) n, (void*) sa, (void*) sx, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_sscal(void* n, void* sa, void* sx, void* incx) __attribute__((alias("flexiblas_chain_sscal_")));
+
+
+static TLS_STORE uint8_t hook_pos_sspmv = 0;
+
 void FC_GLOBAL(sspmv,SSPMV)(char* uplo, blasint* n, float* alpha, float* ap, float* x, blasint* incx, float* beta, float* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
@@ -2723,6 +5951,40 @@
 
 
 
+void flexiblas_real_sspmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.sspmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_sspmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_sspmv_")));
+
+
+void flexiblas_chain_sspmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_sspmv++;
+    if ( hook_pos_sspmv < __flexiblas_hooks->sspmv.nhook ) {
+        fn = __flexiblas_hooks->sspmv.f77_hook_function[hook_pos_sspmv];
+    } else {
+        hook_pos_sspmv = 0;
+        fn = current_backend->blas.sspmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_sspmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_sspmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_sspr = 0;
+
 void FC_GLOBAL(sspr,SSPR)(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
@@ -2749,6 +6011,40 @@
 
 
 
+void flexiblas_real_sspr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+	fn = current_backend->blas.sspr.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_real_sspr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_real_sspr_")));
+
+
+void flexiblas_chain_sspr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+
+
+    hook_pos_sspr++;
+    if ( hook_pos_sspr < __flexiblas_hooks->sspr.nhook ) {
+        fn = __flexiblas_hooks->sspr.f77_hook_function[hook_pos_sspr];
+    } else {
+        hook_pos_sspr = 0;
+        fn = current_backend->blas.sspr.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_sspr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_chain_sspr_")));
+
+
+static TLS_STORE uint8_t hook_pos_sspr2 = 0;
+
 void FC_GLOBAL(sspr2,SSPR2)(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
@@ -2775,6 +6071,40 @@
 
 
 
+void flexiblas_real_sspr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+	fn = current_backend->blas.sspr2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_real_sspr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_real_sspr2_")));
+
+
+void flexiblas_chain_sspr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+
+
+    hook_pos_sspr2++;
+    if ( hook_pos_sspr2 < __flexiblas_hooks->sspr2.nhook ) {
+        fn = __flexiblas_hooks->sspr2.f77_hook_function[hook_pos_sspr2];
+    } else {
+        hook_pos_sspr2 = 0;
+        fn = current_backend->blas.sspr2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_sspr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_chain_sspr2_")));
+
+
+static TLS_STORE uint8_t hook_pos_sswap = 0;
+
 void FC_GLOBAL(sswap,SSWAP)(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
 {
 	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
@@ -2801,6 +6131,40 @@
 
 
 
+void flexiblas_real_sswap_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+
+	fn = current_backend->blas.sswap.f77_blas_function;
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_sswap(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_real_sswap_")));
+
+
+void flexiblas_chain_sswap_(void* n, void* sx, void* incx, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
+
+
+
+    hook_pos_sswap++;
+    if ( hook_pos_sswap < __flexiblas_hooks->sswap.nhook ) {
+        fn = __flexiblas_hooks->sswap.f77_hook_function[hook_pos_sswap];
+    } else {
+        hook_pos_sswap = 0;
+        fn = current_backend->blas.sswap.f77_blas_function;
+    }
+	fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_sswap(void* n, void* sx, void* incx, void* sy, void* incy) __attribute__((alias("flexiblas_chain_sswap_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssymm = 0;
+
 void FC_GLOBAL(ssymm,SSYMM)(char* side, char* uplo, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc)
 {
 	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -2827,6 +6191,40 @@
 
 
 
+void flexiblas_real_ssymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.ssymm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_ssymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_ssymm_")));
+
+
+void flexiblas_chain_ssymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_ssymm++;
+    if ( hook_pos_ssymm < __flexiblas_hooks->ssymm.nhook ) {
+        fn = __flexiblas_hooks->ssymm.f77_hook_function[hook_pos_ssymm];
+    } else {
+        hook_pos_ssymm = 0;
+        fn = current_backend->blas.ssymm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_ssymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_ssymm_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssymv = 0;
+
 void FC_GLOBAL(ssymv,SSYMV)(char* uplo, blasint* n, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -2853,6 +6251,40 @@
 
 
 
+void flexiblas_real_ssymv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.ssymv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_ssymv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_ssymv_")));
+
+
+void flexiblas_chain_ssymv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_ssymv++;
+    if ( hook_pos_ssymv < __flexiblas_hooks->ssymv.nhook ) {
+        fn = __flexiblas_hooks->ssymv.f77_hook_function[hook_pos_ssymv];
+    } else {
+        hook_pos_ssymv = 0;
+        fn = current_backend->blas.ssymv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_ssymv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_ssymv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssyr = 0;
+
 void FC_GLOBAL(ssyr,SSYR)(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
@@ -2879,6 +6311,40 @@
 
 
 
+void flexiblas_real_ssyr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+	fn = current_backend->blas.ssyr.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_ssyr(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_real_ssyr_")));
+
+
+void flexiblas_chain_ssyr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+
+
+    hook_pos_ssyr++;
+    if ( hook_pos_ssyr < __flexiblas_hooks->ssyr.nhook ) {
+        fn = __flexiblas_hooks->ssyr.f77_hook_function[hook_pos_ssyr];
+    } else {
+        hook_pos_ssyr = 0;
+        fn = current_backend->blas.ssyr.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_ssyr(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_chain_ssyr_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssyr2 = 0;
+
 void FC_GLOBAL(ssyr2,SSYR2)(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -2905,6 +6371,40 @@
 
 
 
+void flexiblas_real_ssyr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.ssyr2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_ssyr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_ssyr2_")));
+
+
+void flexiblas_chain_ssyr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_ssyr2++;
+    if ( hook_pos_ssyr2 < __flexiblas_hooks->ssyr2.nhook ) {
+        fn = __flexiblas_hooks->ssyr2.f77_hook_function[hook_pos_ssyr2];
+    } else {
+        hook_pos_ssyr2 = 0;
+        fn = current_backend->blas.ssyr2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_ssyr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_ssyr2_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssyr2k = 0;
+
 void FC_GLOBAL(ssyr2k,SSYR2K)(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -2931,6 +6431,40 @@
 
 
 
+void flexiblas_real_ssyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.ssyr2k.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_ssyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_ssyr2k_")));
+
+
+void flexiblas_chain_ssyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_ssyr2k++;
+    if ( hook_pos_ssyr2k < __flexiblas_hooks->ssyr2k.nhook ) {
+        fn = __flexiblas_hooks->ssyr2k.f77_hook_function[hook_pos_ssyr2k];
+    } else {
+        hook_pos_ssyr2k = 0;
+        fn = current_backend->blas.ssyr2k.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_ssyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_ssyr2k_")));
+
+
+static TLS_STORE uint8_t hook_pos_ssyrk = 0;
+
 void FC_GLOBAL(ssyrk,SSYRK)(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* beta, float* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
@@ -2957,6 +6491,40 @@
 
 
 
+void flexiblas_real_ssyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.ssyrk.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_ssyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_ssyrk_")));
+
+
+void flexiblas_chain_ssyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_ssyrk++;
+    if ( hook_pos_ssyrk < __flexiblas_hooks->ssyrk.nhook ) {
+        fn = __flexiblas_hooks->ssyrk.f77_hook_function[hook_pos_ssyrk];
+    } else {
+        hook_pos_ssyrk = 0;
+        fn = current_backend->blas.ssyrk.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_ssyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_ssyrk_")));
+
+
+static TLS_STORE uint8_t hook_pos_stbmv = 0;
+
 void FC_GLOBAL(stbmv,STBMV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float* a, blasint* lda, float* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -2983,6 +6551,40 @@
 
 
 
+void flexiblas_real_stbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.stbmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_stbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_stbmv_")));
+
+
+void flexiblas_chain_stbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_stbmv++;
+    if ( hook_pos_stbmv < __flexiblas_hooks->stbmv.nhook ) {
+        fn = __flexiblas_hooks->stbmv.f77_hook_function[hook_pos_stbmv];
+    } else {
+        hook_pos_stbmv = 0;
+        fn = current_backend->blas.stbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_stbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_stbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_stbsv = 0;
+
 void FC_GLOBAL(stbsv,STBSV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float* a, blasint* lda, float* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -3009,6 +6611,40 @@
 
 
 
+void flexiblas_real_stbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.stbsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_stbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_stbsv_")));
+
+
+void flexiblas_chain_stbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_stbsv++;
+    if ( hook_pos_stbsv < __flexiblas_hooks->stbsv.nhook ) {
+        fn = __flexiblas_hooks->stbsv.f77_hook_function[hook_pos_stbsv];
+    } else {
+        hook_pos_stbsv = 0;
+        fn = current_backend->blas.stbsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_stbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_stbsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_stpmv = 0;
+
 void FC_GLOBAL(stpmv,STPMV)(char* uplo, char* trans, char* diag, blasint* n, float* ap, float* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -3035,6 +6671,40 @@
 
 
 
+void flexiblas_real_stpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.stpmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_stpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_stpmv_")));
+
+
+void flexiblas_chain_stpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_stpmv++;
+    if ( hook_pos_stpmv < __flexiblas_hooks->stpmv.nhook ) {
+        fn = __flexiblas_hooks->stpmv.f77_hook_function[hook_pos_stpmv];
+    } else {
+        hook_pos_stpmv = 0;
+        fn = current_backend->blas.stpmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_stpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_stpmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_stpsv = 0;
+
 void FC_GLOBAL(stpsv,STPSV)(char* uplo, char* trans, char* diag, blasint* n, float* ap, float* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -3061,6 +6731,40 @@
 
 
 
+void flexiblas_real_stpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.stpsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_stpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_stpsv_")));
+
+
+void flexiblas_chain_stpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_stpsv++;
+    if ( hook_pos_stpsv < __flexiblas_hooks->stpsv.nhook ) {
+        fn = __flexiblas_hooks->stpsv.f77_hook_function[hook_pos_stpsv];
+    } else {
+        hook_pos_stpsv = 0;
+        fn = current_backend->blas.stpsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_stpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_stpsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_strmm = 0;
+
 void FC_GLOBAL(strmm,STRMM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -3087,6 +6791,40 @@
 
 
 
+void flexiblas_real_strmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.strmm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_strmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_strmm_")));
+
+
+void flexiblas_chain_strmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_strmm++;
+    if ( hook_pos_strmm < __flexiblas_hooks->strmm.nhook ) {
+        fn = __flexiblas_hooks->strmm.f77_hook_function[hook_pos_strmm];
+    } else {
+        hook_pos_strmm = 0;
+        fn = current_backend->blas.strmm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_strmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_strmm_")));
+
+
+static TLS_STORE uint8_t hook_pos_strmv = 0;
+
 void FC_GLOBAL(strmv,STRMV)(char* uplo, char* trans, char* diag, blasint* n, float* a, blasint* lda, float* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -3113,6 +6851,40 @@
 
 
 
+void flexiblas_real_strmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.strmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_strmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_strmv_")));
+
+
+void flexiblas_chain_strmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_strmv++;
+    if ( hook_pos_strmv < __flexiblas_hooks->strmv.nhook ) {
+        fn = __flexiblas_hooks->strmv.f77_hook_function[hook_pos_strmv];
+    } else {
+        hook_pos_strmv = 0;
+        fn = current_backend->blas.strmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_strmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_strmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_strsm = 0;
+
 void FC_GLOBAL(strsm,STRSM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -3139,6 +6911,40 @@
 
 
 
+void flexiblas_real_strsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.strsm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_strsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_strsm_")));
+
+
+void flexiblas_chain_strsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_strsm++;
+    if ( hook_pos_strsm < __flexiblas_hooks->strsm.nhook ) {
+        fn = __flexiblas_hooks->strsm.f77_hook_function[hook_pos_strsm];
+    } else {
+        hook_pos_strsm = 0;
+        fn = current_backend->blas.strsm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_strsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_strsm_")));
+
+
+static TLS_STORE uint8_t hook_pos_strsv = 0;
+
 void FC_GLOBAL(strsv,STRSV)(char* uplo, char* trans, char* diag, blasint* n, float* a, blasint* lda, float* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -3165,6 +6971,40 @@
 
 
 
+void flexiblas_real_strsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.strsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_strsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_strsv_")));
+
+
+void flexiblas_chain_strsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_strsv++;
+    if ( hook_pos_strsv < __flexiblas_hooks->strsv.nhook ) {
+        fn = __flexiblas_hooks->strsv.f77_hook_function[hook_pos_strsv];
+    } else {
+        hook_pos_strsv = 0;
+        fn = current_backend->blas.strsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_strsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_strsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_zaxpy = 0;
+
 void FC_GLOBAL(zaxpy,ZAXPY)(blasint* n, double complex* za, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
 {
 	void (*fn) (void* n, void* za, void* zx, void* incx, void* zy, void* incy);
@@ -3191,6 +7031,40 @@
 
 
 
+void flexiblas_real_zaxpy_(void* n, void* za, void* zx, void* incx, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* za, void* zx, void* incx, void* zy, void* incy);
+
+	fn = current_backend->blas.zaxpy.f77_blas_function;
+	fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zaxpy(void* n, void* za, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_real_zaxpy_")));
+
+
+void flexiblas_chain_zaxpy_(void* n, void* za, void* zx, void* incx, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* za, void* zx, void* incx, void* zy, void* incy);
+
+
+
+    hook_pos_zaxpy++;
+    if ( hook_pos_zaxpy < __flexiblas_hooks->zaxpy.nhook ) {
+        fn = __flexiblas_hooks->zaxpy.f77_hook_function[hook_pos_zaxpy];
+    } else {
+        hook_pos_zaxpy = 0;
+        fn = current_backend->blas.zaxpy.f77_blas_function;
+    }
+	fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zaxpy(void* n, void* za, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_chain_zaxpy_")));
+
+
+static TLS_STORE uint8_t hook_pos_zcopy = 0;
+
 void FC_GLOBAL(zcopy,ZCOPY)(blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
 {
 	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
@@ -3217,6 +7091,40 @@
 
 
 
+void flexiblas_real_zcopy_(void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+
+	fn = current_backend->blas.zcopy.f77_blas_function;
+	fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zcopy(void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_real_zcopy_")));
+
+
+void flexiblas_chain_zcopy_(void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+
+
+
+    hook_pos_zcopy++;
+    if ( hook_pos_zcopy < __flexiblas_hooks->zcopy.nhook ) {
+        fn = __flexiblas_hooks->zcopy.f77_hook_function[hook_pos_zcopy];
+    } else {
+        hook_pos_zcopy = 0;
+        fn = current_backend->blas.zcopy.f77_blas_function;
+    }
+	fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zcopy(void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_chain_zcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_zdotc = 0;
+
 void FC_GLOBAL(zdotc,ZDOTC)( double complex* returnvalue, blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
 {
 	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
@@ -3257,6 +7165,56 @@
 
 
 
+void flexiblas_real_zdotc_( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
+	double complex ret;
+
+	fn = current_backend->blas.zdotc.f77_blas_function;	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		}
+
+	*((double complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_real_zdotc( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_real_zdotc_")));
+
+
+void flexiblas_chain_zdotc_( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
+	double complex ret;
+
+
+
+    hook_pos_zdotc++;
+    if ( hook_pos_zdotc < __flexiblas_hooks->zdotc.nhook ) {
+        fn = __flexiblas_hooks->zdotc.f77_hook_function[hook_pos_zdotc];
+    } else {
+        hook_pos_zdotc = 0;
+        fn = current_backend->blas.zdotc.f77_blas_function;
+    }	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		}
+
+	*((double complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_chain_zdotc( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_chain_zdotc_")));
+
+
+static TLS_STORE uint8_t hook_pos_zdotu = 0;
+
 void FC_GLOBAL(zdotu,ZDOTU)( double complex* returnvalue, blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
 {
 	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
@@ -3297,6 +7255,56 @@
 
 
 
+void flexiblas_real_zdotu_( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
+	double complex ret;
+
+	fn = current_backend->blas.zdotu.f77_blas_function;	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		}
+
+	*((double complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_real_zdotu( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_real_zdotu_")));
+
+
+void flexiblas_chain_zdotu_( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
+	double complex ret;
+
+
+
+    hook_pos_zdotu++;
+    if ( hook_pos_zdotu < __flexiblas_hooks->zdotu.nhook ) {
+        fn = __flexiblas_hooks->zdotu.f77_hook_function[hook_pos_zdotu];
+    } else {
+        hook_pos_zdotu = 0;
+        fn = current_backend->blas.zdotu.f77_blas_function;
+    }	fn_intel = (void *) fn;
+
+		if(current_backend->info.intel_interface == 0 ) {
+			ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		} else {
+			fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+		}
+
+	*((double complex *)returnvalue) = ret;
+	return;
+}
+void flexiblas_chain_zdotu( void * returnvalue, void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_chain_zdotu_")));
+
+
+static TLS_STORE uint8_t hook_pos_zdrot = 0;
+
 void FC_GLOBAL(zdrot,ZDROT)(blasint* n, double complex* cx, blasint* incx, double complex* cy, blasint* incy, double* c, double* s)
 {
 	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
@@ -3323,6 +7331,40 @@
 
 
 
+void flexiblas_real_zdrot_(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
+
+	fn = current_backend->blas.zdrot.f77_blas_function;
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_zdrot(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_real_zdrot_")));
+
+
+void flexiblas_chain_zdrot_(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s)
+{
+	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
+
+
+
+    hook_pos_zdrot++;
+    if ( hook_pos_zdrot < __flexiblas_hooks->zdrot.nhook ) {
+        fn = __flexiblas_hooks->zdrot.f77_hook_function[hook_pos_zdrot];
+    } else {
+        hook_pos_zdrot = 0;
+        fn = current_backend->blas.zdrot.f77_blas_function;
+    }
+	fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_zdrot(void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s) __attribute__((alias("flexiblas_chain_zdrot_")));
+
+
+static TLS_STORE uint8_t hook_pos_zdscal = 0;
+
 void FC_GLOBAL(zdscal,ZDSCAL)(blasint* n, double* da, double complex* zx, blasint* incx)
 {
 	void (*fn) (void* n, void* da, void* zx, void* incx);
@@ -3349,6 +7391,40 @@
 
 
 
+void flexiblas_real_zdscal_(void* n, void* da, void* zx, void* incx)
+{
+	void (*fn) (void* n, void* da, void* zx, void* incx);
+
+	fn = current_backend->blas.zdscal.f77_blas_function;
+	fn((void*) n, (void*) da, (void*) zx, (void*) incx);
+
+	return;
+}
+void flexiblas_real_zdscal(void* n, void* da, void* zx, void* incx) __attribute__((alias("flexiblas_real_zdscal_")));
+
+
+void flexiblas_chain_zdscal_(void* n, void* da, void* zx, void* incx)
+{
+	void (*fn) (void* n, void* da, void* zx, void* incx);
+
+
+
+    hook_pos_zdscal++;
+    if ( hook_pos_zdscal < __flexiblas_hooks->zdscal.nhook ) {
+        fn = __flexiblas_hooks->zdscal.f77_hook_function[hook_pos_zdscal];
+    } else {
+        hook_pos_zdscal = 0;
+        fn = current_backend->blas.zdscal.f77_blas_function;
+    }
+	fn((void*) n, (void*) da, (void*) zx, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_zdscal(void* n, void* da, void* zx, void* incx) __attribute__((alias("flexiblas_chain_zdscal_")));
+
+
+static TLS_STORE uint8_t hook_pos_zgbmv = 0;
+
 void FC_GLOBAL(zgbmv,ZGBMV)(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -3375,6 +7451,40 @@
 
 
 
+void flexiblas_real_zgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.zgbmv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_zgbmv_")));
+
+
+void flexiblas_chain_zgbmv_(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_zgbmv++;
+    if ( hook_pos_zgbmv < __flexiblas_hooks->zgbmv.nhook ) {
+        fn = __flexiblas_hooks->zgbmv.f77_hook_function[hook_pos_zgbmv];
+    } else {
+        hook_pos_zgbmv = 0;
+        fn = current_backend->blas.zgbmv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zgbmv(void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_zgbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_zgemm = 0;
+
 void FC_GLOBAL(zgemm,ZGEMM)(char* transa, char* transb, blasint* m, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -3401,6 +7511,40 @@
 
 
 
+void flexiblas_real_zgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zgemm.f77_blas_function;
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zgemm_")));
+
+
+void flexiblas_chain_zgemm_(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zgemm++;
+    if ( hook_pos_zgemm < __flexiblas_hooks->zgemm.nhook ) {
+        fn = __flexiblas_hooks->zgemm.f77_hook_function[hook_pos_zgemm];
+    } else {
+        hook_pos_zgemm = 0;
+        fn = current_backend->blas.zgemm.f77_blas_function;
+    }
+	fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zgemm(void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zgemm_")));
+
+
+static TLS_STORE uint8_t hook_pos_zgemv = 0;
+
 void FC_GLOBAL(zgemv,ZGEMV)(char* trans, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
 {
 	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -3427,6 +7571,40 @@
 
 
 
+void flexiblas_real_zgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.zgemv.f77_blas_function;
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_zgemv_")));
+
+
+void flexiblas_chain_zgemv_(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_zgemv++;
+    if ( hook_pos_zgemv < __flexiblas_hooks->zgemv.nhook ) {
+        fn = __flexiblas_hooks->zgemv.f77_hook_function[hook_pos_zgemv];
+    } else {
+        hook_pos_zgemv = 0;
+        fn = current_backend->blas.zgemv.f77_blas_function;
+    }
+	fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zgemv(void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_zgemv_")));
+
+
+static TLS_STORE uint8_t hook_pos_zgerc = 0;
+
 void FC_GLOBAL(zgerc,ZGERC)(blasint* m, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -3453,6 +7631,40 @@
 
 
 
+void flexiblas_real_zgerc_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.zgerc.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_zgerc(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_zgerc_")));
+
+
+void flexiblas_chain_zgerc_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_zgerc++;
+    if ( hook_pos_zgerc < __flexiblas_hooks->zgerc.nhook ) {
+        fn = __flexiblas_hooks->zgerc.f77_hook_function[hook_pos_zgerc];
+    } else {
+        hook_pos_zgerc = 0;
+        fn = current_backend->blas.zgerc.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_zgerc(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_zgerc_")));
+
+
+static TLS_STORE uint8_t hook_pos_zgeru = 0;
+
 void FC_GLOBAL(zgeru,ZGERU)(blasint* m, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -3479,6 +7691,40 @@
 
 
 
+void flexiblas_real_zgeru_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.zgeru.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_zgeru(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_zgeru_")));
+
+
+void flexiblas_chain_zgeru_(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_zgeru++;
+    if ( hook_pos_zgeru < __flexiblas_hooks->zgeru.nhook ) {
+        fn = __flexiblas_hooks->zgeru.f77_hook_function[hook_pos_zgeru];
+    } else {
+        hook_pos_zgeru = 0;
+        fn = current_backend->blas.zgeru.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_zgeru(void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_zgeru_")));
+
+
+static TLS_STORE uint8_t hook_pos_zhbmv = 0;
+
 void FC_GLOBAL(zhbmv,ZHBMV)(char* uplo, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -3505,6 +7751,40 @@
 
 
 
+void flexiblas_real_zhbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.zhbmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zhbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_zhbmv_")));
+
+
+void flexiblas_chain_zhbmv_(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_zhbmv++;
+    if ( hook_pos_zhbmv < __flexiblas_hooks->zhbmv.nhook ) {
+        fn = __flexiblas_hooks->zhbmv.f77_hook_function[hook_pos_zhbmv];
+    } else {
+        hook_pos_zhbmv = 0;
+        fn = current_backend->blas.zhbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zhbmv(void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_zhbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_zhemm = 0;
+
 void FC_GLOBAL(zhemm,ZHEMM)(char* side, char* uplo, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -3531,6 +7811,40 @@
 
 
 
+void flexiblas_real_zhemm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zhemm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zhemm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zhemm_")));
+
+
+void flexiblas_chain_zhemm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zhemm++;
+    if ( hook_pos_zhemm < __flexiblas_hooks->zhemm.nhook ) {
+        fn = __flexiblas_hooks->zhemm.f77_hook_function[hook_pos_zhemm];
+    } else {
+        hook_pos_zhemm = 0;
+        fn = current_backend->blas.zhemm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zhemm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zhemm_")));
+
+
+static TLS_STORE uint8_t hook_pos_zhemv = 0;
+
 void FC_GLOBAL(zhemv,ZHEMV)(char* uplo, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
@@ -3557,6 +7871,40 @@
 
 
 
+void flexiblas_real_zhemv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.zhemv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zhemv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_zhemv_")));
+
+
+void flexiblas_chain_zhemv_(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_zhemv++;
+    if ( hook_pos_zhemv < __flexiblas_hooks->zhemv.nhook ) {
+        fn = __flexiblas_hooks->zhemv.f77_hook_function[hook_pos_zhemv];
+    } else {
+        hook_pos_zhemv = 0;
+        fn = current_backend->blas.zhemv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zhemv(void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_zhemv_")));
+
+
+static TLS_STORE uint8_t hook_pos_zher = 0;
+
 void FC_GLOBAL(zher,ZHER)(char* uplo, blasint* n, double* alpha, double complex* x, blasint* incx, double complex* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
@@ -3583,6 +7931,40 @@
 
 
 
+void flexiblas_real_zher_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+	fn = current_backend->blas.zher.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_zher(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_real_zher_")));
+
+
+void flexiblas_chain_zher_(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
+
+
+
+    hook_pos_zher++;
+    if ( hook_pos_zher < __flexiblas_hooks->zher.nhook ) {
+        fn = __flexiblas_hooks->zher.f77_hook_function[hook_pos_zher];
+    } else {
+        hook_pos_zher = 0;
+        fn = current_backend->blas.zher.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_zher(void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda) __attribute__((alias("flexiblas_chain_zher_")));
+
+
+static TLS_STORE uint8_t hook_pos_zher2 = 0;
+
 void FC_GLOBAL(zher2,ZHER2)(char* uplo, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
@@ -3609,6 +7991,40 @@
 
 
 
+void flexiblas_real_zher2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+	fn = current_backend->blas.zher2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_real_zher2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_real_zher2_")));
+
+
+void flexiblas_chain_zher2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
+
+
+
+    hook_pos_zher2++;
+    if ( hook_pos_zher2 < __flexiblas_hooks->zher2.nhook ) {
+        fn = __flexiblas_hooks->zher2.f77_hook_function[hook_pos_zher2];
+    } else {
+        hook_pos_zher2 = 0;
+        fn = current_backend->blas.zher2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda);
+
+	return;
+}
+void flexiblas_chain_zher2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda) __attribute__((alias("flexiblas_chain_zher2_")));
+
+
+static TLS_STORE uint8_t hook_pos_zher2k = 0;
+
 void FC_GLOBAL(zher2k,ZHER2K)(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -3635,6 +8051,40 @@
 
 
 
+void flexiblas_real_zher2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zher2k.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zher2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zher2k_")));
+
+
+void flexiblas_chain_zher2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zher2k++;
+    if ( hook_pos_zher2k < __flexiblas_hooks->zher2k.nhook ) {
+        fn = __flexiblas_hooks->zher2k.f77_hook_function[hook_pos_zher2k];
+    } else {
+        hook_pos_zher2k = 0;
+        fn = current_backend->blas.zher2k.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zher2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zher2k_")));
+
+
+static TLS_STORE uint8_t hook_pos_zherk = 0;
+
 void FC_GLOBAL(zherk,ZHERK)(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double complex* a, blasint* lda, double* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
@@ -3661,6 +8111,40 @@
 
 
 
+void flexiblas_real_zherk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zherk.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zherk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zherk_")));
+
+
+void flexiblas_chain_zherk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zherk++;
+    if ( hook_pos_zherk < __flexiblas_hooks->zherk.nhook ) {
+        fn = __flexiblas_hooks->zherk.f77_hook_function[hook_pos_zherk];
+    } else {
+        hook_pos_zherk = 0;
+        fn = current_backend->blas.zherk.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zherk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zherk_")));
+
+
+static TLS_STORE uint8_t hook_pos_zhpmv = 0;
+
 void FC_GLOBAL(zhpmv,ZHPMV)(char* uplo, blasint* n, double complex* alpha, double complex* ap, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
@@ -3687,6 +8171,40 @@
 
 
 
+void flexiblas_real_zhpmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+	fn = current_backend->blas.zhpmv.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zhpmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_real_zhpmv_")));
+
+
+void flexiblas_chain_zhpmv_(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
+
+
+
+    hook_pos_zhpmv++;
+    if ( hook_pos_zhpmv < __flexiblas_hooks->zhpmv.nhook ) {
+        fn = __flexiblas_hooks->zhpmv.f77_hook_function[hook_pos_zhpmv];
+    } else {
+        hook_pos_zhpmv = 0;
+        fn = current_backend->blas.zhpmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zhpmv(void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy) __attribute__((alias("flexiblas_chain_zhpmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_zhpr = 0;
+
 void FC_GLOBAL(zhpr,ZHPR)(char* uplo, blasint* n, double* alpha, double complex* x, blasint* incx, double complex* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
@@ -3713,6 +8231,40 @@
 
 
 
+void flexiblas_real_zhpr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+	fn = current_backend->blas.zhpr.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_real_zhpr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_real_zhpr_")));
+
+
+void flexiblas_chain_zhpr_(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
+
+
+
+    hook_pos_zhpr++;
+    if ( hook_pos_zhpr < __flexiblas_hooks->zhpr.nhook ) {
+        fn = __flexiblas_hooks->zhpr.f77_hook_function[hook_pos_zhpr];
+    } else {
+        hook_pos_zhpr = 0;
+        fn = current_backend->blas.zhpr.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_zhpr(void* uplo, void* n, void* alpha, void* x, void* incx, void* ap) __attribute__((alias("flexiblas_chain_zhpr_")));
+
+
+static TLS_STORE uint8_t hook_pos_zhpr2 = 0;
+
 void FC_GLOBAL(zhpr2,ZHPR2)(char* uplo, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* ap)
 {
 	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
@@ -3739,6 +8291,40 @@
 
 
 
+void flexiblas_real_zhpr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+	fn = current_backend->blas.zhpr2.f77_blas_function;
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_real_zhpr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_real_zhpr2_")));
+
+
+void flexiblas_chain_zhpr2_(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap)
+{
+	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
+
+
+
+    hook_pos_zhpr2++;
+    if ( hook_pos_zhpr2 < __flexiblas_hooks->zhpr2.nhook ) {
+        fn = __flexiblas_hooks->zhpr2.f77_hook_function[hook_pos_zhpr2];
+    } else {
+        hook_pos_zhpr2 = 0;
+        fn = current_backend->blas.zhpr2.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap);
+
+	return;
+}
+void flexiblas_chain_zhpr2(void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap) __attribute__((alias("flexiblas_chain_zhpr2_")));
+
+
+static TLS_STORE uint8_t hook_pos_zrotg = 0;
+
 void FC_GLOBAL(zrotg,ZROTG)(double complex* ca, double complex* cb, double* c, double complex* s)
 {
 	void (*fn) (void* ca, void* cb, void* c, void* s);
@@ -3765,6 +8351,40 @@
 
 
 
+void flexiblas_real_zrotg_(void* ca, void* cb, void* c, void* s)
+{
+	void (*fn) (void* ca, void* cb, void* c, void* s);
+
+	fn = current_backend->blas.zrotg.f77_blas_function;
+	fn((void*) ca, (void*) cb, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_real_zrotg(void* ca, void* cb, void* c, void* s) __attribute__((alias("flexiblas_real_zrotg_")));
+
+
+void flexiblas_chain_zrotg_(void* ca, void* cb, void* c, void* s)
+{
+	void (*fn) (void* ca, void* cb, void* c, void* s);
+
+
+
+    hook_pos_zrotg++;
+    if ( hook_pos_zrotg < __flexiblas_hooks->zrotg.nhook ) {
+        fn = __flexiblas_hooks->zrotg.f77_hook_function[hook_pos_zrotg];
+    } else {
+        hook_pos_zrotg = 0;
+        fn = current_backend->blas.zrotg.f77_blas_function;
+    }
+	fn((void*) ca, (void*) cb, (void*) c, (void*) s);
+
+	return;
+}
+void flexiblas_chain_zrotg(void* ca, void* cb, void* c, void* s) __attribute__((alias("flexiblas_chain_zrotg_")));
+
+
+static TLS_STORE uint8_t hook_pos_zscal = 0;
+
 void FC_GLOBAL(zscal,ZSCAL)(blasint* n, double complex* za, double complex* zx, blasint* incx)
 {
 	void (*fn) (void* n, void* za, void* zx, void* incx);
@@ -3791,6 +8411,40 @@
 
 
 
+void flexiblas_real_zscal_(void* n, void* za, void* zx, void* incx)
+{
+	void (*fn) (void* n, void* za, void* zx, void* incx);
+
+	fn = current_backend->blas.zscal.f77_blas_function;
+	fn((void*) n, (void*) za, (void*) zx, (void*) incx);
+
+	return;
+}
+void flexiblas_real_zscal(void* n, void* za, void* zx, void* incx) __attribute__((alias("flexiblas_real_zscal_")));
+
+
+void flexiblas_chain_zscal_(void* n, void* za, void* zx, void* incx)
+{
+	void (*fn) (void* n, void* za, void* zx, void* incx);
+
+
+
+    hook_pos_zscal++;
+    if ( hook_pos_zscal < __flexiblas_hooks->zscal.nhook ) {
+        fn = __flexiblas_hooks->zscal.f77_hook_function[hook_pos_zscal];
+    } else {
+        hook_pos_zscal = 0;
+        fn = current_backend->blas.zscal.f77_blas_function;
+    }
+	fn((void*) n, (void*) za, (void*) zx, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_zscal(void* n, void* za, void* zx, void* incx) __attribute__((alias("flexiblas_chain_zscal_")));
+
+
+static TLS_STORE uint8_t hook_pos_zswap = 0;
+
 void FC_GLOBAL(zswap,ZSWAP)(blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
 {
 	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
@@ -3817,6 +8471,40 @@
 
 
 
+void flexiblas_real_zswap_(void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+
+	fn = current_backend->blas.zswap.f77_blas_function;
+	fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zswap(void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_real_zswap_")));
+
+
+void flexiblas_chain_zswap_(void* n, void* zx, void* incx, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
+
+
+
+    hook_pos_zswap++;
+    if ( hook_pos_zswap < __flexiblas_hooks->zswap.nhook ) {
+        fn = __flexiblas_hooks->zswap.f77_hook_function[hook_pos_zswap];
+    } else {
+        hook_pos_zswap = 0;
+        fn = current_backend->blas.zswap.f77_blas_function;
+    }
+	fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zswap(void* n, void* zx, void* incx, void* zy, void* incy) __attribute__((alias("flexiblas_chain_zswap_")));
+
+
+static TLS_STORE uint8_t hook_pos_zsymm = 0;
+
 void FC_GLOBAL(zsymm,ZSYMM)(char* side, char* uplo, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -3843,6 +8531,40 @@
 
 
 
+void flexiblas_real_zsymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zsymm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zsymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zsymm_")));
+
+
+void flexiblas_chain_zsymm_(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zsymm++;
+    if ( hook_pos_zsymm < __flexiblas_hooks->zsymm.nhook ) {
+        fn = __flexiblas_hooks->zsymm.f77_hook_function[hook_pos_zsymm];
+    } else {
+        hook_pos_zsymm = 0;
+        fn = current_backend->blas.zsymm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zsymm(void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zsymm_")));
+
+
+static TLS_STORE uint8_t hook_pos_zsyr2k = 0;
+
 void FC_GLOBAL(zsyr2k,ZSYR2K)(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
@@ -3869,6 +8591,40 @@
 
 
 
+void flexiblas_real_zsyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zsyr2k.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zsyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zsyr2k_")));
+
+
+void flexiblas_chain_zsyr2k_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zsyr2k++;
+    if ( hook_pos_zsyr2k < __flexiblas_hooks->zsyr2k.nhook ) {
+        fn = __flexiblas_hooks->zsyr2k.f77_hook_function[hook_pos_zsyr2k];
+    } else {
+        hook_pos_zsyr2k = 0;
+        fn = current_backend->blas.zsyr2k.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zsyr2k(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zsyr2k_")));
+
+
+static TLS_STORE uint8_t hook_pos_zsyrk = 0;
+
 void FC_GLOBAL(zsyrk,ZSYRK)(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* beta, double complex* c, blasint* ldc)
 {
 	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
@@ -3895,6 +8651,40 @@
 
 
 
+void flexiblas_real_zsyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+	fn = current_backend->blas.zsyrk.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_real_zsyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_real_zsyrk_")));
+
+
+void flexiblas_chain_zsyrk_(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc)
+{
+	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
+
+
+
+    hook_pos_zsyrk++;
+    if ( hook_pos_zsyrk < __flexiblas_hooks->zsyrk.nhook ) {
+        fn = __flexiblas_hooks->zsyrk.f77_hook_function[hook_pos_zsyrk];
+    } else {
+        hook_pos_zsyrk = 0;
+        fn = current_backend->blas.zsyrk.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc);
+
+	return;
+}
+void flexiblas_chain_zsyrk(void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc) __attribute__((alias("flexiblas_chain_zsyrk_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztbmv = 0;
+
 void FC_GLOBAL(ztbmv,ZTBMV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double complex* a, blasint* lda, double complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -3921,6 +8711,40 @@
 
 
 
+void flexiblas_real_ztbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ztbmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ztbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ztbmv_")));
+
+
+void flexiblas_chain_ztbmv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ztbmv++;
+    if ( hook_pos_ztbmv < __flexiblas_hooks->ztbmv.nhook ) {
+        fn = __flexiblas_hooks->ztbmv.f77_hook_function[hook_pos_ztbmv];
+    } else {
+        hook_pos_ztbmv = 0;
+        fn = current_backend->blas.ztbmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ztbmv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ztbmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztbsv = 0;
+
 void FC_GLOBAL(ztbsv,ZTBSV)(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double complex* a, blasint* lda, double complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
@@ -3947,6 +8771,40 @@
 
 
 
+void flexiblas_real_ztbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ztbsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ztbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ztbsv_")));
+
+
+void flexiblas_chain_ztbsv_(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ztbsv++;
+    if ( hook_pos_ztbsv < __flexiblas_hooks->ztbsv.nhook ) {
+        fn = __flexiblas_hooks->ztbsv.f77_hook_function[hook_pos_ztbsv];
+    } else {
+        hook_pos_ztbsv = 0;
+        fn = current_backend->blas.ztbsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ztbsv(void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ztbsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztpmv = 0;
+
 void FC_GLOBAL(ztpmv,ZTPMV)(char* uplo, char* trans, char* diag, blasint* n, double complex* ap, double complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -3973,6 +8831,40 @@
 
 
 
+void flexiblas_real_ztpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.ztpmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ztpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_ztpmv_")));
+
+
+void flexiblas_chain_ztpmv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_ztpmv++;
+    if ( hook_pos_ztpmv < __flexiblas_hooks->ztpmv.nhook ) {
+        fn = __flexiblas_hooks->ztpmv.f77_hook_function[hook_pos_ztpmv];
+    } else {
+        hook_pos_ztpmv = 0;
+        fn = current_backend->blas.ztpmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ztpmv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_ztpmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztpsv = 0;
+
 void FC_GLOBAL(ztpsv,ZTPSV)(char* uplo, char* trans, char* diag, blasint* n, double complex* ap, double complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
@@ -3999,6 +8891,40 @@
 
 
 
+void flexiblas_real_ztpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+	fn = current_backend->blas.ztpsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ztpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_real_ztpsv_")));
+
+
+void flexiblas_chain_ztpsv_(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
+
+
+
+    hook_pos_ztpsv++;
+    if ( hook_pos_ztpsv < __flexiblas_hooks->ztpsv.nhook ) {
+        fn = __flexiblas_hooks->ztpsv.f77_hook_function[hook_pos_ztpsv];
+    } else {
+        hook_pos_ztpsv = 0;
+        fn = current_backend->blas.ztpsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ztpsv(void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx) __attribute__((alias("flexiblas_chain_ztpsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztrmm = 0;
+
 void FC_GLOBAL(ztrmm,ZTRMM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -4025,6 +8951,40 @@
 
 
 
+void flexiblas_real_ztrmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.ztrmm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_ztrmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_ztrmm_")));
+
+
+void flexiblas_chain_ztrmm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_ztrmm++;
+    if ( hook_pos_ztrmm < __flexiblas_hooks->ztrmm.nhook ) {
+        fn = __flexiblas_hooks->ztrmm.f77_hook_function[hook_pos_ztrmm];
+    } else {
+        hook_pos_ztrmm = 0;
+        fn = current_backend->blas.ztrmm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_ztrmm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_ztrmm_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztrmv = 0;
+
 void FC_GLOBAL(ztrmv,ZTRMV)(char* uplo, char* trans, char* diag, blasint* n, double complex* a, blasint* lda, double complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -4051,6 +9011,40 @@
 
 
 
+void flexiblas_real_ztrmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ztrmv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ztrmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ztrmv_")));
+
+
+void flexiblas_chain_ztrmv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ztrmv++;
+    if ( hook_pos_ztrmv < __flexiblas_hooks->ztrmv.nhook ) {
+        fn = __flexiblas_hooks->ztrmv.f77_hook_function[hook_pos_ztrmv];
+    } else {
+        hook_pos_ztrmv = 0;
+        fn = current_backend->blas.ztrmv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ztrmv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ztrmv_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztrsm = 0;
+
 void FC_GLOBAL(ztrsm,ZTRSM)(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb)
 {
 	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -4077,6 +9071,40 @@
 
 
 
+void flexiblas_real_ztrsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.ztrsm.f77_blas_function;
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_ztrsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_ztrsm_")));
+
+
+void flexiblas_chain_ztrsm_(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_ztrsm++;
+    if ( hook_pos_ztrsm < __flexiblas_hooks->ztrsm.nhook ) {
+        fn = __flexiblas_hooks->ztrsm.f77_hook_function[hook_pos_ztrsm];
+    } else {
+        hook_pos_ztrsm = 0;
+        fn = current_backend->blas.ztrsm.f77_blas_function;
+    }
+	fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_ztrsm(void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_ztrsm_")));
+
+
+static TLS_STORE uint8_t hook_pos_ztrsv = 0;
+
 void FC_GLOBAL(ztrsv,ZTRSV)(char* uplo, char* trans, char* diag, blasint* n, double complex* a, blasint* lda, double complex* x, blasint* incx)
 {
 	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
@@ -4103,6 +9131,40 @@
 
 
 
+void flexiblas_real_ztrsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+	fn = current_backend->blas.ztrsv.f77_blas_function;
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_real_ztrsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_real_ztrsv_")));
+
+
+void flexiblas_chain_ztrsv_(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx)
+{
+	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
+
+
+
+    hook_pos_ztrsv++;
+    if ( hook_pos_ztrsv < __flexiblas_hooks->ztrsv.nhook ) {
+        fn = __flexiblas_hooks->ztrsv.f77_hook_function[hook_pos_ztrsv];
+    } else {
+        hook_pos_ztrsv = 0;
+        fn = current_backend->blas.ztrsv.f77_blas_function;
+    }
+	fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx);
+
+	return;
+}
+void flexiblas_chain_ztrsv(void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx) __attribute__((alias("flexiblas_chain_ztrsv_")));
+
+
+static TLS_STORE uint8_t hook_pos_caxpby = 0;
+
 void FC_GLOBAL(caxpby,CAXPBY)(blasint* n, float complex* ca, float complex* cx, blasint* incx, float complex* cb, float complex* cy, blasint* incy)
 {
 	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy);
@@ -4129,6 +9191,40 @@
 
 
 
+void flexiblas_real_caxpby_(void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy);
+
+	fn = current_backend->blas.caxpby.f77_blas_function;
+	fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cb, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_caxpby(void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy) __attribute__((alias("flexiblas_real_caxpby_")));
+
+
+void flexiblas_chain_caxpby_(void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy)
+{
+	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy);
+
+
+
+    hook_pos_caxpby++;
+    if ( hook_pos_caxpby < __flexiblas_hooks->caxpby.nhook ) {
+        fn = __flexiblas_hooks->caxpby.f77_hook_function[hook_pos_caxpby];
+    } else {
+        hook_pos_caxpby = 0;
+        fn = current_backend->blas.caxpby.f77_blas_function;
+    }
+	fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cb, (void*) cy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_caxpby(void* n, void* ca, void* cx, void* incx, void* cb, void* cy, void* incy) __attribute__((alias("flexiblas_chain_caxpby_")));
+
+
+static TLS_STORE uint8_t hook_pos_daxpby = 0;
+
 void FC_GLOBAL(daxpby,DAXPBY)(blasint* n, double* da, double* dx, blasint* incx, double* db, double* dy, blasint* incy)
 {
 	void (*fn) (void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy);
@@ -4155,6 +9251,40 @@
 
 
 
+void flexiblas_real_daxpby_(void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy);
+
+	fn = current_backend->blas.daxpby.f77_blas_function;
+	fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) db, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_daxpby(void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy) __attribute__((alias("flexiblas_real_daxpby_")));
+
+
+void flexiblas_chain_daxpby_(void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy)
+{
+	void (*fn) (void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy);
+
+
+
+    hook_pos_daxpby++;
+    if ( hook_pos_daxpby < __flexiblas_hooks->daxpby.nhook ) {
+        fn = __flexiblas_hooks->daxpby.f77_hook_function[hook_pos_daxpby];
+    } else {
+        hook_pos_daxpby = 0;
+        fn = current_backend->blas.daxpby.f77_blas_function;
+    }
+	fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) db, (void*) dy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_daxpby(void* n, void* da, void* dx, void* incx, void* db, void* dy, void* incy) __attribute__((alias("flexiblas_chain_daxpby_")));
+
+
+static TLS_STORE uint8_t hook_pos_zaxpby = 0;
+
 void FC_GLOBAL(zaxpby,ZAXPBY)(blasint* n, double complex* za, double complex* zx, blasint* incx, double complex* zb, double complex* zy, blasint* incy)
 {
 	void (*fn) (void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy);
@@ -4181,6 +9311,40 @@
 
 
 
+void flexiblas_real_zaxpby_(void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy);
+
+	fn = current_backend->blas.zaxpby.f77_blas_function;
+	fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zb, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_zaxpby(void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy) __attribute__((alias("flexiblas_real_zaxpby_")));
+
+
+void flexiblas_chain_zaxpby_(void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy)
+{
+	void (*fn) (void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy);
+
+
+
+    hook_pos_zaxpby++;
+    if ( hook_pos_zaxpby < __flexiblas_hooks->zaxpby.nhook ) {
+        fn = __flexiblas_hooks->zaxpby.f77_hook_function[hook_pos_zaxpby];
+    } else {
+        hook_pos_zaxpby = 0;
+        fn = current_backend->blas.zaxpby.f77_blas_function;
+    }
+	fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zb, (void*) zy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_zaxpby(void* n, void* za, void* zx, void* incx, void* zb, void* zy, void* incy) __attribute__((alias("flexiblas_chain_zaxpby_")));
+
+
+static TLS_STORE uint8_t hook_pos_saxpby = 0;
+
 void FC_GLOBAL(saxpby,SAXPBY)(blasint* n, float* sa, float* sx, blasint* incx, float* sb, float* sy, blasint* incy)
 {
 	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy);
@@ -4207,6 +9371,40 @@
 
 
 
+void flexiblas_real_saxpby_(void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy);
+
+	fn = current_backend->blas.saxpby.f77_blas_function;
+	fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sb, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_real_saxpby(void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy) __attribute__((alias("flexiblas_real_saxpby_")));
+
+
+void flexiblas_chain_saxpby_(void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy)
+{
+	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy);
+
+
+
+    hook_pos_saxpby++;
+    if ( hook_pos_saxpby < __flexiblas_hooks->saxpby.nhook ) {
+        fn = __flexiblas_hooks->saxpby.f77_hook_function[hook_pos_saxpby];
+    } else {
+        hook_pos_saxpby = 0;
+        fn = current_backend->blas.saxpby.f77_blas_function;
+    }
+	fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sb, (void*) sy, (void*) incy);
+
+	return;
+}
+void flexiblas_chain_saxpby(void* n, void* sa, void* sx, void* incx, void* sb, void* sy, void* incy) __attribute__((alias("flexiblas_chain_saxpby_")));
+
+
+static TLS_STORE uint8_t hook_pos_comatcopy = 0;
+
 void FC_GLOBAL(comatcopy,COMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -4233,6 +9431,40 @@
 
 
 
+void flexiblas_real_comatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.comatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_comatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_comatcopy_")));
+
+
+void flexiblas_chain_comatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_comatcopy++;
+    if ( hook_pos_comatcopy < __flexiblas_hooks->comatcopy.nhook ) {
+        fn = __flexiblas_hooks->comatcopy.f77_hook_function[hook_pos_comatcopy];
+    } else {
+        hook_pos_comatcopy = 0;
+        fn = current_backend->blas.comatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_comatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_comatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_zomatcopy = 0;
+
 void FC_GLOBAL(zomatcopy,ZOMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -4259,6 +9491,40 @@
 
 
 
+void flexiblas_real_zomatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.zomatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_zomatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_zomatcopy_")));
+
+
+void flexiblas_chain_zomatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_zomatcopy++;
+    if ( hook_pos_zomatcopy < __flexiblas_hooks->zomatcopy.nhook ) {
+        fn = __flexiblas_hooks->zomatcopy.f77_hook_function[hook_pos_zomatcopy];
+    } else {
+        hook_pos_zomatcopy = 0;
+        fn = current_backend->blas.zomatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_zomatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_zomatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_domatcopy = 0;
+
 void FC_GLOBAL(domatcopy,DOMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, double* alpha, double* a, blasint* lda, double* b, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -4285,6 +9551,40 @@
 
 
 
+void flexiblas_real_domatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.domatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_domatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_domatcopy_")));
+
+
+void flexiblas_chain_domatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_domatcopy++;
+    if ( hook_pos_domatcopy < __flexiblas_hooks->domatcopy.nhook ) {
+        fn = __flexiblas_hooks->domatcopy.f77_hook_function[hook_pos_domatcopy];
+    } else {
+        hook_pos_domatcopy = 0;
+        fn = current_backend->blas.domatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_domatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_domatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_somatcopy = 0;
+
 void FC_GLOBAL(somatcopy,SOMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, float* alpha, float* a, blasint* lda, float* b, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
@@ -4311,6 +9611,40 @@
 
 
 
+void flexiblas_real_somatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+	fn = current_backend->blas.somatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_somatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_real_somatcopy_")));
+
+
+void flexiblas_chain_somatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb);
+
+
+
+    hook_pos_somatcopy++;
+    if ( hook_pos_somatcopy < __flexiblas_hooks->somatcopy.nhook ) {
+        fn = __flexiblas_hooks->somatcopy.f77_hook_function[hook_pos_somatcopy];
+    } else {
+        hook_pos_somatcopy = 0;
+        fn = current_backend->blas.somatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_somatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* b, void* ldb) __attribute__((alias("flexiblas_chain_somatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_cimatcopy = 0;
+
 void FC_GLOBAL(cimatcopy,CIMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, float complex* alpha, float complex* a, blasint* lda, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
@@ -4337,6 +9671,40 @@
 
 
 
+void flexiblas_real_cimatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+	fn = current_backend->blas.cimatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_cimatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_real_cimatcopy_")));
+
+
+void flexiblas_chain_cimatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+
+
+    hook_pos_cimatcopy++;
+    if ( hook_pos_cimatcopy < __flexiblas_hooks->cimatcopy.nhook ) {
+        fn = __flexiblas_hooks->cimatcopy.f77_hook_function[hook_pos_cimatcopy];
+    } else {
+        hook_pos_cimatcopy = 0;
+        fn = current_backend->blas.cimatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_cimatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_chain_cimatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_zimatcopy = 0;
+
 void FC_GLOBAL(zimatcopy,ZIMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, double complex* alpha, double complex* a, blasint* lda, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
@@ -4363,6 +9731,40 @@
 
 
 
+void flexiblas_real_zimatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+	fn = current_backend->blas.zimatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_zimatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_real_zimatcopy_")));
+
+
+void flexiblas_chain_zimatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+
+
+    hook_pos_zimatcopy++;
+    if ( hook_pos_zimatcopy < __flexiblas_hooks->zimatcopy.nhook ) {
+        fn = __flexiblas_hooks->zimatcopy.f77_hook_function[hook_pos_zimatcopy];
+    } else {
+        hook_pos_zimatcopy = 0;
+        fn = current_backend->blas.zimatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_zimatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_chain_zimatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_dimatcopy = 0;
+
 void FC_GLOBAL(dimatcopy,DIMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, double* alpha, double* a, blasint* lda, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
@@ -4389,6 +9791,40 @@
 
 
 
+void flexiblas_real_dimatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+	fn = current_backend->blas.dimatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_dimatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_real_dimatcopy_")));
+
+
+void flexiblas_chain_dimatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+
+
+    hook_pos_dimatcopy++;
+    if ( hook_pos_dimatcopy < __flexiblas_hooks->dimatcopy.nhook ) {
+        fn = __flexiblas_hooks->dimatcopy.f77_hook_function[hook_pos_dimatcopy];
+    } else {
+        hook_pos_dimatcopy = 0;
+        fn = current_backend->blas.dimatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_dimatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_chain_dimatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_simatcopy = 0;
+
 void FC_GLOBAL(simatcopy,SIMATCOPY)(char* order, char* trans, blasint* rows, blasint* cols, float* alpha, float* a, blasint* lda, blasint* ldb)
 {
 	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
@@ -4415,6 +9851,40 @@
 
 
 
+void flexiblas_real_simatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+	fn = current_backend->blas.simatcopy.f77_blas_function;
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_simatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_real_simatcopy_")));
+
+
+void flexiblas_chain_simatcopy_(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb)
+{
+	void (*fn) (void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb);
+
+
+
+    hook_pos_simatcopy++;
+    if ( hook_pos_simatcopy < __flexiblas_hooks->simatcopy.nhook ) {
+        fn = __flexiblas_hooks->simatcopy.f77_hook_function[hook_pos_simatcopy];
+    } else {
+        hook_pos_simatcopy = 0;
+        fn = current_backend->blas.simatcopy.f77_blas_function;
+    }
+	fn((void*) order, (void*) trans, (void*) rows, (void*) cols, (void*) alpha, (void*) a, (void*) lda, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_simatcopy(void* order, void* trans, void* rows, void* cols, void* alpha, void* a, void* lda, void* ldb) __attribute__((alias("flexiblas_chain_simatcopy_")));
+
+
+static TLS_STORE uint8_t hook_pos_sgeadd = 0;
+
 void FC_GLOBAL(sgeadd,SGEADD)(blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* beta, float* b, blasint* ldb)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
@@ -4441,6 +9911,40 @@
 
 
 
+void flexiblas_real_sgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+	fn = current_backend->blas.sgeadd.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_sgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_real_sgeadd_")));
+
+
+void flexiblas_chain_sgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+
+
+    hook_pos_sgeadd++;
+    if ( hook_pos_sgeadd < __flexiblas_hooks->sgeadd.nhook ) {
+        fn = __flexiblas_hooks->sgeadd.f77_hook_function[hook_pos_sgeadd];
+    } else {
+        hook_pos_sgeadd = 0;
+        fn = current_backend->blas.sgeadd.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_sgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_chain_sgeadd_")));
+
+
+static TLS_STORE uint8_t hook_pos_dgeadd = 0;
+
 void FC_GLOBAL(dgeadd,DGEADD)(blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* beta, double* b, blasint* ldb)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
@@ -4467,6 +9971,40 @@
 
 
 
+void flexiblas_real_dgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+	fn = current_backend->blas.dgeadd.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_dgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_real_dgeadd_")));
+
+
+void flexiblas_chain_dgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+
+
+    hook_pos_dgeadd++;
+    if ( hook_pos_dgeadd < __flexiblas_hooks->dgeadd.nhook ) {
+        fn = __flexiblas_hooks->dgeadd.f77_hook_function[hook_pos_dgeadd];
+    } else {
+        hook_pos_dgeadd = 0;
+        fn = current_backend->blas.dgeadd.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_dgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_chain_dgeadd_")));
+
+
+static TLS_STORE uint8_t hook_pos_cgeadd = 0;
+
 void FC_GLOBAL(cgeadd,CGEADD)(blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* beta, float complex* b, blasint* ldb)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
@@ -4493,6 +10031,40 @@
 
 
 
+void flexiblas_real_cgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+	fn = current_backend->blas.cgeadd.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_cgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_real_cgeadd_")));
+
+
+void flexiblas_chain_cgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+
+
+    hook_pos_cgeadd++;
+    if ( hook_pos_cgeadd < __flexiblas_hooks->cgeadd.nhook ) {
+        fn = __flexiblas_hooks->cgeadd.f77_hook_function[hook_pos_cgeadd];
+    } else {
+        hook_pos_cgeadd = 0;
+        fn = current_backend->blas.cgeadd.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_cgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_chain_cgeadd_")));
+
+
+static TLS_STORE uint8_t hook_pos_zgeadd = 0;
+
 void FC_GLOBAL(zgeadd,ZGEADD)(blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* beta, double complex* b, blasint* ldb)
 {
 	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
@@ -4519,4 +10091,36 @@
 
 
 
+void flexiblas_real_zgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+	fn = current_backend->blas.zgeadd.f77_blas_function;
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_real_zgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_real_zgeadd_")));
+
+
+void flexiblas_chain_zgeadd_(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb)
+{
+	void (*fn) (void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb);
+
+
+
+    hook_pos_zgeadd++;
+    if ( hook_pos_zgeadd < __flexiblas_hooks->zgeadd.nhook ) {
+        fn = __flexiblas_hooks->zgeadd.f77_hook_function[hook_pos_zgeadd];
+    } else {
+        hook_pos_zgeadd = 0;
+        fn = current_backend->blas.zgeadd.f77_blas_function;
+    }
+	fn((void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) b, (void*) ldb);
+
+	return;
+}
+void flexiblas_chain_zgeadd(void* m, void* n, void* alpha, void* a, void* lda, void* beta, void* b, void* ldb) __attribute__((alias("flexiblas_chain_zgeadd_")));
+
+
 
