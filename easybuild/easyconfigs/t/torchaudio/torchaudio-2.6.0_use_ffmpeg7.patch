Update torchaudio to work with FFmpeg v7
Author: Samuel Moors (Vrije Universiteit Brussel)
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/filter_graph.cpp audio-2.6.0/src/libtorio/ffmpeg/filter_graph.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/filter_graph.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/filter_graph.cpp	2025-12-02 22:46:46.367838000 +0100
@@ -22,17 +22,26 @@
     AVSampleFormat format,
     AVRational time_base,
     int sample_rate,
-    uint64_t channel_layout) {
+    AVChannelLayout channel_layout) {
   char args[512];
+  char ch_layout_str[128];
+
+  int ret = av_channel_layout_describe(
+      &channel_layout, ch_layout_str, sizeof(ch_layout_str));
+  TORCH_CHECK(
+      ret >= 0,
+      "Failed to describe channel layout: ",
+      av_err2string(ret));
+
   std::snprintf(
       args,
       sizeof(args),
-      "time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=0x%" PRIx64,
+      "time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=%s",
       time_base.num,
       time_base.den,
       sample_rate,
       av_get_sample_fmt_name(format),
-      channel_layout);
+      ch_layout_str);
   return std::string(args);
 }
 
@@ -66,7 +75,7 @@
     AVSampleFormat format,
     AVRational time_base,
     int sample_rate,
-    uint64_t channel_layout) {
+    AVChannelLayout channel_layout) {
   add_src(
       avfilter_get_by_name("abuffer"),
       get_audio_src_args(format, time_base, sample_rate, channel_layout));
@@ -186,7 +195,7 @@
   switch (l->type) {
     case AVMEDIA_TYPE_AUDIO: {
       ret.sample_rate = l->sample_rate;
-#if LIBAVFILTER_VERSION_MAJOR >= 8 && LIBAVFILTER_VERSION_MINOR >= 44
+#if LIBAVFILTER_VERSION_MAJOR > 8 || (LIBAVFILTER_VERSION_MAJOR == 8 && LIBAVFILTER_VERSION_MINOR >= 44)
       ret.num_channels = l->ch_layout.nb_channels;
 #else
       // Before FFmpeg 5.1
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/filter_graph.h audio-2.6.0/src/libtorio/ffmpeg/filter_graph.h
--- audio-2.6.0.orig/src/libtorio/ffmpeg/filter_graph.h	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/filter_graph.h	2025-12-01 19:52:07.342909995 +0100
@@ -47,7 +47,7 @@
       AVSampleFormat format,
       AVRational time_base,
       int sample_rate,
-      uint64_t channel_layout);
+      AVChannelLayout channel_layout);
 
   void add_video_src(
       AVPixelFormat format,
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/pybind/pybind.cpp audio-2.6.0/src/libtorio/ffmpeg/pybind/pybind.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/pybind/pybind.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/pybind/pybind.cpp	2025-12-01 20:51:43.182687490 +0100
@@ -135,7 +135,7 @@
   return num_read == 0 ? AVERROR_EOF : num_read;
 }
 
-static int write_func(void* opaque, uint8_t* buf, int buf_size) {
+static int write_func(void* opaque, const uint8_t* buf, int buf_size) {
   FileObj* fileobj = static_cast<FileObj*>(opaque);
   buf_size = FFMIN(buf_size, fileobj->buffer_size);
 
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/conversion.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_reader/conversion.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/conversion.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_reader/conversion.cpp	2025-12-01 12:07:48.943112806 +0100
@@ -36,7 +36,7 @@
     const AVFrame* src,
     torch::Tensor& dst) {
   TORCH_INTERNAL_ASSERT_DEBUG_ONLY(src);
-  TORCH_INTERNAL_ASSERT_DEBUG_ONLY(num_channels == src->channels);
+  TORCH_INTERNAL_ASSERT_DEBUG_ONLY(num_channels == src->ch_layout.nb_channels);
 
   constexpr int bps = []() {
     switch (dtype) {
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/post_process.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_reader/post_process.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/post_process.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_reader/post_process.cpp	2025-12-01 20:02:13.873117462 +0100
@@ -19,7 +19,7 @@
   return [fmt = codec_ctx->sample_fmt,
           time_base,
           rate = codec_ctx->sample_rate,
-          channel_layout = codec_ctx->channel_layout](
+          channel_layout = codec_ctx->ch_layout](
              const std::string& filter_desc) -> FilterGraph {
     FilterGraph f;
     f.add_audio_src(fmt, time_base, rate, channel_layout);
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/stream_processor.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_reader/stream_processor.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/stream_processor.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_reader/stream_processor.cpp	2025-12-02 20:23:50.185425554 +0100
@@ -2,6 +2,7 @@
 #include <libtorio/ffmpeg/stream_reader/stream_processor.h>
 #include <stdexcept>
 #include <string_view>
+#include <libavutil/channel_layout.h>
 
 namespace torio::io {
 
@@ -140,10 +141,9 @@
     av_dict_set(&opts, "threads", "1", 0);
   }
 
-  if (!codec_ctx->channel_layout) {
-    codec_ctx->channel_layout =
-        av_get_default_channel_layout(codec_ctx->channels);
-  }
+  // if (codec_ctx->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC) {
+  //   av_channel_layout_default(&codec_ctx->ch_layout, codec_ctx->channels);
+  // }
 
   int ret = avcodec_open2(codec_ctx, codec_ctx->codec, &opts);
   clean_up_dict(opts);
@@ -337,7 +337,7 @@
         // This is because they might be intra-frames not in chronological
         // order. In this case, we use received frames as-is in the order they
         // are received.
-        frame->pts = codec_ctx->frame_number + 1;
+        frame->pts = codec_ctx->frame_num + 1;
       } else {
         frame->pts = frame->best_effort_timestamp;
       }
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/stream_reader.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_reader/stream_reader.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_reader/stream_reader.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_reader/stream_reader.cpp	2025-12-01 14:34:29.047656123 +0100
@@ -162,7 +162,7 @@
         ret.fmt_name = av_get_sample_fmt_name(smp_fmt);
       }
       ret.sample_rate = static_cast<double>(codecpar->sample_rate);
-      ret.num_channels = codecpar->channels;
+      ret.num_channels = codecpar->ch_layout.nb_channels;
       break;
     }
     case AVMEDIA_TYPE_VIDEO: {
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/encode_process.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_writer/encode_process.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/encode_process.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_writer/encode_process.cpp	2025-12-03 15:21:12.403231996 +0100
@@ -1,6 +1,8 @@
 #include <libtorio/ffmpeg/hw_context.h>
 #include <libtorio/ffmpeg/stream_writer/encode_process.h>
 #include <cmath>
+#include <libavutil/channel_layout.h>
+#include <libavcodec/avcodec.h>
 
 namespace torio::io {
 
@@ -311,20 +313,30 @@
   return src_sample_rate;
 }
 
-std::string get_supported_channels(const uint64_t* channel_layouts) {
+// Helper to handle the "Describe" API which now requires a buffer
+std::string describe_layout(const AVChannelLayout& layout) {
+    char buf[256];
+    av_channel_layout_describe(&layout, buf, sizeof(buf));
+    return std::string(buf);
+}
+
+std::string get_supported_channels(const AVChannelLayout* channel_layouts) {
   std::vector<std::string> names;
-  while (*channel_layouts) {
+  // FFmpeg 7 ch_layouts array is terminated by a layout with 0 channels
+  while (channel_layouts->nb_channels) {
     std::stringstream ss;
-    ss << av_get_channel_layout_nb_channels(*channel_layouts);
-    ss << " (" << av_get_channel_name(*channel_layouts) << ")";
+    ss << channel_layouts->nb_channels;
+    ss << " (" << describe_layout(*channel_layouts) << ")";
     names.emplace_back(ss.str());
     ++channel_layouts;
   }
   return c10::Join(", ", names);
 }
 
-uint64_t get_channel_layout(
-    const uint64_t src_ch_layout,
+// Return type changed from uint64_t to AVChannelLayout
+// Input src_ch_layout changed from uint64_t to const AVChannelLayout&
+AVChannelLayout get_channel_layout(
+    const AVChannelLayout& src_ch_layout,
     const std::optional<int> enc_num_channels,
     const AVCodec* codec) {
   // If the override is presented, and if it is supported by codec, we use it.
@@ -332,14 +344,20 @@
     const int& val = enc_num_channels.value();
     TORCH_CHECK(
         val > 0, "The number of channels must be greater than 0. Found: ", val);
-    if (!codec->channel_layouts) {
-      return static_cast<uint64_t>(av_get_default_channel_layout(val));
+
+    // Check if codec has specific supported layouts (ch_layouts replaces channel_layouts)
+    if (!codec->ch_layouts) {
+      AVChannelLayout default_layout;
+      av_channel_layout_default(&default_layout, val);
+      return default_layout;
     }
-    for (const uint64_t* it = codec->channel_layouts; *it; ++it) {
-      if (av_get_channel_layout_nb_channels(*it) == val) {
+
+    for (const AVChannelLayout* it = codec->ch_layouts; it->nb_channels; ++it) {
+      if (it->nb_channels == val) {
         return *it;
       }
     }
+
     TORCH_CHECK(
         false,
         "Codec ",
@@ -347,35 +365,42 @@
         " does not support a channel layout consists of ",
         val,
         " channels. Supported values are: ",
-        get_supported_channels(codec->channel_layouts));
+        get_supported_channels(codec->ch_layouts));
   }
+
   // If the codec does not have restriction on channel layout, we reuse the
   // source channel layout
-  if (!codec->channel_layouts) {
+  if (!codec->ch_layouts) {
     return src_ch_layout;
   }
+
   // If the codec has restriction, and source layout is supported, we reuse the
   // source channel layout
-  for (const uint64_t* it = codec->channel_layouts; *it; ++it) {
-    if (*it == src_ch_layout) {
+  for (const AVChannelLayout* it = codec->ch_layouts; it->nb_channels; ++it) {
+    // av_channel_layout_compare returns 0 if they are equal
+    if (av_channel_layout_compare(it, &src_ch_layout) == 0) {
       return src_ch_layout;
     }
   }
+
   // Use the default layout of the codec.
-  return codec->channel_layouts[0];
+  return codec->ch_layouts[0];
 }
 
 void configure_audio_codec_ctx(
     AVCodecContext* codec_ctx,
     AVSampleFormat format,
     int sample_rate,
-    uint64_t channel_layout,
+    AVChannelLayout channel_layout,
     const std::optional<CodecConfig>& codec_config) {
   codec_ctx->sample_fmt = format;
   codec_ctx->sample_rate = sample_rate;
   codec_ctx->time_base = av_inv_q(av_d2q(sample_rate, 1 << 24));
-  codec_ctx->channels = av_get_channel_layout_nb_channels(channel_layout);
-  codec_ctx->channel_layout = channel_layout;
+
+  av_channel_layout_uninit(&codec_ctx->ch_layout);
+
+  int ret = av_channel_layout_copy(&codec_ctx->ch_layout, &channel_layout);
+  TORCH_CHECK(ret >= 0, "Failed to set channel layout: ", av_err2string(ret));
 
   // Set optional stuff
   if (codec_config) {
@@ -595,23 +620,33 @@
 FilterGraph get_audio_filter_graph(
     AVSampleFormat src_fmt,
     int src_sample_rate,
-    uint64_t src_ch_layout,
+    AVChannelLayout src_ch_layout,
     const std::optional<std::string>& filter_desc,
     AVSampleFormat enc_fmt,
     int enc_sample_rate,
-    uint64_t enc_ch_layout,
+    AVChannelLayout enc_ch_layout,
     int nb_samples) {
   const auto desc = [&]() -> const std::string {
     std::vector<std::string> parts;
     if (filter_desc) {
       parts.push_back(filter_desc.value());
     }
+
     if (filter_desc || src_fmt != enc_fmt ||
-        src_sample_rate != enc_sample_rate || src_ch_layout != enc_ch_layout) {
+        src_sample_rate != enc_sample_rate || av_channel_layout_compare(&src_ch_layout, &enc_ch_layout) != 0) {
+
+      char ch_layout_str[128];
+      int ret = av_channel_layout_describe(&enc_ch_layout,
+                                           ch_layout_str,
+                                           sizeof(ch_layout_str));
+      TORCH_CHECK(ret >= 0,
+                  "Failed to describe channel layout: ",
+                  av_err2string(ret));
+
       std::stringstream ss;
       ss << "aformat=sample_fmts=" << av_get_sample_fmt_name(enc_fmt)
-         << ":sample_rates=" << enc_sample_rate << ":channel_layouts=0x"
-         << std::hex << enc_ch_layout;
+         << ":sample_rates=" << enc_sample_rate << ":channel_layouts="
+         << ch_layout_str;
       parts.push_back(ss.str());
     }
     if (nb_samples > 0) {
@@ -697,20 +732,21 @@
     AVSampleFormat format,
     int sample_rate,
     int num_channels,
-    uint64_t channel_layout,
+    AVChannelLayout channel_layout,
     int nb_samples) {
   AVFramePtr frame{alloc_avframe()};
   frame->format = format;
-  frame->channel_layout = channel_layout;
   frame->sample_rate = sample_rate;
   frame->nb_samples = nb_samples;
+
+  frame ->ch_layout = channel_layout;
+
   int ret = av_frame_get_buffer(frame, 0);
   TORCH_CHECK(
       ret >= 0, "Error allocating the source audio frame:", av_err2string(ret));
 
   // Note: `channels` attribute is not required for encoding, but
   // TensorConverter refers to it
-  frame->channels = num_channels;
   frame->pts = 0;
   return frame;
 }
@@ -767,8 +803,10 @@
   const AVSampleFormat src_fmt = (disable_converter)
       ? av_get_sample_fmt(format.c_str())
       : get_src_sample_fmt(format);
-  const auto src_ch_layout =
-      static_cast<uint64_t>(av_get_default_channel_layout(src_num_channels));
+
+  // CHANGE: Convert integer channel count to AVChannelLayout struct
+  AVChannelLayout src_ch_layout;
+  av_channel_layout_default(&src_ch_layout, src_num_channels);
 
   // 2. Fetch codec from default or override
   TORCH_CHECK(
@@ -780,7 +818,9 @@
   // 3. Check that encoding sample format, sample rate and channels
   const AVSampleFormat enc_fmt = get_enc_fmt(src_fmt, encoder_format, codec);
   const int enc_sr = get_enc_sr(src_sample_rate, encoder_sample_rate, codec);
-  const uint64_t enc_ch_layout = [&]() -> uint64_t {
+
+  // CHANGE: Return type is now AVChannelLayout
+  const AVChannelLayout enc_ch_layout = [&]() -> AVChannelLayout {
     if (std::strcmp(codec->name, "vorbis") == 0) {
       // Special case for vorbis.
       // It only supports 2 channels, but it is not listed in channel_layouts
@@ -788,7 +828,10 @@
       // https://github.com/FFmpeg/FFmpeg/blob/0684e58886881a998f1a7b510d73600ff1df2b90/libavcodec/vorbisenc.c#L1277
       // This is the case for at least until FFmpeg 6.0, so it will be
       // like this for a while.
-      return static_cast<uint64_t>(av_get_default_channel_layout(2));
+      // CHANGE: Use struct initialization for Vorbis default
+      AVChannelLayout layout;
+      av_channel_layout_default(&layout, 2);
+      return layout;
     }
     return get_channel_layout(src_ch_layout, encoder_num_channels, codec);
   }();
@@ -796,11 +839,13 @@
   // 4. Initialize codec context
   AVCodecContextPtr codec_ctx =
       get_codec_ctx(codec, format_ctx->oformat->flags);
+  // CHANGE: You must ensure configure_audio_codec_ctx accepts AVChannelLayout now
   configure_audio_codec_ctx(
       codec_ctx, enc_fmt, enc_sr, enc_ch_layout, codec_config);
   open_codec(codec_ctx, encoder_option);
 
   // 5. Build filter graph
+  // CHANGE: You must ensure get_audio_filter_graph accepts AVChannelLayout now
   FilterGraph filter_graph = get_audio_filter_graph(
       src_fmt,
       src_sample_rate,
@@ -812,6 +857,7 @@
       codec_ctx->frame_size);
 
   // 6. Instantiate source frame
+  // CHANGE: You must ensure get_audio_frame accepts AVChannelLayout now
   AVFramePtr src_frame = get_audio_frame(
       src_fmt,
       src_sample_rate,
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/stream_writer.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_writer/stream_writer.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/stream_writer.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_writer/stream_writer.cpp	2025-12-01 14:11:58.947476037 +0100
@@ -355,7 +355,7 @@
 AVIOContext* get_io_context(
     void* opaque,
     int buffer_size,
-    int (*write_packet)(void* opaque, uint8_t* buf, int buf_size),
+    int (*write_packet)(void* opaque, const uint8_t* buf, int buf_size),
     int64_t (*seek)(void* opaque, int64_t offset, int whence)) {
   unsigned char* buffer = static_cast<unsigned char*>(av_malloc(buffer_size));
   TORCH_CHECK(buffer, "Failed to allocate buffer.");
@@ -372,7 +372,7 @@
 CustomOutput::CustomOutput(
     void* opaque,
     int buffer_size,
-    int (*write_packet)(void* opaque, uint8_t* buf, int buf_size),
+    int (*write_packet)(void* opaque, const uint8_t* buf, int buf_size),
     int64_t (*seek)(void* opaque, int64_t offset, int whence))
     : io_ctx(get_io_context(opaque, buffer_size, write_packet, seek)) {}
 } // namespace detail
@@ -381,7 +381,7 @@
     void* opaque,
     const std::optional<std::string>& format,
     int buffer_size,
-    int (*write_packet)(void* opaque, uint8_t* buf, int buf_size),
+    int (*write_packet)(void* opaque, const uint8_t* buf, int buf_size),
     int64_t (*seek)(void* opaque, int64_t offset, int whence))
     : CustomOutput(opaque, buffer_size, write_packet, seek),
       StreamingMediaEncoder(io_ctx, format) {}
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/stream_writer.h audio-2.6.0/src/libtorio/ffmpeg/stream_writer/stream_writer.h
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/stream_writer.h	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_writer/stream_writer.h	2025-12-01 14:12:52.557260048 +0100
@@ -299,7 +299,7 @@
   CustomOutput(
       void* opaque,
       int buffer_size,
-      int (*write_packet)(void* opaque, uint8_t* buf, int buf_size),
+      int (*write_packet)(void* opaque, const uint8_t* buf, int buf_size),
       int64_t (*seek)(void* opaque, int64_t offset, int whence));
 };
 } // namespace detail
@@ -327,7 +327,7 @@
       void* opaque,
       const std::optional<std::string>& format,
       int buffer_size,
-      int (*write_packet)(void* opaque, uint8_t* buf, int buf_size),
+      int (*write_packet)(void* opaque, const uint8_t* buf, int buf_size),
       int64_t (*seek)(void* opaque, int64_t offset, int whence) = nullptr);
 };
 
diff -ur audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/tensor_converter.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_writer/tensor_converter.cpp
--- audio-2.6.0.orig/src/libtorio/ffmpeg/stream_writer/tensor_converter.cpp	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_writer/tensor_converter.cpp	2025-12-01 18:39:16.927582605 +0100
@@ -29,10 +29,13 @@
       t.dtype().toScalarType());
   TORCH_CHECK(t.device().is_cpu(), "Input tensor has to be on CPU.");
   TORCH_CHECK(t.dim() == 2, "Input Tensor has to be 2D.");
+
+  const int channels = buffer->ch_layout.nb_channels;
+
   TORCH_CHECK(
-      t.size(1) == buffer->channels,
+      t.size(1) == channels,
       "Expected waveform with ",
-      buffer->channels,
+      channels,
       " channels. Found ",
       t.size(1));
 }
@@ -40,7 +43,9 @@
 // 2D (time, channel) and contiguous.
 void convert_func_(const torch::Tensor& chunk, AVFrame* buffer) {
   TORCH_INTERNAL_ASSERT_DEBUG_ONLY(chunk.dim() == 2);
-  TORCH_INTERNAL_ASSERT_DEBUG_ONLY(chunk.size(1) == buffer->channels);
+
+  const int channels = buffer->ch_layout.nb_channels;
+  TORCH_INTERNAL_ASSERT_DEBUG_ONLY(chunk.size(1) == channels);
 
   // https://ffmpeg.org/doxygen/4.1/muxing_8c_source.html#l00334
   if (!av_frame_is_writable(buffer)) {
diff -ur audio-2.6.0.orig/src/torchaudio/io/_effector.py audio-2.6.0/src/torchaudio/io/_effector.py
--- audio-2.6.0.orig/src/torchaudio/io/_effector.py	2025-01-29 02:11:55.000000000 +0100
+++ audio-2.6.0/src/torchaudio/io/_effector.py	2025-12-03 16:36:30.536644472 +0100
@@ -264,12 +264,11 @@
             option = {}
             # Some formats are headerless, so need to provide these infomation.
             if self.format == "mulaw":
-                option = {"sample_rate": f"{sample_rate}", "channels": f"{num_channels}"}
-
+                option = {"sample_rate": f"{sample_rate}", "ch_layout": f"{num_channels}c"}
         else:  # PCM
             muxer = _get_muxer(waveform.dtype)
             encoder = None
-            option = {"sample_rate": f"{sample_rate}", "channels": f"{num_channels}"}
+            option = {"sample_rate": f"{sample_rate}", "ch_layout": f"{num_channels}c"}
 
         if frames_per_chunk is None:
             src = _encode(waveform, sample_rate, self.effect, muxer, encoder, self.codec_config)
