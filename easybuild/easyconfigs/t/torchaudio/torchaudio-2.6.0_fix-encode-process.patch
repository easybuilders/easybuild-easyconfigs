Allow encoder sample_fmt fallback (e.g. s16 -> fltp for libvorbis):
get_enc_fmt() fall back to the codec's first supported sample_fmt when the requested encoder_format isn't supported.
This fixes OGG/Vorbis saves with FFmpeg+libvorbis where only fltp is accepted and s16 (or others) causes encoder open to fail.
A TORCH_WARN_ONCE is emitted and the filter graph performs the conversion.
Default behavior remains: prefer src_fmt if supported, else use the codec's first supported format.
Errors without this patch:
[libvorbis] Specified sample format s16 is not supported by the libvorbis encoder (supported: fltp)
Error while opening encoder / Conversion failed
Author: Pavel Tomanek (Inuits/Ugent)
------------------------------------------------------------------
diff -Nru audio-2.6.0.p1/src/libtorio/ffmpeg/stream_writer/encode_process.cpp audio-2.6.0/src/libtorio/ffmpeg/stream_writer/encode_process.cpp
--- audio-2.6.0.p1/src/libtorio/ffmpeg/stream_writer/encode_process.cpp	2026-02-13 15:55:06.105338831 +0000
+++ audio-2.6.0/src/libtorio/ffmpeg/stream_writer/encode_process.cpp	2026-02-13 15:55:29.426444845 +0000
@@ -229,23 +229,39 @@
     const std::optional<std::string>& encoder_format,
     const AVCodec* codec) {
   if (encoder_format) {
-    auto& enc_fmt_val = encoder_format.value();
-    auto fmt = av_get_sample_fmt(enc_fmt_val.c_str());
-    TORCH_CHECK(
-        fmt != AV_SAMPLE_FMT_NONE, "Unknown sample format: ", enc_fmt_val);
-    TORCH_CHECK(
-        supported_sample_fmt(fmt, codec->sample_fmts),
-        codec->name,
-        " does not support ",
-        encoder_format.value(),
-        " format. Supported values are; ",
-        get_supported_formats(codec->sample_fmts));
+    const auto& enc_fmt_val = encoder_format.value();
+    AVSampleFormat fmt = av_get_sample_fmt(enc_fmt_val.c_str());
+    TORCH_CHECK(fmt != AV_SAMPLE_FMT_NONE, "Unknown sample format: ", enc_fmt_val);
+
+    if (supported_sample_fmt(fmt, codec->sample_fmts)) {
+      return fmt;
+    }
+
+    // If codec has restrictions, fall back to its first supported format
+    // and rely on filter graph conversion.
+    if (codec->sample_fmts) {
+      TORCH_WARN_ONCE(
+          codec->name,
+          " does not support requested sample format ",
+          enc_fmt_val,
+          "; falling back to ",
+          av_get_sample_fmt_name(codec->sample_fmts[0]),
+          " and converting via filter graph.");
+      return codec->sample_fmts[0];
+    }
+
+    // If codec does not advertise supported formats, just use the requested one.
     return fmt;
   }
-  if (codec->sample_fmts) {
-    return codec->sample_fmts[0];
+
+  // No explicit encoder format requested: keep the source format if possible.
+  if (!codec->sample_fmts) {
+    return src_fmt;
   }
-  return src_fmt;
+  if (supported_sample_fmt(src_fmt, codec->sample_fmts)) {
+    return src_fmt;
+  }
+  return codec->sample_fmts[0];
 };
 
 bool supported_sample_rate(const int sample_rate, const AVCodec* codec) {
@@ -313,11 +329,11 @@
   return src_sample_rate;
 }
 
-// Helper to handle the "Describe" API which now requires a buffer
 std::string describe_layout(const AVChannelLayout& layout) {
-    char buf[256];
-    av_channel_layout_describe(&layout, buf, sizeof(buf));
-    return std::string(buf);
+  char buf[256];
+  int ret = av_channel_layout_describe(&layout, buf, sizeof(buf));
+  TORCH_CHECK(ret >= 0, "Failed to describe channel layout: ", av_err2string(ret));
+  return std::string(buf);
 }
 
 std::string get_supported_channels(const AVChannelLayout* channel_layouts) {
@@ -333,8 +349,6 @@
   return c10::Join(", ", names);
 }
 
-// Return type changed from uint64_t to AVChannelLayout
-// Input src_ch_layout changed from uint64_t to const AVChannelLayout&
 AVChannelLayout get_channel_layout(
     const AVChannelLayout& src_ch_layout,
     const std::optional<int> enc_num_channels,
@@ -344,20 +358,16 @@
     const int& val = enc_num_channels.value();
     TORCH_CHECK(
         val > 0, "The number of channels must be greater than 0. Found: ", val);
-
-    // Check if codec has specific supported layouts (ch_layouts replaces channel_layouts)
     if (!codec->ch_layouts) {
       AVChannelLayout default_layout;
       av_channel_layout_default(&default_layout, val);
       return default_layout;
     }
-
     for (const AVChannelLayout* it = codec->ch_layouts; it->nb_channels; ++it) {
       if (it->nb_channels == val) {
         return *it;
       }
     }
-
     TORCH_CHECK(
         false,
         "Codec ",
@@ -398,7 +408,6 @@
   codec_ctx->time_base = av_inv_q(av_d2q(sample_rate, 1 << 24));
 
   av_channel_layout_uninit(&codec_ctx->ch_layout);
-
   int ret = av_channel_layout_copy(&codec_ctx->ch_layout, &channel_layout);
   TORCH_CHECK(ret >= 0, "Failed to set channel layout: ", av_err2string(ret));
 
@@ -631,18 +640,16 @@
     if (filter_desc) {
       parts.push_back(filter_desc.value());
     }
-
     if (filter_desc || src_fmt != enc_fmt ||
-        src_sample_rate != enc_sample_rate || av_channel_layout_compare(&src_ch_layout, &enc_ch_layout) != 0) {
-
+        src_sample_rate != enc_sample_rate ||
+        av_channel_layout_compare(&src_ch_layout, &enc_ch_layout) != 0) {
       char ch_layout_str[128];
-      int ret = av_channel_layout_describe(&enc_ch_layout,
-                                           ch_layout_str,
-                                           sizeof(ch_layout_str));
-      TORCH_CHECK(ret >= 0,
-                  "Failed to describe channel layout: ",
-                  av_err2string(ret));
-
+      int ret = av_channel_layout_describe(
+          &enc_ch_layout, ch_layout_str, sizeof(ch_layout_str));
+      TORCH_CHECK(
+          ret >= 0,
+          "Failed to describe channel layout: ",
+          av_err2string(ret));
       std::stringstream ss;
       ss << "aformat=sample_fmts=" << av_get_sample_fmt_name(enc_fmt)
          << ":sample_rates=" << enc_sample_rate << ":channel_layouts="
@@ -731,22 +738,17 @@
 AVFramePtr get_audio_frame(
     AVSampleFormat format,
     int sample_rate,
-    int num_channels,
     AVChannelLayout channel_layout,
     int nb_samples) {
   AVFramePtr frame{alloc_avframe()};
   frame->format = format;
   frame->sample_rate = sample_rate;
   frame->nb_samples = nb_samples;
-
-  frame ->ch_layout = channel_layout;
-
+  frame->ch_layout = channel_layout;
   int ret = av_frame_get_buffer(frame, 0);
   TORCH_CHECK(
       ret >= 0, "Error allocating the source audio frame:", av_err2string(ret));
 
-  // Note: `channels` attribute is not required for encoding, but
-  // TensorConverter refers to it
   frame->pts = 0;
   return frame;
 }
@@ -803,8 +805,6 @@
   const AVSampleFormat src_fmt = (disable_converter)
       ? av_get_sample_fmt(format.c_str())
       : get_src_sample_fmt(format);
-
-  // CHANGE: Convert integer channel count to AVChannelLayout struct
   AVChannelLayout src_ch_layout;
   av_channel_layout_default(&src_ch_layout, src_num_channels);
 
@@ -818,8 +818,6 @@
   // 3. Check that encoding sample format, sample rate and channels
   const AVSampleFormat enc_fmt = get_enc_fmt(src_fmt, encoder_format, codec);
   const int enc_sr = get_enc_sr(src_sample_rate, encoder_sample_rate, codec);
-
-  // CHANGE: Return type is now AVChannelLayout
   const AVChannelLayout enc_ch_layout = [&]() -> AVChannelLayout {
     if (std::strcmp(codec->name, "vorbis") == 0) {
       // Special case for vorbis.
@@ -828,7 +826,6 @@
       // https://github.com/FFmpeg/FFmpeg/blob/0684e58886881a998f1a7b510d73600ff1df2b90/libavcodec/vorbisenc.c#L1277
       // This is the case for at least until FFmpeg 6.0, so it will be
       // like this for a while.
-      // CHANGE: Use struct initialization for Vorbis default
       AVChannelLayout layout;
       av_channel_layout_default(&layout, 2);
       return layout;
@@ -839,13 +836,11 @@
   // 4. Initialize codec context
   AVCodecContextPtr codec_ctx =
       get_codec_ctx(codec, format_ctx->oformat->flags);
-  // CHANGE: You must ensure configure_audio_codec_ctx accepts AVChannelLayout now
   configure_audio_codec_ctx(
       codec_ctx, enc_fmt, enc_sr, enc_ch_layout, codec_config);
   open_codec(codec_ctx, encoder_option);
 
   // 5. Build filter graph
-  // CHANGE: You must ensure get_audio_filter_graph accepts AVChannelLayout now
   FilterGraph filter_graph = get_audio_filter_graph(
       src_fmt,
       src_sample_rate,
@@ -857,11 +852,9 @@
       codec_ctx->frame_size);
 
   // 6. Instantiate source frame
-  // CHANGE: You must ensure get_audio_frame accepts AVChannelLayout now
   AVFramePtr src_frame = get_audio_frame(
       src_fmt,
       src_sample_rate,
-      src_num_channels,
       src_ch_layout,
       codec_ctx->frame_size > 0 ? codec_ctx->frame_size : 256);
 