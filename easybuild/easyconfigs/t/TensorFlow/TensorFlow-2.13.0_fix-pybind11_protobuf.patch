Make the pybind11_protobuf protobuf work with our system/EB-installed protobuf
by removing unused references.

Author: Alexander Grund (TU Dresden)

diff --git a/tensorflow/workspace2.bzl b/tensorflow/workspace2.bzl
index da9295adaba..543746c4815 100644
--- a/tensorflow/workspace2.bzl
+++ b/tensorflow/workspace2.bzl
@@ -875,7 +875,10 @@ def _tf_repositories():
         urls = tf_mirror_urls("https://github.com/pybind/pybind11_protobuf/archive/80f3440cd8fee124e077e2e47a8a17b78b451363.zip"),
         sha256 = "c7ab64b1ccf9a678694a89035a8c865a693e4e872803778f91f0965c2f281d78",
         strip_prefix = "pybind11_protobuf-80f3440cd8fee124e077e2e47a8a17b78b451363",
-        patch_file = ["//third_party/pybind11_protobuf:remove_license.patch"],
+        patch_file = [
+            "//third_party/pybind11_protobuf:fix_proto_api_use.patch",
+            "//third_party/pybind11_protobuf:remove_license.patch",
+        ],
     )
 
     tf_http_archive(
diff --git a/third_party/pybind11_protobuf/fix_proto_api_use.patch b/third_party/pybind11_protobuf/fix_proto_api_use.patch
new file mode 100644
index 00000000000..0a82655c5cd
--- /dev/null
+++ b/third_party/pybind11_protobuf/fix_proto_api_use.patch
@@ -0,0 +1,124 @@
+diff --git a/pybind11_protobuf/BUILD b/pybind11_protobuf/BUILD
+index b62eb91..1856ad3 100644
+--- a/pybind11_protobuf/BUILD
++++ b/pybind11_protobuf/BUILD
+@@ -61,9 +61,11 @@ pybind_library(
+         "@com_google_absl//absl/container:flat_hash_map",
+         "@com_google_absl//absl/strings",
+         "@com_google_absl//absl/types:optional",
+-        "@com_google_protobuf//:proto_api",
+         "@com_google_protobuf//:protobuf",
+-    ],
++    ] + select({
++        ":enable_pyproto_api_setting": ["@com_google_protobuf//:proto_api"],
++        "//conditions:default": [],
++    }),
+ )
+ 
+ pybind_library(
+diff --git a/pybind11_protobuf/proto_cast_util.cc b/pybind11_protobuf/proto_cast_util.cc
+index 52c57c9..70801c8 100644
+--- a/pybind11_protobuf/proto_cast_util.cc
++++ b/pybind11_protobuf/proto_cast_util.cc
+@@ -14,9 +14,12 @@
+ 
+ #include "google/protobuf/descriptor.pb.h"
+ #include "google/protobuf/descriptor.h"
++#include "google/protobuf/descriptor_database.h"
+ #include "google/protobuf/dynamic_message.h"
+ #include "google/protobuf/message.h"
++#if defined(PYBIND11_PROTOBUF_ENABLE_PYPROTO_API)
+ #include "python/google/protobuf/proto_api.h"
++#endif
+ #include "absl/container/flat_hash_map.h"
+ #include "absl/strings/numbers.h"
+ #include "absl/strings/str_replace.h"
+@@ -35,8 +38,11 @@ using ::google::protobuf::FileDescriptor;
+ using ::google::protobuf::FileDescriptorProto;
+ using ::google::protobuf::Message;
+ using ::google::protobuf::MessageFactory;
++#if defined(PYBIND11_PROTOBUF_ENABLE_PYPROTO_API)
+ using ::google::protobuf::python::PyProto_API;
+-using ::google::protobuf::python::PyProtoAPICapsuleName;
++#else
++struct PyProto_API;
++#endif
+ 
+ namespace pybind11_protobuf {
+ namespace {
+@@ -225,6 +231,7 @@ GlobalState::GlobalState() {
+   using_fast_cpp_ = (CastToOptionalString(type).value_or("") == "cpp");
+ 
+ #if defined(PYBIND11_PROTOBUF_ENABLE_PYPROTO_API)
++  using ::google::protobuf::python::PyProtoAPICapsuleName;
+   // DANGER: The only way to guarantee that the PyProto_API doesn't have
+   // incompatible ABI changes is to ensure that the python protobuf .so
+   // and all other extension .so files are built with the exact same
+@@ -321,6 +328,7 @@ py::object GlobalState::PyMessageInstance(const Descriptor* descriptor) {
+                        module_name + "?");
+ }
+ 
++#if defined(PYBIND11_PROTOBUF_ENABLE_PYPROTO_API)
+ std::pair<py::object, Message*> GlobalState::PyFastCppProtoMessageInstance(
+     const Descriptor* descriptor) {
+   assert(descriptor != nullptr);
+@@ -361,6 +369,7 @@ std::pair<py::object, Message*> GlobalState::PyFastCppProtoMessageInstance(
+   }
+   return {std::move(result), message};
+ }
++#endif
+ 
+ // Create C++ DescriptorPools based on Python DescriptorPools.
+ // The Python pool will provide message definitions when they are needed.
+@@ -500,6 +509,7 @@ class PythonDescriptorPoolWrapper {
+    private:
+     bool CopyToFileDescriptorProto(py::handle py_file_descriptor,
+                                    FileDescriptorProto* output) {
++#if defined(PYBIND11_PROTOBUF_ENABLE_PYPROTO_API)
+       if (GlobalState::instance()->py_proto_api()) {
+         try {
+           py::object c_proto = py::reinterpret_steal<py::object>(
+@@ -518,6 +528,7 @@ class PythonDescriptorPoolWrapper {
+           PyErr_Print();
+         }
+       }
++#endif
+ 
+       py::object wire = py_file_descriptor.attr("serialized_pb");
+       const char* bytes = PYBIND11_BYTES_AS_STRING(wire.ptr());
+@@ -561,6 +572,9 @@ void ImportProtoDescriptorModule(const Descriptor* descriptor) {
+ 
+ const Message* PyProtoGetCppMessagePointer(py::handle src) {
+   assert(PyGILState_Check());
++#ifndef PYBIND11_PROTOBUF_ENABLE_PYPROTO_API
++  return nullptr;
++#else
+   if (!GlobalState::instance()->py_proto_api()) return nullptr;
+   auto* ptr =
+       GlobalState::instance()->py_proto_api()->GetMessagePointer(src.ptr());
+@@ -571,6 +585,7 @@ const Message* PyProtoGetCppMessagePointer(py::handle src) {
+     return nullptr;
+   }
+   return ptr;
++#endif
+ }
+ 
+ absl::optional<std::string> PyProtoDescriptorName(py::handle py_proto) {
+@@ -732,6 +747,9 @@ py::handle GenericPyProtoCast(Message* src, py::return_value_policy policy,
+ 
+ py::handle GenericFastCppProtoCast(Message* src, py::return_value_policy policy,
+                                    py::handle parent, bool is_const) {
++#ifndef PYBIND11_PROTOBUF_ENABLE_PYPROTO_API
++  throw std::logic_error("Not implemented");
++#else
+   assert(policy != pybind11::return_value_policy::automatic);
+   assert(policy != pybind11::return_value_policy::automatic_reference);
+   assert(src != nullptr);
+@@ -802,6 +820,7 @@ py::handle GenericFastCppProtoCast(Message* src, py::return_value_policy policy,
+       std::string message("pybind11_protobuf unhandled return_value_policy::");
+       throw py::cast_error(message + ReturnValuePolicyName(policy));
+   }
++#endif
+ }
+ 
+ py::handle GenericProtoCast(Message* src, py::return_value_policy policy,
