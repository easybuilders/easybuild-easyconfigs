Rename FALSE macro to prevent the following error:

../shared/commonlib.h:88:24: error: expected identifier or ‘(’ before numeric constant
   #define FALSE        0

See https://github.com/chandu-atina/lp_solve_python_3x/issues/1
author: Davide Vanzo (Vanderbilt University)
diff -ru lp_solve_5.5.orig/lp_crash.c lp_solve_5.5/lp_crash.c
--- lp_solve_5.5.orig/lp_crash.c	2019-02-19 10:42:21.368737063 -0600
+++ lp_solve_5.5/lp_crash.c	2019-02-19 11:55:26.088858391 -0600
@@ -39,7 +39,7 @@
 
   /* Initialize basis indicators */
   if(lp->basis_valid)
-    lp->var_basic[0] = FALSE;
+    lp->var_basic[0] = FFALSE;
   else
     default_basis(lp);
 
@@ -64,8 +64,8 @@
     /* Tally row and column non-zero counts */
     ok = allocINT(lp,  &rowNZ, lp->rows+1,     TRUE) &&
          allocINT(lp,  &colNZ, lp->columns+1,  TRUE) &&
-         allocREAL(lp, &rowMAX, lp->rows+1,    FALSE) &&
-         allocREAL(lp, &colMAX, lp->columns+1, FALSE);
+         allocREAL(lp, &rowMAX, lp->rows+1,    FFALSE) &&
+         allocREAL(lp, &colMAX, lp->columns+1, FFALSE);
     if(!ok)
       goto Finish;
 
@@ -241,9 +241,9 @@
     report(lp, NORMAL, "crash_basis: 'Least degenerate' basis crashing selected\n");
 
     /* Create temporary arrays */
-    ok = allocINT(lp,  &merit, lp->columns + 1, FALSE) &&
-         allocREAL(lp, &eta, lp->rows + 1, FALSE) &&
-         allocREAL(lp, &rhs, lp->rows + 1, FALSE);
+    ok = allocINT(lp,  &merit, lp->columns + 1, FFALSE) &&
+         allocREAL(lp, &eta, lp->rows + 1, FFALSE) &&
+         allocREAL(lp, &rhs, lp->rows + 1, FFALSE);
     createLink(lp->columns, &colLL, NULL);
     createLink(lp->rows, &rowLL, NULL);
     ok &= (colLL != NULL) && (rowLL != NULL);
@@ -337,7 +337,7 @@
 #if 0
 MYBOOL __WINAPI guess_basis(lprec *lp, REAL *guessvector, int *basisvector)
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
   REAL   *values = NULL, *violation = NULL,
          *value, error, upB, loB, sortorder = 1.0;
   int    i, n, *rownr, *colnr;
@@ -411,7 +411,7 @@
 
   /* Sort decending by violation; this means that variables with
      the largest violations will be designated as basic */
-  sortByREAL(basisvector, violation, lp->sum, 1, FALSE);
+  sortByREAL(basisvector, violation, lp->sum, 1, FFALSE);
 
   /* Adjust the non-basic indeces for the (proximal) bound state */
   error = lp->epsprimal;
@@ -439,7 +439,7 @@
 #if 0
 MYBOOL __WINAPI guess_basis(lprec *lp, REAL *guessvector, int *basisvector)
 {
-  MYBOOL *isnz, status = FALSE;
+  MYBOOL *isnz, status = FFALSE;
   REAL   *values = NULL, *violation = NULL,
          eps = lp->epsprimal,
          *value, error, upB, loB, sortorder = 1.0;
@@ -515,7 +515,7 @@
 
   /* Sort decending by violation; this means that variables with
      the largest violations will be designated as basic */
-  sortByREAL(basisvector, violation, lp->sum, 1, FALSE);
+  sortByREAL(basisvector, violation, lp->sum, 1, FFALSE);
   error = violation[1];
 
   /* Adjust the non-basic indeces for the (proximal) bound state */
@@ -583,7 +583,7 @@
 #if 0
 MYBOOL __WINAPI guess_basis(lprec *lp, REAL *guessvector, int *basisvector)
 {
-  MYBOOL *isnz, status = FALSE;
+  MYBOOL *isnz, status = FFALSE;
   REAL   *values = NULL, *violation = NULL,
          eps = lp->epsprimal,
          *value, error, upB, loB, sortorder = 1.0;
@@ -659,7 +659,7 @@
 
   /* Sort decending by violation; this means that variables with
      the largest violations will be designated as basic */
-  sortByREAL(basisvector, violation, lp->sum, 1, FALSE);
+  sortByREAL(basisvector, violation, lp->sum, 1, FFALSE);
   error = violation[1];
 
   /* Adjust the non-basic indeces for the (proximal) bound state */
@@ -730,7 +730,7 @@
 
 MYBOOL __WINAPI guess_basis(lprec *lp, REAL *guessvector, int *basisvector)
 {
-  MYBOOL *isnz = NULL, status = FALSE;
+  MYBOOL *isnz = NULL, status = FFALSE;
   REAL   *values = NULL, *violation = NULL,
          eps = lp->epsprimal,
          *value, error, upB, loB, sortorder = -1.0;
@@ -793,7 +793,7 @@
   /* Sort decending , meaning that variables with the largest
      "violations" will be designated basic. Effectively, we are performing a
      greedy type algorithm, but start at the "least interesting" end. */
-  sortByREAL(basisvector, violation, nsum, 1, FALSE);
+  sortByREAL(basisvector, violation, nsum, 1, FFALSE);
   error = violation[1]; /* Used for setting the return value */
 
   /* Let us check for obvious row singularities and try to fix these.
diff -ru lp_solve_5.5.orig/lp_lib.c lp_solve_5.5/lp_lib.c
--- lp_solve_5.5.orig/lp_lib.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_lib.c	2019-02-19 12:07:38.248878651 -0600
@@ -157,7 +157,7 @@
     lp->outstream = stdout;
   else
     lp->outstream = stream;
-  lp->streamowned = FALSE;
+  lp->streamowned = FFALSE;
 }
 
 MYBOOL __WINAPI set_outputfile(lprec *lp, char *filename)
@@ -327,7 +327,7 @@
 #ifndef PARSER_LP
 MYBOOL __WINAPI LP_readhandle(lprec **lp, FILE *filename, int verbose, char *lp_name)
 {
-  return(FALSE);
+  return(FFALSE);
 }
 lprec * __WINAPI read_lp(FILE *filename, int verbose, char *lp_name)
 {
@@ -354,7 +354,7 @@
   if(typeMPS) {
     set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);
     lp->basis_valid = TRUE;   /* Do not re-initialize basis on entering Solve */
-    lp->var_basic[0] = FALSE; /* Set to signal that this is a non-default basis */
+    lp->var_basic[0] = FFALSE; /* Set to signal that this is a non-default basis */
   }
   return( (MYBOOL) typeMPS );
 }
@@ -369,7 +369,7 @@
   /* lp->lag_accept        = DEF_LAGACCEPT; */
   set_epslevel(lp, EPS_DEFAULT);
 
-  lp->tighten_on_set    = FALSE;
+  lp->tighten_on_set    = FFALSE;
   lp->negrange          = DEF_NEGRANGE;
 
 #if 0
@@ -432,10 +432,10 @@
 
   set_outputstream(lp, NULL);          /* Set to default output stream */
   lp->verbose           = NORMAL;
-  lp->print_sol         = FALSE;       /* Can be FALSE, TRUE, AUTOMATIC (only non-zeros printed) */
-  lp->spx_trace         = FALSE;
-  lp->lag_trace         = FALSE;
-  lp->bb_trace          = FALSE;
+  lp->print_sol         = FFALSE;       /* Can be FALSE, TRUE, AUTOMATIC (only non-zeros printed) */
+  lp->spx_trace         = FFALSE;
+  lp->lag_trace         = FFALSE;
+  lp->bb_trace          = FFALSE;
 }
 
 void __WINAPI unscale(lprec *lp)
@@ -451,7 +451,7 @@
   if(has_BFP(lp)) {
     lp->solvecount++;
     if(is_add_rowmode(lp))
-      set_add_rowmode(lp, FALSE);
+      set_add_rowmode(lp, FFALSE);
     return(lin_solve(lp));
   }
   else
@@ -677,14 +677,14 @@
 {
   if(colnr > lp->columns || colnr < 1) {
     report(lp, IMPORTANT, "set_var_branch: Column %d out of range\n", colnr);
-    return( FALSE );
+    return( FFALSE );
   }
 
   if(lp->bb_varbranch == NULL) {
     int i;
     if(branch_mode == BRANCH_DEFAULT)
       return( TRUE );
-    allocMYBOOL(lp, &lp->bb_varbranch, lp->columns_alloc, FALSE);
+    allocMYBOOL(lp, &lp->bb_varbranch, lp->columns_alloc, FFALSE);
     for(i = 0; i < lp->columns; i++)
       lp->bb_varbranch[i] = BRANCH_DEFAULT;
   }
@@ -734,13 +734,13 @@
   if(fabs(value) >= lp->infinite)
     return( TRUE );
   else
-    return( FALSE );
+    return( FFALSE );
 #endif
 }
 
 void __WINAPI set_infinite(lprec *lp, REAL infinite)
 {
-  set_infiniteex(lp, infinite, FALSE);
+  set_infiniteex(lp, infinite, FFALSE);
 }
 
 REAL __WINAPI get_infinite(lprec *lp)
@@ -825,7 +825,7 @@
     case EPS_BAGGY:  SPX_RELAX = 1000;
                       MIP_RELAX = 100;
                       break;
-    default:        return( FALSE );
+    default:        return( FFALSE );
   }
   lp->epsvalue   = SPX_RELAX*DEF_EPSVALUE;
   lp->epsprimal  = SPX_RELAX*DEF_EPSPRIMAL;
@@ -1015,11 +1015,11 @@
 {
   if((rownr < 0) || (rownr > lp->rows)) {
     report(lp, IMPORTANT, "set_mat: Row %d out of range\n", rownr);
-    return( FALSE );
+    return( FFALSE );
   }
   if((colnr < 1) || (colnr > lp->columns)) {
     report(lp, IMPORTANT, "set_mat: Column %d out of range\n", colnr);
-    return( FALSE );
+    return( FFALSE );
   }
 
 #ifdef DoMatrixRounding
@@ -1032,7 +1032,7 @@
     return( TRUE );
   }
   else
-    return( mat_setvalue(lp->matA, rownr, colnr, value, FALSE) );
+    return( mat_setvalue(lp->matA, rownr, colnr, value, FFALSE) );
 }
 
 REAL __WINAPI get_working_objective(lprec *lp)
@@ -1087,7 +1087,7 @@
     ;
   else if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_variables: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   MEMCOPY(var, lp->best_solution + (1 + lp->rows), lp->columns);
@@ -1100,7 +1100,7 @@
     ;
   else if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_ptr_variables: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(var != NULL)
@@ -1114,7 +1114,7 @@
     ;
   else if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_constraints: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   MEMCOPY(constr, lp->best_solution + 1, lp->rows);
@@ -1127,7 +1127,7 @@
     ;
   else if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_ptr_constraints: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(constr != NULL)
@@ -1141,14 +1141,14 @@
 
   if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_sensitivity_rhs: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(!get_ptr_sensitivity_rhs(lp,
                               (duals != NULL) ? &duals0 : NULL,
                               (dualsfrom != NULL) ? &dualsfrom0 : NULL,
                               (dualstill != NULL) ? &dualstill0 : NULL))
-    return(FALSE);
+    return(FFALSE);
 
   if(duals != NULL)
     MEMCOPY(duals, duals0, lp->sum);
@@ -1163,17 +1163,17 @@
 {
   if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_ptr_sensitivity_rhs: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(duals != NULL) {
     if(lp->duals == NULL) {
       if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {
         report(lp, CRITICAL, "get_ptr_sensitivity_rhs: Sensitivity unknown\n");
-        return(FALSE);
+        return(FFALSE);
       }
       if(!construct_duals(lp))
-        return(FALSE);
+        return(FFALSE);
     }
     *duals = lp->duals + 1;
   }
@@ -1182,11 +1182,11 @@
     if((lp->dualsfrom == NULL) || (lp->dualstill == NULL)) {
       if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {
         report(lp, CRITICAL, "get_ptr_sensitivity_rhs: Sensitivity unknown\n");
-        return(FALSE);
+        return(FFALSE);
       }
       construct_sensitivity_duals(lp);
       if((lp->dualsfrom == NULL) || (lp->dualstill == NULL))
-        return(FALSE);
+        return(FFALSE);
     }
     if(dualsfrom != NULL)
       *dualsfrom = lp->dualsfrom + 1;
@@ -1202,14 +1202,14 @@
 
   if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_sensitivity_objex: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(!get_ptr_sensitivity_objex(lp, (objfrom != NULL) ? &objfrom0 : NULL,
                                     (objtill != NULL) ? &objtill0 : NULL,
                                     (objfromvalue != NULL) ? &objfromvalue0 : NULL,
                                     (objtillvalue != NULL) ? &objtillvalue0 : NULL))
-    return(FALSE);
+    return(FFALSE);
 
   if((objfrom != NULL) && (objfrom0 != NULL))
     MEMCOPY(objfrom, objfrom0, lp->columns);
@@ -1231,18 +1231,18 @@
 {
   if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_ptr_sensitivity_objex: Not a valid basis\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   if((objfrom != NULL) || (objtill != NULL)) {
     if((lp->objfrom == NULL) || (lp->objtill == NULL)) {
       if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {
         report(lp, CRITICAL, "get_ptr_sensitivity_objex: Sensitivity unknown\n");
-        return(FALSE);
+        return(FFALSE);
       }
       construct_sensitivity_obj(lp);
       if((lp->objfrom == NULL) || (lp->objtill == NULL))
-        return(FALSE);
+        return(FFALSE);
     }
     if(objfrom != NULL)
       *objfrom = lp->objfrom + 1;
@@ -1254,11 +1254,11 @@
     if((lp->objfromvalue == NULL) /* || (lp->objtillvalue == NULL) */) {
       if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {
         report(lp, CRITICAL, "get_ptr_sensitivity_objex: Sensitivity unknown\n");
-        return(FALSE);
+        return(FFALSE);
       }
       construct_sensitivity_duals(lp);
       if((lp->objfromvalue == NULL) /* || (lp->objtillvalue == NULL) */)
-        return(FALSE);
+        return(FFALSE);
     }
   }
 
@@ -1382,7 +1382,7 @@
     return(NULL);
 
   set_lp_name(lp, NULL);
-  lp->names_used    = FALSE;
+  lp->names_used    = FFALSE;
   lp->use_row_names = TRUE;
   lp->use_col_names = TRUE;
   lp->rowcol_name   = NULL;
@@ -1391,7 +1391,7 @@
 #if 1
   lp->obj_in_basis  = DEF_OBJINBASIS;
 #else
-  lp->obj_in_basis  = FALSE;
+  lp->obj_in_basis  = FFALSE;
 #endif
   lp->verbose       = NORMAL;
   set_callbacks(lp);
@@ -1409,15 +1409,15 @@
   reset_params(lp);
 
   /* Do other initializations --------------------------------------------------------------- */
-  lp->source_is_file    = FALSE;
+  lp->source_is_file    = FFALSE;
   lp->model_is_pure     = TRUE;
-  lp->model_is_valid    = FALSE;
+  lp->model_is_valid    = FFALSE;
   lp->spx_status        = NOTRUN;
   lp->lag_status        = NOTRUN;
 
   lp->workarrays = mempool_create(lp);
-  lp->wasPreprocessed   = FALSE;
-  lp->wasPresolved      = FALSE;
+  lp->wasPreprocessed   = FFALSE;
+  lp->wasPresolved      = FFALSE;
   presolve_createUndo(lp);
 
   lp->bb_varactive      = NULL;
@@ -1466,10 +1466,10 @@
   lp->bb_bounds = NULL;
   lp->bb_basis = NULL;
 
-  lp->basis_valid       = FALSE;
+  lp->basis_valid       = FFALSE;
   lp->simplex_mode      = SIMPLEX_DYNAMIC;
-  lp->scaling_used      = FALSE;
-  lp->columns_scaled    = FALSE;
+  lp->scaling_used      = FFALSE;
+  lp->columns_scaled    = FFALSE;
   lp->P1extraDim        = 0;
   lp->P1extraVal        = 0.0;
   lp->bb_strongbranches = 0;
@@ -1590,7 +1590,7 @@
   }
   if(lp->bb_basis != NULL) {
 /*    report(lp, SEVERE, "delete_lp: The stack of saved bases was not empty on delete\n"); */
-    unload_basis(lp, FALSE);
+    unload_basis(lp, FFALSE);
   }
 
   FREE(lp->rejectpivot);
@@ -1654,7 +1654,7 @@
   SOSrec *SOS;
 
   if((index < 1) || (index > SOS_count(lp)))
-    return( FALSE );
+    return( FFALSE );
   SOS = lp->SOS->sos_list[index-1];
   if(name != NULL)
     strcpy(name, SOS->name);
@@ -1683,7 +1683,7 @@
   int   i, n, *idx = NULL;
   REAL  hold, *val = NULL, infinite;
   lprec *newlp = NULL;
-  char buf[256], ok = FALSE;
+  char buf[256], ok = FFALSE;
   int sostype, priority, count, *sosvars, rows, columns;
   REAL *weights = NULL;
 
@@ -1695,8 +1695,8 @@
   rows = get_Nrows(lp);
   columns = get_Ncolumns(lp);
 
-  if(!allocINT(lp, &idx, rows+1, FALSE) ||
-     !allocREAL(lp, &val, rows+1, FALSE))
+  if(!allocINT(lp, &idx, rows+1, FFALSE) ||
+     !allocREAL(lp, &val, rows+1, FFALSE))
     goto Finish;
 
   /* Create the new object */
@@ -1706,7 +1706,7 @@
   if(!resize_lp(newlp, rows, columns))
     goto Finish;
   set_sense(newlp, is_maxim(lp));
-  set_use_names(newlp, FALSE, is_use_names(lp, FALSE));
+  set_use_names(newlp, FFALSE, is_use_names(lp, FFALSE));
   set_use_names(newlp, TRUE, is_use_names(lp, TRUE));
   if(!set_lp_name(newlp, get_lp_name(lp)))
     goto Finish;
@@ -1738,7 +1738,7 @@
   set_bb_depthlimit(newlp, get_bb_depthlimit(lp));
   set_bb_floorfirst(newlp, get_bb_floorfirst(lp));
   set_mip_gap(newlp, TRUE, get_mip_gap(lp, TRUE));
-  set_mip_gap(newlp, FALSE, get_mip_gap(lp, FALSE));
+  set_mip_gap(newlp, FFALSE, get_mip_gap(lp, FFALSE));
   set_break_at_first(newlp, is_break_at_first(lp));
   set_break_at_value(newlp, get_break_at_value(lp));
 
@@ -1789,8 +1789,8 @@
   /* copy SOS data */
   for(i = 1; get_SOS(lp, i, buf, &sostype, &priority, &count, NULL, NULL); i++)
     if (count) {
-      if(!allocINT(lp, &sosvars, count, FALSE) ||
-         !allocREAL(lp, &weights, count, FALSE))
+      if(!allocINT(lp, &sosvars, count, FFALSE) ||
+         !allocREAL(lp, &weights, count, FFALSE))
         n = 0;
       else {
         get_SOS(lp, i, buf, &sostype, &priority, &count, sosvars, weights);
@@ -1811,7 +1811,7 @@
     MEMCOPY(newlp->is_lower, lp->is_lower, lp->sum+1);
     MEMCOPY(newlp->solution, lp->solution, lp->sum+1);
     if(lp->duals != NULL) {
-      allocREAL(newlp, &newlp->duals, newlp->sum_alloc+1, FALSE);
+      allocREAL(newlp, &newlp->duals, newlp->sum_alloc+1, FFALSE);
       MEMCOPY(newlp->duals, lp->duals, lp->sum+1);
     }
     newlp->solutioncount = lp->solutioncount;
@@ -1838,7 +1838,7 @@
 
   /* Are we allowed to perform the operation? */
   if((MIP_count(lp) > 0) || (lp->solvecount > 0))
-    return( FALSE );
+    return( FFALSE );
 
   /* Modify sense */
   set_sense(lp, (MYBOOL) !is_maxim(lp));
@@ -1881,7 +1881,7 @@
 /* Optimize memory usage */
 STATIC MYBOOL memopt_lp(lprec *lp, int rowextra, int colextra, int nzextra)
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
   if(lp == NULL)
     return( status );
@@ -1894,7 +1894,7 @@
     int colalloc = lp->columns_alloc - MIN(lp->columns_alloc, lp->columns + colextra),
         rowalloc = lp->rows_alloc    - MIN(lp->rows_alloc,    lp->rows + rowextra);
 
-    status = inc_lag_space(lp, rowalloc, FALSE) &&
+    status = inc_lag_space(lp, rowalloc, FFALSE) &&
              inc_row_space(lp, rowalloc) &&
              inc_col_space(lp, colalloc);
   }
@@ -1914,7 +1914,7 @@
 STATIC void varmap_clear(lprec *lp)
 {
   presolve_setOrig(lp, 0, 0);
-  lp->varmap_locked = FALSE;
+  lp->varmap_locked = FFALSE;
 }
 STATIC MYBOOL varmap_canunlock(lprec *lp)
 {
@@ -1927,17 +1927,17 @@
     if(/*lp->names_used ||
        (psundo->orig_columns != lp->columns) || (psundo->orig_rows != lp->rows)) */
        (psundo->orig_columns > lp->columns) || (psundo->orig_rows > lp->rows))
-      return( FALSE );
+      return( FFALSE );
 
     /* Check for deletions */
     for(i = psundo->orig_rows + psundo->orig_columns; i > 0; i--)
       if(psundo->orig_to_var[i] == 0)
-        return( FALSE );
+        return( FFALSE );
 
     /* Check for insertions */
     for(i = lp->sum; i > 0; i--)
       if(psundo->var_to_orig[i] == 0)
-        return( FALSE );
+        return( FFALSE );
   }
   return( TRUE );
 }
@@ -2031,7 +2031,7 @@
      2) shift the deleted variable to original mappings left
      3) decrement all subsequent original-to-current pointers
   */
-  if(varmap_canunlock(lp))    lp->varmap_locked = FALSE;
+  if(varmap_canunlock(lp))    lp->varmap_locked = FFALSE;
   for(i = base; i < base-delta; i++) {
     ii = psundo->var_to_orig[i];
     if(ii > 0)
@@ -2267,7 +2267,7 @@
 
   lp->sum += delta;
 
-  lp->matA->row_end_valid = FALSE;
+  lp->matA->row_end_valid = FFALSE;
 
   return(TRUE);
 }
@@ -2319,7 +2319,7 @@
     k = 0;
     for(i = 1; i <= lp->rows; i++) {
       ii = lp->var_basic[i];
-      lp->is_basic[ii] = FALSE;
+      lp->is_basic[ii] = FFALSE;
       if(ii >= base) {
        /* Skip to next basis variable if this one is to be deleted */
         if(ii < base-delta) {
@@ -2362,7 +2362,7 @@
        basis and must create one (in most usage modes this should not happen,
        unless there is a bug) */
     if(k+delta < 0)
-      Ok = FALSE;
+      Ok = FFALSE;
     if(isrow || (k != lp->rows))
       set_action(&lp->spx_action, ACTION_REINVERT);
 
@@ -2664,10 +2664,10 @@
 
   }
 
-  shift_basis(lp, lp->rows+base, delta, usedmap, FALSE);
+  shift_basis(lp, lp->rows+base, delta, usedmap, FFALSE);
   if(SOS_count(lp) > 0)
-    SOS_shift_col(lp->SOS, 0, base, delta, usedmap, FALSE);
-  shift_rowcoldata(lp, lp->rows+base, delta, usedmap, FALSE);
+    SOS_shift_col(lp->SOS, 0, base, delta, usedmap, FFALSE);
+  shift_rowcoldata(lp, lp->rows+base, delta, usedmap, FFALSE);
   inc_columns(lp, delta);
 
   return( TRUE );
@@ -2729,7 +2729,7 @@
      !allocMYBOOL(lp, &lp->is_basic, rowcolsum, AUTOMATIC) ||
      !allocMYBOOL(lp, &lp->is_lower, rowcolsum, AUTOMATIC) ||
      ((lp->scalars != NULL) && !allocREAL(lp, &lp->scalars, rowcolsum, AUTOMATIC)))
-    return( FALSE );
+    return( FFALSE );
 
   /* Fill in default values, where appropriate */
   for(i = oldrowcolalloc+1; i < rowcolsum; i++) {
@@ -2737,7 +2737,7 @@
     lp->orig_upbo[i] = lp->upbo[i];
     lp->lowbo[i] = 0;
     lp->orig_lowbo[i] = lp->lowbo[i];
-    lp->is_basic[i] = FALSE;
+    lp->is_basic[i] = FFALSE;
     lp->is_lower[i] = TRUE;
   }
 
@@ -2765,7 +2765,7 @@
     if(!allocREAL(lp, &lp->lag_rhs, newsize+1, AUTOMATIC) ||
        !allocREAL(lp, &lp->lambda, newsize+1, AUTOMATIC) ||
        !allocINT(lp, &lp->lag_con_type, newsize+1, AUTOMATIC))
-      return( FALSE );
+      return( FFALSE );
 
     /* Reallocate the matrix (note that the row scalars are stored at index 0) */
     if(!ignoreMAT) {
@@ -2824,7 +2824,7 @@
        !allocLREAL(lp, &lp->rhs, rowsum, AUTOMATIC) ||
        !allocINT(lp, &lp->row_type, rowsum, AUTOMATIC) ||
        !allocINT(lp, &lp->var_basic, rowsum, AUTOMATIC))
-      return( FALSE );
+      return( FFALSE );
 
     if(oldrowsalloc == 0) {
       lp->var_basic[0] = AUTOMATIC; /*TRUE;*/  /* Indicates default basis */
@@ -2848,7 +2848,7 @@
         ht = copy_hash_table(lp->rowname_hashtab, lp->row_name, lp->rows_alloc + 1);
         if(ht == NULL) {
           lp->spx_status = NOMEMORY;
-          return( FALSE );
+          return( FFALSE );
         }
         free_hash_table(lp->rowname_hashtab);
         lp->rowname_hashtab = ht;
@@ -2858,7 +2858,7 @@
       lp->row_name = (hashelem **) realloc(lp->row_name, (rowsum) * sizeof(*lp->row_name));
       if(lp->row_name == NULL) {
         lp->spx_status = NOMEMORY;
-        return( FALSE );
+        return( FFALSE );
       }
       for(i = oldrowsalloc + 1; i < rowsum; i++)
         lp->row_name[i] = NULL;
@@ -2925,11 +2925,11 @@
        ((lp->var_priority != NULL) && !allocINT(lp, &lp->var_priority, colsum-1, AUTOMATIC)) ||
        ((lp->var_is_free != NULL) && !allocINT(lp, &lp->var_is_free, colsum, AUTOMATIC)) ||
        ((lp->bb_varbranch != NULL) && !allocMYBOOL(lp, &lp->bb_varbranch, colsum-1, AUTOMATIC)))
-      return( FALSE );
+      return( FFALSE );
 
     /* Make sure that Lagrangean constraints have the same number of columns */
     if(get_Lrows(lp) > 0)
-      inc_lag_space(lp, 0, FALSE);
+      inc_lag_space(lp, 0, FFALSE);
 
     /* Update column pointers */
     for(i = MIN(oldcolsalloc, lp->columns) + 1; i < colsum; i++) {
@@ -2952,7 +2952,7 @@
         lp->bb_varbranch[i] = BRANCH_DEFAULT;
     }
 
-    inc_rowcol_space(lp, deltacols, FALSE);
+    inc_rowcol_space(lp, deltacols, FFALSE);
 
   }
   return(TRUE);
@@ -2976,7 +2976,7 @@
   REAL   value;
 
   if(row == NULL)
-    return( FALSE );
+    return( FFALSE );
 
   else if(colno == NULL) {
     if(count <= 0)
@@ -3016,14 +3016,14 @@
   REAL   *arow;
   char   *p, *newp;
 
-  allocREAL(lp, &arow, lp->columns + 1, FALSE);
+  allocREAL(lp, &arow, lp->columns + 1, FFALSE);
   p = row_string;
   for(i = 1; i <= lp->columns; i++) {
     arow[i] = (REAL) strtod(p, &newp);
     if(p == newp) {
       report(lp, IMPORTANT, "str_set_obj_fn: Bad string %s\n", p);
       lp->spx_status = DATAIGNORED;
-      ret = FALSE;
+      ret = FFALSE;
       break;
     }
     else
@@ -3038,7 +3038,7 @@
 STATIC MYBOOL append_columns(lprec *lp, int deltacolumns)
 {
   if(!inc_col_space(lp, deltacolumns))
-    return( FALSE );
+    return( FFALSE );
   varmap_add(lp, lp->sum+1, deltacolumns);
   shift_coldata(lp, lp->columns+1, deltacolumns, NULL);
   return( TRUE );
@@ -3047,7 +3047,7 @@
 STATIC MYBOOL append_rows(lprec *lp, int deltarows)
 {
   if(!inc_row_space(lp, deltarows))
-    return( FALSE );
+    return( FFALSE );
   varmap_add(lp, lp->rows+1, deltarows);
   shift_rowdata(lp, lp->rows+1, deltarows, NULL);
 
@@ -3059,7 +3059,7 @@
   if((lp->solvecount == 0) && (turnon ^ lp->matA->is_roworder))
     return( mat_transpose(lp->matA) );
   else
-    return( FALSE );
+    return( FFALSE );
 }
 
 MYBOOL __WINAPI is_add_rowmode(lprec *lp)
@@ -3071,7 +3071,7 @@
 {
   if((rownr < 0) || (rownr > lp->rows)) {
     report(lp, IMPORTANT, "set_row: Row %d out of range\n", rownr);
-    return( FALSE );
+    return( FFALSE );
   }
   if(rownr == 0)
     return( set_obj_fn(lp, row) );
@@ -3083,7 +3083,7 @@
 {
   if((rownr < 0) || (rownr > lp->rows)) {
     report(lp, IMPORTANT, "set_rowex: Row %d out of range\n", rownr);
-    return( FALSE );
+    return( FFALSE );
   }
   if(rownr == 0)
     return( set_obj_fnex(lp, count, row, colno) );
@@ -3094,7 +3094,7 @@
 MYBOOL __WINAPI add_constraintex(lprec *lp, int count, REAL *row, int *colno, int constr_type, REAL rh)
 {
   int    n;
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
   if(!(constr_type == LE || constr_type == GE || constr_type == EQ)) {
     report(lp, IMPORTANT, "add_constraintex: Invalid %d constraint type\n", constr_type);
@@ -3155,9 +3155,9 @@
   int    i;
   char   *p, *newp;
   REAL   *aRow;
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
-  allocREAL(lp, &aRow, lp->columns + 1, FALSE);
+  allocREAL(lp, &aRow, lp->columns + 1, FFALSE);
   p = row_string;
 
   for(i = 1; i <= lp->columns; i++) {
@@ -3215,12 +3215,12 @@
     rownr = -rownr;
   if((rownr < 1) || (rownr > lp->rows)) {
     report(lp, IMPORTANT, "del_constraint: Attempt to delete non-existing constraint %d\n", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
   /*
   if(lp->matA->is_roworder) {
     report(lp, IMPORTANT, "del_constraint: Cannot delete constraint while in row entry mode.\n");
-    return(FALSE);
+    return(FFALSE);
   }
   */
 
@@ -3278,10 +3278,10 @@
     sign = -1;
   else {
     report(lp, IMPORTANT, "add_lag_con: Constraint type %d not implemented\n", con_type);
-    return(FALSE);
+    return(FFALSE);
   }
 
-  inc_lag_space(lp, 1, FALSE);
+  inc_lag_space(lp, 1, FFALSE);
 
   k = get_Lrows(lp);
   lp->lag_rhs[k] = rhs * sign;
@@ -3299,7 +3299,7 @@
   REAL   *a_row;
   char   *p, *new_p;
 
-  allocREAL(lp, &a_row, lp->columns + 1, FALSE);
+  allocREAL(lp, &a_row, lp->columns + 1, FFALSE);
   p = row_string;
 
   for(i = 1; i <= lp->columns; i++) {
@@ -3307,7 +3307,7 @@
     if(p == new_p) {
       report(lp, IMPORTANT, "str_add_lag_con: Bad string '%s'\n", p);
       lp->spx_status = DATAIGNORED;
-      ret = FALSE;
+      ret = FFALSE;
       break;
     }
     else
@@ -3376,7 +3376,7 @@
    NB! If the column has only one entry, this should be handled as
        a bound, but this currently is not the case  */
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
  /* Prepare and shift column vectors */
   if(!append_columns(lp, 1))
@@ -3418,7 +3418,7 @@
   REAL *aCol;
   char *p, *newp;
 
-  allocREAL(lp, &aCol, lp->rows + 1, FALSE);
+  allocREAL(lp, &aCol, lp->rows + 1, FFALSE);
   p = col_string;
 
   for(i = 0; i <= lp->rows; i++) {
@@ -3426,7 +3426,7 @@
     if(p == newp) {
       report(lp, IMPORTANT, "str_add_column: Bad string '%s'\n", p);
       lp->spx_status = DATAIGNORED;
-      ret = FALSE;
+      ret = FFALSE;
       break;
     }
     else
@@ -3507,12 +3507,12 @@
     colnr = -colnr;
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "del_column: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
   /*
   if(lp->matA->is_roworder) {
     report(lp, IMPORTANT, "del_column: Cannot delete column while in row entry mode.\n");
-    return(FALSE);
+    return(FFALSE);
   }
   */
 
@@ -3565,7 +3565,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_upbo: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
 #ifdef DoBorderRounding
@@ -3576,7 +3576,7 @@
   if(lp->tighten_on_set) {
     if(value < lp->orig_lowbo[lp->rows + colnr]) {
       report(lp, IMPORTANT, "set_upbo: Upperbound must be >= lowerbound\n");
-      return(FALSE);
+      return(FFALSE);
     }
     if(value < lp->orig_upbo[lp->rows + colnr]) {
       set_action(&lp->spx_action, ACTION_REBASE);
@@ -3613,7 +3613,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_lowbo: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
 #ifdef DoBorderRounding
@@ -3624,7 +3624,7 @@
   if(lp->tighten_on_set) {
     if(value > lp->orig_upbo[lp->rows + colnr]) {
       report(lp, IMPORTANT, "set_lowbo: Upper bound must be >= lower bound\n");
-      return(FALSE);
+      return(FFALSE);
     }
     if((value < 0) || (value > lp->orig_lowbo[lp->rows + colnr])) {
       set_action(&lp->spx_action, ACTION_REBASE);
@@ -3661,7 +3661,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_bounds: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
   if(fabs(upper - lower) < lp->epsvalue) {
     if(lower < 0)
@@ -3672,7 +3672,7 @@
   else if(lower > upper) {
     report(lp, IMPORTANT, "set_bounds: Column %d upper bound must be >= lower bound\n",
                           colnr);
-    return( FALSE );
+    return( FFALSE );
   }
 
   colnr += lp->rows;
@@ -3706,7 +3706,7 @@
 {
   if((column > lp->columns) || (column < 1)) {
     report(lp, IMPORTANT, "get_bounds: Column %d out of range", column);
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(lower != NULL)
@@ -3721,7 +3721,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_int: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   if((lp->var_type[colnr] & ISINTEGER) != 0) {
@@ -3741,7 +3741,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "is_int: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   return((lp->var_type[colnr] & ISINTEGER) != 0);
@@ -3751,7 +3751,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "is_SOS_var: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   return((lp->var_type[colnr] & ISSOS) != 0);
@@ -3798,7 +3798,7 @@
 #ifdef Paranoia
   if(count < 0) {
     report(lp, IMPORTANT, "add_GUB: Invalid GUB member count %d\n", count);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -3816,7 +3816,7 @@
 
 MYBOOL __WINAPI set_binary(lprec *lp, int colnr, MYBOOL must_be_bin)
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_binary: Column %d out of range\n", colnr);
@@ -3833,7 +3833,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "is_binary: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   return((MYBOOL) (((lp->var_type[colnr] & ISINTEGER) != 0) &&
@@ -3845,7 +3845,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_unbounded: Column %d out of range\n", colnr);
-    return( FALSE );
+    return( FFALSE );
   }
 
   return( set_bounds(lp, colnr, -lp->infinite, lp->infinite) );
@@ -3857,7 +3857,7 @@
 
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "is_unbounded: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   test = is_splitvar(lp, colnr);
@@ -3873,7 +3873,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "is_negative: Column %d out of range\n", colnr);
-    return( FALSE );
+    return( FFALSE );
   }
 
   colnr += lp->rows;
@@ -3888,11 +3888,11 @@
   }
   if(weights != NULL) {
     int n;
-    allocINT(lp, &lp->var_priority, lp->columns_alloc, FALSE);
+    allocINT(lp, &lp->var_priority, lp->columns_alloc, FFALSE);
     for(n = 0; n < lp->columns; n++) {
       lp->var_priority[n] = n+1;
     }
-    n = sortByREAL(lp->var_priority, weights, lp->columns, 0, FALSE);
+    n = sortByREAL(lp->var_priority, weights, lp->columns, 0, FFALSE);
   }
   return(TRUE);
 }
@@ -3900,7 +3900,7 @@
 MYBOOL __WINAPI set_var_priority(lprec *lp)
 /* Experimental automatic variable ordering/priority setting */
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
   if(is_bb_mode(lp, NODE_AUTOORDER) &&
      (lp->var_priority == NULL) &&
@@ -3909,7 +3909,7 @@
     REAL *rcost = NULL;
     int  i, j, *colorder = NULL;
 
-    allocINT(lp, &colorder, lp->columns+1, FALSE);
+    allocINT(lp, &colorder, lp->columns+1, FFALSE);
 
     /* Create an "optimal" B&B variable ordering; this MDO-based routine
        returns column indeces in an increasing order of co-dependency.
@@ -3919,10 +3919,10 @@
     colorder[0] = lp->columns;
     for(j = 1; j <= lp->columns; j++)
       colorder[j] = lp->rows+j;
-    i = getMDO(lp, NULL, colorder, NULL, FALSE);
+    i = getMDO(lp, NULL, colorder, NULL, FFALSE);
 
     /* Map to variable weight */
-    allocREAL(lp, &rcost, lp->columns+1, FALSE);
+    allocREAL(lp, &rcost, lp->columns+1, FFALSE);
     for(j = lp->columns; j > 0; j--) {
       i = colorder[j]-lp->rows;
       rcost[i] = -j;
@@ -3943,7 +3943,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "get_var_priority: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(lp->var_priority == NULL)
@@ -3956,7 +3956,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "set_semicont: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(lp->sc_lobound[colnr] != 0) {
@@ -3975,7 +3975,7 @@
 {
   if((colnr > lp->columns) || (colnr < 1)) {
     report(lp, IMPORTANT, "is_semicont: Column %d out of range\n", colnr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   return((lp->var_type[colnr] & ISSEMI) != 0);
@@ -3985,7 +3985,7 @@
 {
   if((rownr > lp->rows) || (rownr < 0)) {
     report(lp, IMPORTANT, "set_rh: Row %d out of range\n", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(((rownr == 0) && (!is_maxim(lp))) ||
@@ -4061,7 +4061,7 @@
 {
   if(rownr > lp->rows || rownr < 1) {
     report(lp, IMPORTANT, "set_rh_upper: Row %d out of range", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
 
  /* First scale the value */
@@ -4077,7 +4077,7 @@
       if(value + lp->orig_rhs[rownr] < 0) {
         report(lp, SEVERE, "set_rh_upper: Invalid negative range in row %d\n",
                            rownr);
-        return(FALSE);
+        return(FFALSE);
       }
 #endif
 #ifdef DoBorderRounding
@@ -4106,7 +4106,7 @@
 {
   if(rownr > lp->rows || rownr < 1) {
     report(lp, IMPORTANT, "set_rh_lower: Row %d out of range", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
 
  /* First scale the value */
@@ -4122,7 +4122,7 @@
       if(lp->orig_rhs[rownr] - value < 0) {
         report(lp, SEVERE, "set_rh_lower: Invalid negative range in row %d\n",
                            rownr);
-        return(FALSE);
+        return(FFALSE);
       }
 #endif
 #ifdef DoBorderRounding
@@ -4152,7 +4152,7 @@
 {
   if((rownr > lp->rows) || (rownr < 1)) {
     report(lp, IMPORTANT, "set_rh_range: Row %d out of range", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   deltavalue = scaled_value(lp, deltavalue, rownr);
@@ -4189,7 +4189,7 @@
 {
   if((rownr > lp->rows) || (rownr < 0)) {
     report(lp, IMPORTANT, "get_rh_range: row %d out of range\n", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   if(lp->orig_upbo[rownr] >= lp->infinite)
@@ -4228,7 +4228,7 @@
     if(p == newp) {
       report(lp, IMPORTANT, "str_set_rh_vec: Bad string %s\n", p);
       lp->spx_status = DATAIGNORED;
-      ret = FALSE;
+      ret = FFALSE;
       break;
     }
     else
@@ -4242,7 +4242,7 @@
 
 void __WINAPI set_sense(lprec *lp, MYBOOL maximize)
 {
-  maximize = (MYBOOL) (maximize != FALSE);
+  maximize = (MYBOOL) (maximize != FFALSE);
   if(is_maxim(lp) != maximize) {
     int i;
     if(is_infinite(lp, lp->bb_heuristicOF))
@@ -4267,7 +4267,7 @@
 
 void __WINAPI set_minim(lprec *lp)
 {
-  set_sense(lp, FALSE);
+  set_sense(lp, FFALSE);
 }
 
 MYBOOL __WINAPI is_maxim(lprec *lp)
@@ -4282,12 +4282,12 @@
 
   if(rownr > lp->rows+1 || rownr < 1) {
     report(lp, IMPORTANT, "set_constr_type: Row %d out of range\n", rownr);
-    return( FALSE );
+    return( FFALSE );
   }
 
   /* Prepare for a new row */
   if((rownr > lp->rows) && !append_rows(lp, rownr-lp->rows))
-    return( FALSE );
+    return( FFALSE );
 
   /* Update the constraint type data */
   if(is_constr_type(lp, rownr, EQ))
@@ -4302,7 +4302,7 @@
   else {
     report(lp, IMPORTANT, "set_constr_type: Constraint type %d not implemented (row %d)\n",
                           con_type, rownr);
-    return( FALSE );
+    return( FFALSE );
   }
 
   /* Change the signs of the row, if necessary */
@@ -4315,7 +4315,7 @@
     MATrec *mat = lp->matA;
 
     if(mat->is_roworder)
-      mat_multcol(mat, rownr, -1, FALSE);
+      mat_multcol(mat, rownr, -1, FFALSE);
     else
       mat_multrow(mat, rownr, -1);
     if(lp->orig_rhs[rownr] != 0)
@@ -4326,7 +4326,7 @@
       lp->orig_rhs[rownr] = lp->infinite;
 
   set_action(&lp->spx_action, ACTION_REINVERT);
-  lp->basis_valid = FALSE;
+  lp->basis_valid = FFALSE;
 
   return( TRUE );
 }
@@ -4340,7 +4340,7 @@
 {
   if((rownr < 0) || (rownr > lp->rows)) {
     report(lp, IMPORTANT, "is_constr_type: Row %d out of range\n", rownr);
-    return( FALSE );
+    return( FFALSE );
   }
   return( (MYBOOL) ((lp->row_type[rownr] & ROWTYPE_CONSTRAINT) == mask));
 }
@@ -4590,7 +4590,7 @@
     }
   }
   else {
-    MYBOOL chsign = FALSE;
+    MYBOOL chsign = FFALSE;
     int    ie, i;
     MATrec *mat = lp->matA;
 
@@ -4616,7 +4616,7 @@
       chsign = is_chsign(lp, rownr);
     for(; i < ie; i++) {
       j = ROW_MAT_COLNR(i);
-      a = get_mat_byindex(lp, i, TRUE, FALSE);
+      a = get_mat_byindex(lp, i, TRUE, FFALSE);
       if(lp->matA->is_roworder)
         chsign = is_chsign(lp, j);
       a = my_chsign(chsign, a);
@@ -4732,13 +4732,13 @@
 #ifndef Phase1EliminateRedundant
     if(lp->P1extraDim < 0) {
       if(index > lp->sum + lp->P1extraDim)
-        accept = FALSE;
+        accept = FFALSE;
     }
     else
 #endif
     if((index <= lp->sum - lp->P1extraDim) || (mult == 0)) {
       if((mult == 0) || (lp->bigM == 0))
-        accept = FALSE;
+        accept = FFALSE;
       else
         (*ofValue) /= lp->bigM;
     }
@@ -4766,7 +4766,7 @@
     (*ofValue) *= mult;
     if(fabs(*ofValue) < lp->epsmachine) {
       (*ofValue) = 0;
-      accept = FALSE;
+      accept = FFALSE;
     }
   }
   else
@@ -5212,7 +5212,7 @@
 MYBOOL __WINAPI is_nativeBFP(lprec *lp)
 {
 #ifdef ExcludeNativeInverse
-  return( FALSE );
+  return( FFALSE );
 #elif LoadInverseLib == TRUE
   return( (MYBOOL) (lp->hBFP == NULL) );
 #else
@@ -5242,7 +5242,7 @@
 
   if(filename == NULL) {
     if(!is_nativeBFP(lp))
-      return( FALSE );
+      return( FFALSE );
 #ifndef ExcludeNativeInverse
     lp->bfp_name = bfp_name;
     lp->bfp_compatible = bfp_compatible;
@@ -5566,7 +5566,7 @@
 MYBOOL __WINAPI is_nativeXLI(lprec *lp)
 {
 #ifdef ExcludeNativeLanguage
-  return( FALSE );
+  return( FFALSE );
 #elif LoadLanguageLib == TRUE
   return( (MYBOOL) (lp->hXLI == NULL) );
 #else
@@ -5592,7 +5592,7 @@
 
   if(filename == NULL) {
     if(!is_nativeXLI(lp))
-      return( FALSE );
+      return( FFALSE );
 #ifndef ExcludeNativeLanguage
     lp->xli_name = xli_name;
     lp->xli_compatible = xli_compatible;
@@ -5798,7 +5798,7 @@
     ;
   else if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_primal_solution: Not a valid basis");
-    return(FALSE);
+    return(FFALSE);
   }
 
   MEMCOPY(pv, lp->best_solution, lp->sum + 1);
@@ -5818,7 +5818,7 @@
 
   if(!lp->basis_valid) {
     report(lp, CRITICAL, "get_dual_solution: Not a valid basis");
-    return(FALSE);
+    return(FFALSE);
   }
 
   ret = get_ptr_sensitivity_rhs(lp, &duals, NULL, NULL);
@@ -5853,7 +5853,7 @@
 {
   if(!lp->basis_valid || (get_Lrows(lp) == 0)) {
     report(lp, CRITICAL, "get_lambda: Not a valid basis");
-    return(FALSE);
+    return(FFALSE);
   }
 
   MEMCOPY(lambda, lp->lambda+1, get_Lrows(lp));
@@ -5898,7 +5898,7 @@
     if(values[i - lp->rows] < unscaled_value(lp, lp->orig_lowbo[i], i)
        || values[i - lp->rows] > unscaled_value(lp, lp->orig_upbo[i], i)) {
       if(!((lp->sc_lobound[i - lp->rows]>0) && (values[i - lp->rows]==0)))
-        return(FALSE);
+        return(FFALSE);
     }
   }
 
@@ -5918,10 +5918,10 @@
     my_roundzero(dist, threshold);
     if((lp->orig_upbo[i] == 0 && dist != 0) ||( dist < 0)) {
       FREE(this_rhs);
-      return(FALSE);
+      return(FFALSE);
     }
   }
-  mempool_releaseVector(lp->workarrays, (char *) this_rhs, FALSE);
+  mempool_releaseVector(lp->workarrays, (char *) this_rhs, FFALSE);
 /*  FREE(this_rhs); */
   return(TRUE);
 }
@@ -6034,24 +6034,24 @@
 int __WINAPI get_nameindex(lprec *lp, char *varname, MYBOOL isrow)
 {
   if(isrow)
-    return( find_row(lp, varname, FALSE) );
+    return( find_row(lp, varname, FFALSE) );
   else
-    return( find_var(lp, varname, FALSE) );
+    return( find_var(lp, varname, FFALSE) );
 }
 
 MYBOOL __WINAPI set_row_name(lprec *lp, int rownr, char *new_name)
 {
   if((rownr < 0) || (rownr > lp->rows+1)) {
     report(lp, IMPORTANT, "set_row_name: Row %d out of range", rownr);
-    return(FALSE);
+    return(FFALSE);
   }
 
   /* Prepare for a new row */
   if((rownr > lp->rows) && !append_rows(lp, rownr-lp->rows))
-    return( FALSE );
+    return( FFALSE );
   if(!lp->names_used) {
     if(!init_rowcol_names(lp))
-      return(FALSE);
+      return(FFALSE);
   }
   rename_var(lp, rownr, new_name, lp->row_name, &lp->rowname_hashtab);
 
@@ -6100,7 +6100,7 @@
   }
   else {
     if(lp->rowcol_name == NULL)
-      if (!allocCHAR(lp, &lp->rowcol_name, 20, FALSE))
+      if (!allocCHAR(lp, &lp->rowcol_name, 20, FFALSE))
         return(NULL);
     ptr = lp->rowcol_name;
     if(newrow)
@@ -6118,7 +6118,7 @@
   }
 
   if((colnr > lp->columns) && !append_columns(lp, colnr-lp->columns))
-    return(FALSE);
+    return(FFALSE);
 
   if(!lp->names_used)
     init_rowcol_names(lp);
@@ -6168,7 +6168,7 @@
   }
   else {
     if(lp->rowcol_name == NULL)
-      if (!allocCHAR(lp, &lp->rowcol_name, 20, FALSE))
+      if (!allocCHAR(lp, &lp->rowcol_name, 20, FFALSE))
         return(NULL);
     ptr = lp->rowcol_name;
     if(newcol)
@@ -6320,14 +6320,14 @@
 
   /* Define variable target list and compute the reduced costs */
   coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->columns+1, sizeof(*coltarget));
-  if(!get_colIndexA(lp, target, coltarget, FALSE)) {
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
-    return(FALSE);
+  if(!get_colIndexA(lp, target, coltarget, FFALSE)) {
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
+    return(FFALSE);
   }
   bsolve(lp, 0, *duals, NULL, lp->epsmachine*DOUBLEROUND, 1.0);
   prod_xA(lp, coltarget, *duals, NULL, lp->epsmachine, 1.0,
                          *duals, *nzduals, MAT_ROUNDDEFAULT | MAT_ROUNDRC);
-  mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+  mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
 
   /* Compute sum or maximum infeasibility as specified */
   for(i = 1; i <= (*nzduals)[0]; i++) {
@@ -6465,7 +6465,7 @@
         if(rownr == 0)
           *pivcolval = unscaled_mat(lp, lp->orig_obj[jb], 0, jb);
         else
-          *pivcolval = get_mat_byindex(lp, jb, TRUE, FALSE);
+          *pivcolval = get_mat_byindex(lp, jb, TRUE, FFALSE);
         continue;
       }
       if(!is_int(lp, jj))
@@ -6478,7 +6478,7 @@
       if(rownr == 0)
         rowval = unscaled_mat(lp, lp->orig_obj[jb], 0, jb);
       else
-        rowval = get_mat_byindex(lp, jb, TRUE, FALSE);
+        rowval = get_mat_byindex(lp, jb, TRUE, FFALSE);
       if(rowval > 0)
         (*plucount)++;
 
@@ -6740,11 +6740,11 @@
       if(rownr == 0)
         rowval = unscaled_mat(lp, obj_orig[jj], 0, jj);
       else
-        rowval = get_mat_byindex(lp, j, TRUE, FALSE);
+        rowval = get_mat_byindex(lp, j, TRUE, FFALSE);
 
       /* Allocate array of coefficients to be sorted */
       if(n == 0)
-        allocREAL(lp, &obj_sort, je-jb, FALSE);
+        allocREAL(lp, &obj_sort, je-jb, FFALSE);
 
       obj_sort[n++] = rowval;
     }
@@ -6767,7 +6767,7 @@
       while(n > 0) {
 
         /* Sort the coefficients in ascending order */
-        qsortex(obj_sort, n, 0, sizeof(*obj_sort), FALSE, compareREAL, NULL, 0);
+        qsortex(obj_sort, n, 0, sizeof(*obj_sort), FFALSE, compareREAL, NULL, 0);
 
         /* Eliminate array duplicates (could consider applying an eps) */
         j = 0; jb = 1;
@@ -6925,7 +6925,7 @@
      (fabs(lp->upbo[varindex]-lp->rhs[basisvar]) < lp->epsprimal))
     return( TRUE );
   else
-    return( FALSE );
+    return( FFALSE );
 }
 
 STATIC int findBasicFixedvar(lprec *lp, int afternr, MYBOOL slacksonly)
@@ -6958,15 +6958,15 @@
   int    col;
   REAL   x;
   MYBOOL Ok = TRUE;
-  MYBOOL doSC = FALSE;
+  MYBOOL doSC = FFALSE;
 
   col = lp->var_basic[basis_row];
   x = lp->rhs[basis_row];         /* The current solution of basic variables stored here! */
   if((x < -tol) || (x > lp->upbo[col]+tol))
-    Ok = FALSE;
+    Ok = FFALSE;
   else if(doSC && (col > lp->rows) && (fabs(lp->sc_lobound[col - lp->rows]) > 0)) {
     if((x > tol) && (x < fabs(lp->sc_lobound[col - lp->rows])-tol))
-      Ok = FALSE;
+      Ok = FFALSE;
   }
   return( Ok );
 }
@@ -6993,7 +6993,7 @@
     feasible = TRUE;
 /*    if(((*rhsptr) < lp->lowbo[*idxptr]-tol) || ((*rhsptr) > lp->upbo[*idxptr]+tol)) */
     if(((*rhsptr) < -tol) || ((*rhsptr) > lp->upbo[*idxptr]+tol))
-      feasible = FALSE;
+      feasible = FFALSE;
 #endif
     if(!feasible) {
       if(infeasibles == NULL)
@@ -7008,7 +7008,7 @@
     if(feasible)
       *feasibilitygap = 0.0;
     else
-      *feasibilitygap = feasibilityOffset(lp, FALSE);
+      *feasibilitygap = feasibilityOffset(lp, FFALSE);
   }
 
   return(feasible);
@@ -7033,7 +7033,7 @@
     int  *nzdcol = NULL;
     REAL d, *dcol = NULL;
 
-    f = compute_dualslacks(lp, target, &dcol, &nzdcol, FALSE);
+    f = compute_dualslacks(lp, target, &dcol, &nzdcol, FFALSE);
     if(nzdcol != NULL)
     for(i = 1; i <= nzdcol[0]; i++) {
       varnr = nzdcol[i];
@@ -7073,7 +7073,7 @@
     }
   }
   else
-    f = compute_dualslacks(lp, target, NULL, NULL, FALSE);
+    f = compute_dualslacks(lp, target, NULL, NULL, FFALSE);
 /*    f = feasibilityOffset(lp, TRUE); */  /* Safe legacy mode */
 
   /* Do an extra scan to see if there are bounded variables in the OF not present in any constraint;
@@ -7125,7 +7125,7 @@
   /* Set user variables at their lower bound, including the
      dummy slack for the objective "constraint" */
   for(; i <= lp->sum; i++) {
-    lp->is_basic[i] = FALSE;
+    lp->is_basic[i] = FFALSE;
     lp->is_lower[i] = TRUE;
   }
   lp->is_lower[0] = TRUE;
@@ -7151,7 +7151,7 @@
   /* Make sure we are consistent */
   if(lp->wasPresolved && ((lp->rows != lp->presolve_undo->orig_rows) ||
                           (lp->columns != lp->presolve_undo->orig_columns)))
-    return( FALSE );
+    return( FFALSE );
 
  /* Initialize (lp->is_basic is set in preprocess); Note that as of v5 and before
     it is an lp_solve convention that basic variables are at their lower bounds!
@@ -7160,10 +7160,10 @@
   lp->is_lower[0] = TRUE;
   for(i = 1; i <= lp->sum; i++) {
     lp->is_lower[i] = TRUE;
-    lp->is_basic[i] = FALSE;
+    lp->is_basic[i] = FFALSE;
   }
   for(i = 1; i <= lp->rows; i++)
-    lp->var_basic[i] = FALSE;
+    lp->var_basic[i] = FFALSE;
 
  /* Set basic and optionally non-basic variables;
     negative index means at lower bound, positive at upper bound */
@@ -7175,29 +7175,29 @@
     s = bascolumn[i];
     k = abs(s);
     if(k <= 0 || k > lp->sum)
-      return( FALSE );
+      return( FFALSE );
     if(i <= lp->rows) {
       lp->var_basic[i] = k;
       lp->is_basic[k] = TRUE;
     }
     else     /* Remove this test if basic variables can be upper-bounded */
     if(s > 0)
-      lp->is_lower[k] = FALSE;
+      lp->is_lower[k] = FFALSE;
   }
   if(!verify_basis(lp))
-    return( FALSE );
+    return( FFALSE );
 
  /* Invalidate basis */
   set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);
   lp->basis_valid = TRUE;   /* Do not re-initialize basis on entering Solve */
-  lp->var_basic[0] = FALSE; /* Set to signal that this is a non-default basis */
+  lp->var_basic[0] = FFALSE; /* Set to signal that this is a non-default basis */
 
   return( TRUE );
 }
 
 void __WINAPI reset_basis(lprec *lp)
 {
-  lp->basis_valid = FALSE;   /* Causes reinversion at next opportunity */
+  lp->basis_valid = FFALSE;   /* Causes reinversion at next opportunity */
 }
 
 MYBOOL __WINAPI get_basis(lprec *lp, int *bascolumn, MYBOOL nonbasic)
@@ -7207,7 +7207,7 @@
   if(!lp->basis_valid ||
      (lp->rows != lp->presolve_undo->orig_rows) ||
      (lp->columns != lp->presolve_undo->orig_columns))
-    return( FALSE );
+    return( FFALSE );
 
   *bascolumn = 0;
 
@@ -7262,7 +7262,7 @@
 STATIC MYBOOL verify_basis(lprec *lp)
 {
   int    i, ii, k = 0;
-  MYBOOL result = FALSE;
+  MYBOOL result = FFALSE;
 
   for(i = 1; i <= lp->rows; i++) {
     ii = lp->var_basic[i];
@@ -7315,9 +7315,9 @@
                            enteringCol, (double) get_total_iter(lp));
 #endif
 
-  lp->var_basic[0]          = FALSE;       /* Set to signal that this is a non-default basis */
+  lp->var_basic[0]          = FFALSE;       /* Set to signal that this is a non-default basis */
   lp->var_basic[basisPos]   = enteringCol;
-  lp->is_basic[leavingCol]  = FALSE;
+  lp->is_basic[leavingCol]  = FFALSE;
   lp->is_basic[enteringCol] = TRUE;
   if(lp->bb_basis != NULL)
     lp->bb_basis->pivots++;
@@ -7397,7 +7397,7 @@
     if((lowbo != NULL) && (lowbo != lp->lowbo))
       MEMCOPY(lp->lowbo, lowbo, lp->sum + 1);
     if(lp->bb_bounds != NULL)
-      lp->bb_bounds->UBzerobased = FALSE;
+      lp->bb_bounds->UBzerobased = FFALSE;
     set_action(&lp->spx_action, ACTION_REBASE);
   }
   set_action(&lp->spx_action, ACTION_RECOMPUTE);
@@ -7442,14 +7442,14 @@
   newbasis = (basisrec *) calloc(sizeof(*newbasis), 1);
   if((newbasis != NULL) &&
 #if LowerStorageModel == 0
-    allocMYBOOL(lp, &newbasis->is_lower,  sum,  FALSE) &&
+    allocMYBOOL(lp, &newbasis->is_lower,  sum,  FFALSE) &&
 #else
     allocMYBOOL(lp, &newbasis->is_lower,  (sum + 8) / 8,  TRUE) &&
 #endif
 #if BasisStorageModel == 0
-    allocMYBOOL(lp, &newbasis->is_basic,  sum,  FALSE) &&
+    allocMYBOOL(lp, &newbasis->is_basic,  sum,  FFALSE) &&
 #endif
-    allocINT(lp,    &newbasis->var_basic, lp->rows + 1, FALSE)) {
+    allocINT(lp,    &newbasis->var_basic, lp->rows + 1, FFALSE)) {
 
     if(islower == NULL)
       islower = lp->is_lower;
@@ -7489,7 +7489,7 @@
   MYBOOL same_basis = TRUE;
 
   if(lp->bb_basis == NULL)
-    return( FALSE );
+    return( FFALSE );
 
   /* Loop over basis variables until a mismatch (order can be different) */
   i = 1;
@@ -7744,7 +7744,7 @@
                          i, k);
 #endif
     j = lp->rows + i;
-    if(!SOS_is_marked(lp->SOS, 0, i) && !SOS_is_full(lp->SOS, 0, i, FALSE)) {
+    if(!SOS_is_marked(lp->SOS, 0, i) && !SOS_is_full(lp->SOS, 0, i, FFALSE)) {
 /*    if(!SOS_is_marked(lp->SOS, 0, i) && !SOS_is_full(lp->SOS, 0, i, TRUE)) { */
       if(!intsos || is_int(lp, i)) {
         (*count)++;
@@ -7788,16 +7788,16 @@
   depthfirstmode = is_bb_mode(lp, NODE_DEPTHFIRSTMODE);
   breadthfirstmode = is_bb_mode(lp, NODE_BREADTHFIRSTMODE) &&
                      (MYBOOL) (lp->bb_level <= lp->int_vars);
-  rcostmode      = (MYBOOL) /* FALSE */ (BB->lp->solutioncount > 0) && is_bb_mode(lp, NODE_RCOSTFIXING) ; /* 5/2/08 peno disabled NODE_RCOSTFIXING because it results in non-optimal solutions with some models */ /* 15/2/8 peno enabled NODE_RCOSTFIXING again because a fix is found. See lp_simplex.c NODE__RCOSTFIXING fix */
+  rcostmode      = (MYBOOL) /* FFALSE */ (BB->lp->solutioncount > 0) && is_bb_mode(lp, NODE_RCOSTFIXING) ; /* 5/2/08 peno disabled NODE_RCOSTFIXING because it results in non-optimal solutions with some models */ /* 15/2/8 peno enabled NODE_RCOSTFIXING again because a fix is found. See lp_simplex.c NODE__RCOSTFIXING fix */
   pseudocostmode = is_bb_mode(lp, NODE_PSEUDOCOSTMODE);
   pseudocostsel  = is_bb_rule(lp, NODE_PSEUDOCOSTSELECT) ||
                    is_bb_rule(lp, NODE_PSEUDONONINTSELECT) ||
                    is_bb_rule(lp, NODE_PSEUDORATIOSELECT);
-  pseudostrong   = FALSE &&
+  pseudostrong   = FFALSE &&
                    pseudocostsel && !rcostmode && is_bb_mode(lp, NODE_STRONGINIT);
 
   /* Fill list of non-ints */
-  allocINT(lp, &nonint, lp->columns + 1, FALSE);
+  allocINT(lp, &nonint, lp->columns + 1, FFALSE);
   n = 0;
   depthmax = -1;
   if(isfeasible != NULL)
@@ -7820,7 +7820,7 @@
     }
     else {
 
-      valINT = solution_is_int(lp, i, FALSE);
+      valINT = solution_is_int(lp, i, FFALSE);
 
       /* Skip already fixed variables */
       if(lowbo[i] == upbo[i]) {
@@ -7871,7 +7871,7 @@
     for(i = 1; (i <= lp->rows) && (BB->lastrcf == 0); i++) {
       /* Skip already fixed slacks (equalities) */
       if(lowbo[i] < upbo[i]) {
-        bestvar = rcfbound_BB(BB, i, FALSE, NULL, isfeasible);
+        bestvar = rcfbound_BB(BB, i, FFALSE, NULL, isfeasible);
         if(bestvar != FR)
           BB->lastrcf++;
       }
@@ -7893,7 +7893,7 @@
     int *depths = NULL;
 
     /* Fill attribute array and make sure ordinal order breaks ties during sort */
-    allocINT(lp, &depths, n + 1, FALSE);
+    allocINT(lp, &depths, n + 1, FFALSE);
     for(i = 1; i <= n; i++)
       depths[i] = (depthfirstmode ? n+1-i : i) + (n+1)*lp->bb_varactive[nonint[i]];
     hpsortex(depths, n, 1, sizeof(*nonint), depthfirstmode, compareINT, nonint);
@@ -8076,7 +8076,7 @@
   int i;
 
   if((lp->bb_PseudoCost == NULL) || ((clower == NULL) && (cupper == NULL)))
-    return(FALSE);
+    return(FFALSE);
   for(i = 1; i <= lp->columns; i++) {
     if(clower != NULL)
       lp->bb_PseudoCost->LOcost[i].value = clower[i];
@@ -8093,7 +8093,7 @@
   int i;
 
   if((lp->bb_PseudoCost == NULL) || ((clower == NULL) && (cupper == NULL)))
-    return(FALSE);
+    return(FFALSE);
   for(i = 1; i <= lp->columns; i++) {
     if(clower != NULL)
       clower[i] = lp->bb_PseudoCost->LOcost[i].value;
@@ -8296,9 +8296,9 @@
 {
   int    varout;
   REAL   pivot, epsmargin, leavingValue, leavingUB, enteringUB;
-  MYBOOL leavingToUB = FALSE, enteringFromUB, enteringIsFixed, leavingIsFixed;
+  MYBOOL leavingToUB = FFALSE, enteringFromUB, enteringIsFixed, leavingIsFixed;
   MYBOOL *islower = &(lp->is_lower[varin]);
-  MYBOOL minitNow = FALSE, minitStatus = ITERATE_MAJORMAJOR;
+  MYBOOL minitNow = FFALSE, minitStatus = ITERATE_MAJORMAJOR;
   LREAL  deltatheta = theta;
 
   if(userabort(lp, MSG_ITERATION))
@@ -8309,7 +8309,7 @@
     if (lp->spx_trace)
       report(lp, IMPORTANT, "performiteration: Numeric instability encountered!\n");
     lp->spx_status = NUMFAILURE;
-    return( FALSE );
+    return( FFALSE );
   }
 #endif
   varout = lp->var_basic[rownr];
@@ -8453,7 +8453,7 @@
                        lp->rhs[0], (double) get_total_iter(lp));
 
 #if 0
-  if(verify_solution(lp, FALSE, my_if(minitNow, "MINOR", "MAJOR")) >= 0) {
+  if(verify_solution(lp, FFALSE, my_if(minitNow, "MINOR", "MAJOR")) >= 0) {
     if(minitNow)
       pivot = get_obj_active(lp, varin);
     else
@@ -8562,7 +8562,7 @@
     else
       return(TRUE);
   }
-  return(FALSE);
+  return(FFALSE);
 #endif
 } /* solution_is_int */
 
@@ -8760,7 +8760,7 @@
     case OF_DUALLIMIT: refvalue = lp->bb_limitOF;
                        break;
     default         :  report(lp, SEVERE, "bb_better: Passed invalid test target '%d'\n", target);
-                       return( FALSE );
+                       return( FFALSE );
   }
 
   /* Adjust the test value for the desired acceptability window */
@@ -8968,7 +8968,7 @@
 
  /* Find the signed sums and the largest absolute product in the matrix (exclude the OF for speed) */
 #ifdef UseMaxValueInCheck
-  allocREAL(lp, &maxvalue, lp->rows + 1, FALSE);
+  allocREAL(lp, &maxvalue, lp->rows + 1, FFALSE);
   for(i = 0; i <= lp->rows; i++)
     maxvalue[i] = fabs(get_rh(lp, i));
 #elif !defined RelativeAccuracyCheck
@@ -9280,18 +9280,18 @@
   if(is_action(lp->spx_action, ACTION_REBASE) ||
      is_action(lp->spx_action, ACTION_REINVERT) || (!lp->basis_valid) ||
      !allocREAL(lp, &(lp->duals), lp->sum + 1, AUTOMATIC))
-    return(FALSE);
+    return(FFALSE);
 
   /* Initialize */
   coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->columns+1, sizeof(*coltarget));
-  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
-    return(FALSE);
+  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FFALSE)) {
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
+    return(FFALSE);
   }
   bsolve(lp, 0, lp->duals, NULL, lp->epsmachine*DOUBLEROUND, 1.0);
   prod_xA(lp, coltarget, lp->duals, NULL, lp->epsmachine, 1.0,
                          lp->duals, NULL, MAT_ROUNDDEFAULT | MAT_ROUNDRC);
-  mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+  mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
 
 
   /* The (Lagrangean) dual values are the reduced costs of the primal slacks;
@@ -9329,7 +9329,7 @@
 #endif
       lp->full_duals[i] = lp->duals[ix];
     }
-    presolve_rebuildUndo(lp, FALSE);
+    presolve_rebuildUndo(lp, FFALSE);
   }
 
   /* Calculate the dual OF and do scaling adjustments to the duals */
@@ -9384,7 +9384,7 @@
     FREE(lp->objfromvalue);
     FREE(lp->dualsfrom);
     FREE(lp->dualstill);
-    ok = FALSE;
+    ok = FFALSE;
   }
   else {
     infinite=lp->infinite;
@@ -9394,8 +9394,8 @@
       till=infinite;
       objfromvalue=infinite;
       if (!lp->is_basic[varnr]) {
-        if (!fsolve(lp, varnr, pcol, workINT, epsvalue, 1.0, FALSE)) {  /* construct one column of the tableau */
-          ok = FALSE;
+        if (!fsolve(lp, varnr, pcol, workINT, epsvalue, 1.0, FFALSE)) {  /* construct one column of the tableau */
+          ok = FFALSE;
           break;
         }
         /* Search for the rows(s) which first result in further iterations */
@@ -9470,7 +9470,7 @@
   FREE(lp->objfrom);
   FREE(lp->objtill);
   if(!allocREAL(lp, &drow, lp->sum + 1, TRUE) ||
-     !allocREAL(lp, &OrigObj, lp->columns + 1, FALSE) ||
+     !allocREAL(lp, &OrigObj, lp->columns + 1, FFALSE) ||
      !allocREAL(lp, &prow, lp->sum + 1, TRUE) ||
      !allocREAL(lp, &lp->objfrom, lp->columns + 1, AUTOMATIC) ||
      !allocREAL(lp, &lp->objtill, lp->columns + 1, AUTOMATIC)) {
@@ -9480,7 +9480,7 @@
     FREE(prow);
     FREE(lp->objfrom);
     FREE(lp->objtill);
-    ok = FALSE;
+    ok = FFALSE;
   }
   else {
     int *coltarget;
@@ -9489,8 +9489,8 @@
     epsvalue=lp->epsmachine;
 
     coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->columns+1, sizeof(*coltarget));
-    if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {
-      mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+    if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FFALSE)) {
+      mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
       goto Abandon;
     }
     bsolve(lp, 0, drow, NULL, epsvalue*DOUBLEROUND, 1.0);
@@ -9510,7 +9510,7 @@
           a = -a;
         if ((!sensrejvar) && (lp->upbo[varnr] == 0.0))
           /* ignore, because this case doesn't results in further iterations */ ;
-        else if(((lp->is_lower[varnr] != 0) == (is_maxim(lp) == FALSE)) && (a > -epsvalue))
+        else if(((lp->is_lower[varnr] != 0) == (is_maxim(lp) == FFALSE)) && (a > -epsvalue))
           from = OrigObj[i] - a; /* less than this value gives further iterations */
         else
           till = OrigObj[i] - a; /* bigger than this value gives further iterations */
@@ -9542,7 +9542,7 @@
                   min2 = a;
               }
             }
-          if ((lp->is_lower[varnr] == 0) == (is_maxim(lp) == FALSE)) {
+          if ((lp->is_lower[varnr] == 0) == (is_maxim(lp) == FFALSE)) {
             a = min1;
             min1 = min2;
             min2 = a;
@@ -9569,7 +9569,7 @@
       lp->objfrom[i]=from;
       lp->objtill[i]=till;
     }
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
   }
   FREE(prow);
   FREE(OrigObj);
@@ -9586,7 +9586,7 @@
   else if (pivcount < 2*DEF_MAXPIVOTRETRY)
     return( TRUE );
   else
-    return( FALSE );
+    return( FFALSE );
 }
 
 STATIC MYBOOL check_if_less(lprec *lp, REAL x, REAL y, int variable)
@@ -9595,7 +9595,7 @@
     if(lp->bb_trace)
       report(lp, NORMAL, "check_if_less: Invalid new bound %g should be < %g for %s\n",
                          x, y, get_col_name(lp, variable));
-    return(FALSE);
+    return(FFALSE);
   }
   else
     return(TRUE);
@@ -9631,7 +9631,7 @@
 
   out = var_basic[rownr];
   var_basic[rownr] = var;
-  is_basic[out] = FALSE;
+  is_basic[out] = FFALSE;
   is_basic[var] = TRUE;
 }
 
@@ -9803,15 +9803,15 @@
   int  i, ii, n, *oldmap, *newmap, *refmap = NULL;
   REAL *oldrhs, err, errmax;
 
-  allocINT(lp, &oldmap, lp->rows+1, FALSE);
-  allocINT(lp, &newmap, lp->rows+1, FALSE);
-  allocREAL(lp, &oldrhs, lp->rows+1, FALSE);
+  allocINT(lp, &oldmap, lp->rows+1, FFALSE);
+  allocINT(lp, &newmap, lp->rows+1, FFALSE);
+  allocREAL(lp, &oldrhs, lp->rows+1, FFALSE);
 
   /* Get sorted mapping of the old basis */
   for(i = 0; i <= lp->rows; i++)
     oldmap[i] = i;
   if(reinvert) {
-    allocINT(lp, &refmap, lp->rows+1, FALSE);
+    allocINT(lp, &refmap, lp->rows+1, FFALSE);
     MEMCOPY(refmap, lp->var_basic, lp->rows+1);
     sortByINT(oldmap, refmap, lp->rows, 1, TRUE);
   }
@@ -9819,7 +9819,7 @@
   /* Save old and calculate the new RHS vector */
   MEMCOPY(oldrhs, lp->rhs, lp->rows+1);
   if(reinvert)
-    invert(lp, INITSOL_USEZERO, FALSE);
+    invert(lp, INITSOL_USEZERO, FFALSE);
   else
     recompute_solution(lp, INITSOL_USEZERO);
 
@@ -9905,7 +9905,7 @@
       if(knint > 1)
         break;
 
-      mv = get_mat_byindex(lp, jb, TRUE, FALSE);
+      mv = get_mat_byindex(lp, jb, TRUE, FFALSE);
       if(fabs(my_reldiff(mv, rh)) > lp->epsprimal)
         break;
 
@@ -10006,7 +10006,7 @@
   if(lp->constraintOF) {
     del_constraint(lp, lp->rows);
     if(is_BasisReady(lp) && !verify_basis(lp))
-      return( FALSE );
+      return( FFALSE );
   }
 */
 #endif
@@ -10035,16 +10035,16 @@
     doPP = is_piv_mode(lp, PRICE_PARTIAL | PRICE_AUTOPARTIAL);
 /*    doPP &= (MYBOOL) (lp->columns / 2 > lp->rows); */
     if(doPP) {
-      i = partial_findBlocks(lp, FALSE, FALSE);
+      i = partial_findBlocks(lp, FFALSE, FFALSE);
       if(i < 4)
         i = (int) (5 * log((REAL) lp->columns / lp->rows));
       report(lp, NORMAL, "The model is %s to have %d column blocks/stages.\n",
                          (i > 1 ? "estimated" : "set"), i);
-      set_partialprice(lp, i, NULL, FALSE);
+      set_partialprice(lp, i, NULL, FFALSE);
     }
 /*    doPP &= (MYBOOL) (lp->rows / 4 > lp->columns); */
     if(doPP) {
-      i = partial_findBlocks(lp, FALSE, TRUE);
+      i = partial_findBlocks(lp, FFALSE, TRUE);
       if(i < 4)
         i = (int) (5 * log((REAL) lp->rows / lp->columns));
       report(lp, NORMAL, "The model is %s to have %d row blocks/stages.\n",
@@ -10114,7 +10114,7 @@
                        (hold < -lp->negrange) &&
                        (lp->orig_lowbo[i] <= lp->negrange)) ) {
 */
-#define fullybounded FALSE
+#define fullybounded FFALSE
     if( ((hold < lp->infinite) && my_infinite(lp, lp->orig_lowbo[i])) ||
         (!fullybounded && !my_infinite(lp, lp->negrange) &&
          (hold < -lp->negrange) && (lp->orig_lowbo[i] <= lp->negrange)) ) {
@@ -10125,7 +10125,7 @@
       mat_multcol(lp->matA, j, -1, TRUE);
       if(lp->var_is_free == NULL) {
         if(!allocINT(lp, &lp->var_is_free, MAX(lp->columns, lp->columns_alloc) + 1, TRUE))
-          return(FALSE);
+          return(FFALSE);
       }
       lp->var_is_free[j] = -j; /* Indicator UB and LB are switched, with no helper variable added */
       lp->orig_upbo[i] = my_flipsign(lp->orig_lowbo[i]);
@@ -10140,7 +10140,7 @@
     else if((lp->orig_lowbo[i] <= lp->negrange) && (hold >= -lp->negrange)) {
       if(lp->var_is_free == NULL) {
         if(!allocINT(lp, &lp->var_is_free, MAX(lp->columns,lp->columns_alloc) + 1, TRUE))
-          return(FALSE);
+          return(FFALSE);
       }
       if(lp->var_is_free[j] <= 0) { /* If this variable wasn't split yet ... */
         if(SOS_is_member(lp->SOS, 0, i - lp->rows)) {   /* Added */
@@ -10150,9 +10150,9 @@
           continue;
         }
         if(new_column == NULL) {
-          if(!allocREAL(lp, &new_column, lp->rows + 1, FALSE) ||
-             !allocINT(lp, &new_index, lp->rows + 1, FALSE)) {
-            ok = FALSE;
+          if(!allocREAL(lp, &new_column, lp->rows + 1, FFALSE) ||
+             !allocINT(lp, &new_index, lp->rows + 1, FFALSE)) {
+            ok = FFALSE;
             break;
           }
         }
@@ -10160,10 +10160,10 @@
        /* in get_column and add_column operations; also make sure that */
        /* full scaling information is preserved */
         scaled = lp->scaling_used;
-        lp->scaling_used = FALSE;
+        lp->scaling_used = FFALSE;
         k = get_columnex(lp, j, new_column, new_index);
         if(!add_columnex(lp, k, new_column, new_index)) {
-          ok = FALSE;
+          ok = FFALSE;
           break;
         }
         mat_multcol(lp->matA, lp->columns, -1, TRUE);
@@ -10179,7 +10179,7 @@
           sprintf(fieldn, "__AntiBodyOf(%d)__", j);
           if(!set_col_name(lp, lp->columns, fieldn)) {
 /*          if (!set_col_name(lp, lp->columns, get_col_name(lp, j))) { */
-            ok = FALSE;
+            ok = FFALSE;
             break;
           }
         }
@@ -10318,6 +10318,6 @@
 
   }
 
-  lp->wasPreprocessed = FALSE;
+  lp->wasPreprocessed = FFALSE;
 }
 
diff -ru lp_solve_5.5.orig/lp_matrix.c lp_solve_5.5/lp_matrix.c
--- lp_solve_5.5.orig/lp_matrix.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_matrix.c	2019-02-19 11:57:43.416862191 -0600
@@ -99,7 +99,7 @@
 #else
      (rowextra < 0) || (colextra < 0) || (nzextra < 0))
 #endif
-    return( FALSE );
+    return( FFALSE );
 
   mat->rows_alloc    = MIN(mat->rows_alloc,    mat->rows + rowextra);
   mat->columns_alloc = MIN(mat->columns_alloc, mat->columns + colextra);
@@ -209,7 +209,7 @@
 
     /* Update row pointers */
     status = allocINT(mat->lp, &mat->row_end, rowsum, AUTOMATIC);
-    mat->row_end_valid = FALSE;
+    mat->row_end_valid = FFALSE;
   }
   return( status );
 }
@@ -235,7 +235,7 @@
       mat->col_end[0] = 0;
     for(i = MIN(oldcolsalloc, mat->columns) + 1; i < colsum; i++)
       mat->col_end[i] = mat->col_end[i-1];
-    mat->row_end_valid = FALSE;
+    mat->row_end_valid = FFALSE;
   }
   return( status );
 }
@@ -266,9 +266,9 @@
 {
 #ifdef Paranoia
   if(isrow && ((index < 0) || (index > mat->rows)))
-    return( FALSE );
+    return( FFALSE );
   else if(!isrow && ((index < 1) || (index > mat->columns)))
-    return( FALSE );
+    return( FFALSE );
 #endif
 
   if(isrow && mat_validate(mat)) {
@@ -288,7 +288,7 @@
 STATIC int mat_shiftrows(MATrec *mat, int *bbase, int delta, LLrec *varmap)
 {
   int     j, k, i, ii, thisrow, *colend, base;
-  MYBOOL  preparecompact = FALSE;
+  MYBOOL  preparecompact = FFALSE;
   int     *rownr;
 
   if(delta == 0)
@@ -320,7 +320,7 @@
     if(preparecompact) {
       /* Create the offset array */
       int *newrowidx = NULL;
-      allocINT(mat->lp, &newrowidx, mat->rows+1, FALSE);
+      allocINT(mat->lp, &newrowidx, mat->rows+1, FFALSE);
       newrowidx[0] = 0;
       delta = 0;
       for(j = 1; j <= mat->rows; j++) {
@@ -420,15 +420,15 @@
   /* Create map and sort by increasing index in "mat" */
   if(mat2 != NULL) {
     jj = mat2->col_tag[0];
-    allocINT(lp, &indirect, jj+1, FALSE);
+    allocINT(lp, &indirect, jj+1, FFALSE);
     indirect[0] = jj;
     for(i = 1; i <= jj; i++)
       indirect[i] = i;
-    hpsortex(mat2->col_tag, jj, 1, sizeof(*indirect), FALSE, compareINT, indirect);
+    hpsortex(mat2->col_tag, jj, 1, sizeof(*indirect), FFALSE, compareINT, indirect);
   }
 
   /* Do the compacting */
-  mat->row_end_valid = FALSE;
+  mat->row_end_valid = FFALSE;
   nz = mat->col_end[mat->columns];
   ie = 0;
   ii = 0;
@@ -781,7 +781,7 @@
   for(xa = 0; xa < na; xa++, rownr += matRowColStep, colnr += matRowColStep, value += matValueStep) {
     if((isActiveLink(colmap, *colnr) ^ negated) &&
        (isActiveLink(rowmap, *rownr) ^ negated))
-      mat_setvalue(newmat, *rownr, *colnr, *value, FALSE);
+      mat_setvalue(newmat, *rownr, *colnr, *value, FFALSE);
   }
 
   /* Return the populated new matrix */
@@ -798,7 +798,7 @@
   /* Check if we are in row order mode and should add as row instead;
      the matrix will be transposed at a later stage */
   if(checkrowmode && mat->is_roworder)
-    return( mat_setrow(mat, colno, count, column, rowno, doscale, FALSE) );
+    return( mat_setrow(mat, colno, count, column, rowno, doscale, FFALSE) );
 
   /* Initialize and validate */
   isA = (MYBOOL) (mat == mat->lp->matA);
@@ -806,12 +806,12 @@
   if(!isNZ)
     count = mat->lp->rows;
   else if((count < 0) || (count > mat->rows+((mat->is_roworder) ? 0 : 1)))
-    return( FALSE );
+    return( FFALSE );
   if(isNZ && (count > 0)) {
     if(count > 1)
       sortREALByINT(column, rowno, count, 0, TRUE);
     if((rowno[0] < 0) || (rowno[count-1] > mat->rows))
-      return( FALSE );
+      return( FFALSE );
   }
 
   /* Capture OF definition in column mode */
@@ -856,7 +856,7 @@
   else {
     newnr = 0;
     if(!allocMYBOOL(lp, &addto, mat->rows + 1, TRUE)) {
-      return( FALSE );
+      return( FFALSE );
     }
     for(i = mat->rows; i >= 0; i--) {
       if(fabs(column[i]) > mat->epsvalue) {
@@ -931,7 +931,7 @@
       jj++;
     }
   }
-  mat->row_end_valid = FALSE;
+  mat->row_end_valid = FFALSE;
 
   /* Finish and return */
 Done:
@@ -948,15 +948,15 @@
   int   i, ix, iy, n, *colmap = NULL;
   REAL  *colvalue = NULL;
 
-  if((target->rows < source->rows) || !allocREAL(lp, &colvalue, target->rows+1, FALSE))
-    return( FALSE );
+  if((target->rows < source->rows) || !allocREAL(lp, &colvalue, target->rows+1, FFALSE))
+    return( FFALSE );
 
   if(usecolmap) {
     n = source->col_tag[0];
-    allocINT(lp, &colmap, n+1, FALSE);
+    allocINT(lp, &colmap, n+1, FFALSE);
     for(i = 1; i <= n; i++)
       colmap[i] = i;
-    hpsortex(source->col_tag, n, 1, sizeof(*colmap), FALSE, compareINT, colmap);
+    hpsortex(source->col_tag, n, 1, sizeof(*colmap), FFALSE, compareINT, colmap);
   }
   else
     n = source->columns;
@@ -973,8 +973,8 @@
     }
     else
       ix = iy = i;
-    mat_expandcolumn(source, ix, colvalue, NULL, FALSE);
-    mat_setcol(target, iy, 0, colvalue, NULL, FALSE, FALSE);
+    mat_expandcolumn(source, ix, colvalue, NULL, FFALSE);
+    mat_setcol(target, iy, 0, colvalue, NULL, FFALSE, FFALSE);
   }
 
   FREE( colvalue );
@@ -1000,22 +1000,22 @@
   /* Check if we are in row order mode and should add as column instead;
      the matrix will be transposed at a later stage */
   if(checkrowmode && mat->is_roworder)
-    return( mat_setcol(mat, rowno, count, row, colno, doscale, FALSE) );
+    return( mat_setcol(mat, rowno, count, row, colno, doscale, FFALSE) );
 
   /* Do initialization and validation */
   if(!mat_validate(mat))
-    return( FALSE );
+    return( FFALSE );
   isA = (MYBOOL) (mat == lp->matA);
   isNZ = (MYBOOL) (colno != NULL);
   if(!isNZ)
     count = mat->columns;
   else if((count < 0) || (count > mat->columns))
-    return( FALSE );
+    return( FFALSE );
   if(isNZ && (count > 0)) {
     if(count > 1)
       sortREALByINT(row, (int *) colno, count, 0, TRUE);
     if((colno[0] < 1) || (colno[count-1] > mat->columns))
-      return( FALSE );
+      return( FFALSE );
   }
 
   /* Capture OF definition in row mode */
@@ -1130,7 +1130,7 @@
         else {
           if(addto == NULL) {
             if(!allocMYBOOL(lp, &addto, mat->columns + 1, TRUE))
-              return( FALSE );
+              return( FFALSE );
             firstcol = k;
           }
           addto[k] = TRUE;
@@ -1140,7 +1140,7 @@
     }
   }
   if(newnr == 0)
-   if (FALSE)
+   if (FFALSE)
     return( TRUE );
 
   /* Make sure we have enough matrix space */
@@ -1201,7 +1201,7 @@
   if(jj_j > 0) {
     if(!inc_mat_space(mat, jj_j)) {
       FREE(addto);
-      return( FALSE );
+      return( FFALSE );
     }
     if(orignr-jj > 0) {
       COL_MAT_MOVE(jj+jj_j, jj, orignr-jj);
@@ -1371,7 +1371,7 @@
   /* Compact in the case that we added zeros and set flag for row index update */
   if(matz > 0)
     mat_zerocompact(mat);
-  mat->row_end_valid = FALSE;
+  mat->row_end_valid = FFALSE;
 
 Done:
   if(saved != 0)
@@ -1396,18 +1396,18 @@
   /* Check if we are in row order mode and should add as column instead;
      the matrix will be transposed at a later stage */
   if(checkrowmode && mat->is_roworder)
-    return( mat_setcol(mat, rowno, count, row, colno, doscale, FALSE) );
+    return( mat_setcol(mat, rowno, count, row, colno, doscale, FFALSE) );
 
   /* Do initialization and validation */
   if(!mat_validate(mat))
-    return( FALSE );
+    return( FFALSE );
   isA = (MYBOOL) (mat == lp->matA);
   if(doscale && isA && !lp->scaling_used)
-    doscale = FALSE;
+    doscale = FFALSE;
   isNZ = (MYBOOL) (colno != NULL);
   lendense = (mat->is_roworder ? lp->rows : lp->columns);
   if((count < 0) || (count > lendense))
-    return( FALSE );
+    return( FFALSE );
   colnr1 = lendense + 1;
 
   /* Capture OF definition in row mode */
@@ -1437,14 +1437,14 @@
   /* Make local working data copies */
   if(!isNZ) {
     REAL *tmprow = NULL;
-    if(!allocINT(lp, &colno, lendense+1, FALSE))
-      return( FALSE );
+    if(!allocINT(lp, &colno, lendense+1, FFALSE))
+      return( FFALSE );
     newnz = 0;
     for(i = 1; i <= lendense; i++)
       if((value = row[i]) != 0) {
-        if((tmprow == NULL) && !allocREAL(lp, &tmprow, lendense-i+1, FALSE)) {
+        if((tmprow == NULL) && !allocREAL(lp, &tmprow, lendense-i+1, FFALSE)) {
           FREE(colno);
-          return( FALSE );
+          return( FFALSE );
         }
         tmprow[newnz] = value;
         colno[newnz++] = i;
@@ -1454,8 +1454,8 @@
   }
   else {
     int *tmpcolno = NULL;
-    if(!allocINT(lp, &tmpcolno, lendense, FALSE))
-      return( FALSE );
+    if(!allocINT(lp, &tmpcolno, lendense, FFALSE))
+      return( FFALSE );
     newnz = count;
     MEMCOPY(tmpcolno, colno, newnz);
     colno = tmpcolno;
@@ -1464,7 +1464,7 @@
     if((newnz > 0) && ((colno[0] < 0) || (colno[newnz-1] > lendense))) {
       FREE(colno);
       newnz = 0;
-      return( FALSE );
+      return( FFALSE );
     }
   }
 
@@ -1609,7 +1609,7 @@
   jj_j = origidx - j;
   for(; k <= lendense; k++)
     mat->col_end[k] = jj_j;
-  mat->row_end_valid = FALSE;
+  mat->row_end_valid = FFALSE;
 
 Done:
   if(!isNZ)
@@ -1630,7 +1630,7 @@
   /* Check if we are in row order mode and should add as column instead;
      the matrix will be transposed at a later stage */
   if(checkrowmode && mat->is_roworder)
-    return( mat_appendcol(mat, count, row, colno, mult, FALSE) );
+    return( mat_appendcol(mat, count, row, colno, mult, FFALSE) );
 
   /* Do initialization and validation */
   isA = (MYBOOL) (mat == lp->matA);
@@ -1765,7 +1765,7 @@
   /* Check if we are in row order mode and should add as row instead;
      the matrix will be transposed at a later stage */
   if(checkrowmode && mat->is_roworder)
-    return( mat_appendrow(mat, count, column, rowno, mult, FALSE) );
+    return( mat_appendrow(mat, count, column, rowno, mult, FFALSE) );
 
   /* Make sure we have enough space */
 /*
@@ -1929,7 +1929,7 @@
           report(mat->lp, SEVERE, "mat_validate: Matrix value storage error row %d [0..%d], column %d [1..%d]\n",
                                   *rownr, mat->rows, *colnr, mat->columns);
           mat->lp->spx_status = UNKNOWNERROR;
-          return(FALSE);
+          return(FFALSE);
         }
 #endif
         *colnr = i;
@@ -2197,14 +2197,14 @@
     }
     else {
       mat_setitem(mat, row, column, delta);
-      return( FALSE );
+      return( FFALSE );
     }
   }
 }
 
 STATIC MYBOOL mat_setitem(MATrec *mat, int row, int column, REAL value)
 {
-  return( mat_setvalue(mat, row, column, value, FALSE) );
+  return( mat_setvalue(mat, row, column, value, FFALSE) );
 }
 
 STATIC void mat_multrow(MATrec *mat, int row_nr, REAL mult)
@@ -2329,9 +2329,9 @@
   }
 
   /* Find out if we already have such an entry, or return insertion point */
-  i = mat_findins(mat, Row, Column, &elmnr, FALSE);
+  i = mat_findins(mat, Row, Column, &elmnr, FFALSE);
   if(i == -1)
-    return(FALSE);
+    return(FFALSE);
 
   if(isA)
     set_action(&mat->lp->spx_action, ACTION_REBASE | ACTION_RECOMPUTE | ACTION_REINVERT);
@@ -2363,14 +2363,14 @@
       for(i = Column; i <= mat->columns; i++)
         mat->col_end[i]--;
 
-      mat->row_end_valid = FALSE;
+      mat->row_end_valid = FFALSE;
     }
   }
   else if(fabs(Value) > mat->epsvalue) {
     /* no existing entry. make new one only if not nearly zero */
     /* check if more space is needed for matrix */
     if(!inc_mat_space(mat, 1))
-      return(FALSE);
+      return(FFALSE);
 
     if(Column > mat->columns) {
       i = mat->columns + 1;
@@ -2403,7 +2403,7 @@
     for(i = Column; i <= mat->columns; i++)
       mat->col_end[i]++;
 
-    mat->row_end_valid = FALSE;
+    mat->row_end_valid = FFALSE;
   }
 
   if(isA && (mat->lp->var_is_free != NULL) && (mat->lp->var_is_free[ColumnA] > 0))
@@ -2425,13 +2425,13 @@
 
   /* Check if more space is needed for matrix */
   if(!inc_mat_space(mat, 1))
-    return(FALSE);
+    return(FFALSE);
 
 #ifdef Paranoia
   /* Check valid indeces */
   if((Row < 0) || (Row > mat->rows)) {
     report(mat->lp, SEVERE, "mat_appendvalue: Invalid row index %d specified\n", Row);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -2441,14 +2441,14 @@
 
   /* Update column count */
   (*elmnr)++;
-  mat->row_end_valid = FALSE;
+  mat->row_end_valid = FFALSE;
 
   return(TRUE);
 }
 
 STATIC MYBOOL mat_equalRows(MATrec *mat, int baserow, int comprow)
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
   if(mat_validate(mat)) {
     int bj1 = 0, ej1, bj2 = 0, ej2;
@@ -2469,7 +2469,7 @@
       if(COL_MAT_COLNR(bj1) != COL_MAT_COLNR(bj2))
         break;
 #if 1
-      if(fabs(get_mat_byindex(mat->lp, bj1, TRUE, FALSE)-get_mat_byindex(mat->lp, bj2, TRUE, FALSE)) > mat->lp->epsprimal)
+      if(fabs(get_mat_byindex(mat->lp, bj1, TRUE, FFALSE)-get_mat_byindex(mat->lp, bj2, TRUE, FFALSE)) > mat->lp->epsprimal)
 #else
       if(fabs(COL_MAT_VALUE(bj1)-COL_MAT_VALUE(bj2)) > mat->lp->epsprimal)
 #endif
@@ -2537,7 +2537,7 @@
   /* Prepare arrays */
   if(!allocREAL(mat->lp, &mat->colmax, mat->columns_alloc+1, AUTOMATIC) ||
      !allocREAL(mat->lp, &mat->rowmax, mat->rows_alloc+1, AUTOMATIC))
-     return( FALSE );
+     return( FFALSE );
   MEMCLEAR(mat->colmax, mat->columns+1);
   MEMCLEAR(mat->rowmax, mat->rows+1);
 
@@ -2600,8 +2600,8 @@
 #else /*if MatrixColAccess==CAM_Vector*/
       REAL *newValue = NULL;
       int  *newRownr = NULL;
-      allocREAL(mat->lp, &newValue, mat->mat_alloc, FALSE);
-      allocINT(mat->lp, &newRownr, mat->mat_alloc, FALSE);
+      allocREAL(mat->lp, &newValue, mat->mat_alloc, FFALSE);
+      allocINT(mat->lp, &newRownr, mat->mat_alloc, FFALSE);
 
       j = mat->row_end[0];
       for(i = nz-1; i >= j ; i--) {
@@ -2640,7 +2640,7 @@
 
     /* Finally set current storage mode */
     mat->is_roworder = (MYBOOL) !mat->is_roworder;
-    mat->row_end_valid = FALSE;
+    mat->row_end_valid = FFALSE;
   }
   return(status);
 }
@@ -2731,7 +2731,7 @@
 STATIC MYBOOL freeUndoLadder(DeltaVrec **DV)
 {
   if((DV == NULL) || (*DV == NULL))
-    return(FALSE);
+    return(FFALSE);
 
   mat_free(&((*DV)->tracker));
   FREE(*DV);
@@ -2759,19 +2759,19 @@
 
     /* Do normal user variable case */
     if(colnrDep <= lp->columns)
-      mat_setvalue(mat, colnrDep, ix, beta, FALSE);
+      mat_setvalue(mat, colnrDep, ix, beta, FFALSE);
 
     /* Handle case where a slack variable is referenced */
     else {
       int ipos, jx = mat->col_tag[ix];
-      mat_setvalue(mat, jx, ix, beta, FALSE);
-      jx = mat_findins(mat, jx, ix, &ipos, FALSE);
+      mat_setvalue(mat, jx, ix, beta, FFALSE);
+      jx = mat_findins(mat, jx, ix, &ipos, FFALSE);
       COL_MAT_ROWNR(ipos) = colnrDep;
     }
     return( TRUE );
   }
   else
-    return( FALSE );
+    return( FFALSE );
 }
 STATIC MYBOOL addUndoPresolve(lprec *lp, MYBOOL isprimal, int colnrElim, REAL alpha, REAL beta, int colnrDep)
 {
@@ -2787,7 +2787,7 @@
       *DV = createUndoLadder(lp, lp->columns+1, lp->columns);
       mat = (*DV)->tracker;
       mat->epsvalue = lp->matA->epsvalue;
-      allocINT(lp, &(mat->col_tag), lp->columns+1, FALSE);
+      allocINT(lp, &(mat->col_tag), lp->columns+1, FFALSE);
       mat->col_tag[0] = 0;
     }
   }
@@ -2797,7 +2797,7 @@
       *DV = createUndoLadder(lp, lp->rows+1, lp->rows);
       mat = (*DV)->tracker;
       mat->epsvalue = lp->matA->epsvalue;
-      allocINT(lp, &(mat->col_tag), lp->rows+1, FALSE);
+      allocINT(lp, &(mat->col_tag), lp->rows+1, FFALSE);
       mat->col_tag[0] = 0;
     }
   }
@@ -2810,13 +2810,13 @@
   ix = mat->col_tag[0] = incrementUndoLadder(*DV);
   mat->col_tag[ix] = colnrElim;
   if(alpha != 0)
-    mat_setvalue(mat, 0, ix, alpha, FALSE);
+    mat_setvalue(mat, 0, ix, alpha, FFALSE);
 /*    mat_appendvalue(*mat, 0, alpha);*/
   if((colnrDep > 0) && (beta != 0)) {
     if(colnrDep > lp->columns)
       return( appendUndoPresolve(lp, isprimal, beta, colnrDep) );
     else
-      mat_setvalue(mat, colnrDep, ix, beta, FALSE);
+      mat_setvalue(mat, colnrDep, ix, beta, FFALSE);
   }
 
   return( TRUE );
@@ -2957,7 +2957,7 @@
  /* Make sure the tags are correct */
   if(!mat_validate(lp->matA)) {
     lp->spx_status = INFEASIBLE;
-    return(FALSE);
+    return(FFALSE);
   }
 
  /* Create the inverse management object at the first call to invert() */
@@ -2970,7 +2970,7 @@
  /* Must save spx_status since it is used to carry information about
     the presence and handling of singular columns in the matrix */
   if(userabort(lp, MSG_INVERT))
-    return(FALSE);
+    return(FFALSE);
 
 #ifdef Paranoia
   if(lp->spx_trace)
@@ -2982,7 +2982,7 @@
     the basis is I; in this case take the easy way out */
   if(!allocMYBOOL(lp, &usedpos, lp->sum + 1, TRUE)) {
     lp->bb_break = TRUE;
-    return(FALSE);
+    return(FFALSE);
   }
   usedpos[0] = TRUE;
   usercolB = 0;
@@ -3008,7 +3008,7 @@
     if(resetbasis) {
       j = lp->var_basic[i];
       if(j > lp->rows)
-        lp->is_basic[j] = FALSE;
+        lp->is_basic[j] = FFALSE;
       lp->var_basic[i] = i;
       lp->is_basic[i] = TRUE;
     }
@@ -3036,7 +3036,7 @@
 
 Cleanup:
   /* Check for numerical instability indicated by frequent refactorizations */
-  test = get_refactfrequency(lp, FALSE);
+  test = get_refactfrequency(lp, FFALSE);
   if(test < MIN_REFACTFREQUENCY) {
     test = get_refactfrequency(lp, TRUE);
     report(lp, NORMAL, "invert: Refactorization frequency %.1g indicates numeric instability.\n",
@@ -3055,9 +3055,9 @@
   int    j;
   MYBOOL Ok = TRUE;
 
-  allocREAL(lp, &errors, lp->rows + 1, FALSE);
+  allocREAL(lp, &errors, lp->rows + 1, FFALSE);
   if(errors == NULL) {
-    Ok = FALSE;
+    Ok = FFALSE;
     return(Ok);
   }
   MEMCOPY(errors, pcol, lp->rows + 1);
@@ -3087,9 +3087,9 @@
   REAL   *errors, err, maxerr;
   MYBOOL Ok = TRUE;
 
-  allocREAL(lp, &errors, lp->sum + 1, FALSE);
+  allocREAL(lp, &errors, lp->sum + 1, FFALSE);
   if(errors == NULL) {
-    Ok = FALSE;
+    Ok = FFALSE;
     return(Ok);
   }
   MEMCOPY(errors, rhsvector, lp->sum + 1);
@@ -3193,7 +3193,7 @@
   int n;
 
   if((densevector == NULL) || (nzindex == NULL) || (startpos > endpos))
-    return( FALSE );
+    return( FFALSE );
 
   n = 0;
   densevector += startpos;
@@ -3265,15 +3265,15 @@
 
   /* Adjust for partial pricing */
   if(varset & SCAN_PARTIALBLOCK) {
-    SETMAX(vb, partial_blockStart(lp, FALSE));
-    SETMIN(ve, partial_blockEnd(lp, FALSE));
+    SETMAX(vb, partial_blockStart(lp, FFALSE));
+    SETMIN(ve, partial_blockEnd(lp, FFALSE));
   }
 
   /* Determine exclusion columns */
   omitfixed = (MYBOOL) ((varset & OMIT_FIXED) != 0);
   omitnonfixed = (MYBOOL) ((varset & OMIT_NONFIXED) != 0);
   if(omitfixed && omitnonfixed)
-    return(FALSE);
+    return(FFALSE);
 
   /* Scan the target colums */
   if(append)
@@ -3323,7 +3323,7 @@
 /* prod_Ax is only used in fimprove; note that it is NOT VALIDATED/verified as of 20030801 - KE */
 {
   int      j, colnr, ib, ie, vb, ve;
-  MYBOOL   localset, localnz = FALSE, isRC;
+  MYBOOL   localset, localnz = FFALSE, isRC;
   MATrec   *mat = lp->matA;
   REAL     sdp;
   REAL     *value;
@@ -3339,9 +3339,9 @@
     if(isRC && is_piv_mode(lp, PRICE_PARTIAL) && !is_piv_mode(lp, PRICE_FORCEFULL))
       varset |= SCAN_PARTIALBLOCK;
     coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->sum+1, sizeof(*coltarget));
-    if(!get_colIndexA(lp, varset, coltarget, FALSE)) {
-      mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
-      return(FALSE);
+    if(!get_colIndexA(lp, varset, coltarget, FFALSE)) {
+      mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
+      return(FFALSE);
     }
   }
   localnz = (MYBOOL) (nzinput == NULL);
@@ -3377,9 +3377,9 @@
 
   /* Clean up and return */
   if(localset)
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
   if(localnz)
-    mempool_releaseVector(lp->workarrays, (char *) nzinput, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) nzinput, FFALSE);
 
   return(TRUE);
 }
@@ -3392,7 +3392,7 @@
    the same vector as input, without overwriting the [0..rows] elements. */
 {
   int      colnr, rownr, varnr, ib, ie, vb, ve, nrows = lp->rows;
-  MYBOOL   localset, localnz = FALSE, includeOF, isRC;
+  MYBOOL   localset, localnz = FFALSE, includeOF, isRC;
   REALXP   vmax;
   register REALXP v;
   int      inz, *rowin, countNZ = 0;
@@ -3418,9 +3418,9 @@
     if(isRC && is_piv_mode(lp, PRICE_PARTIAL) && !is_piv_mode(lp, PRICE_FORCEFULL))
       varset |= SCAN_PARTIALBLOCK;
     coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->sum+1, sizeof(*coltarget));
-    if(!get_colIndexA(lp, varset, coltarget, FALSE)) {
-      mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
-      return(FALSE);
+    if(!get_colIndexA(lp, varset, coltarget, FFALSE)) {
+      mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
+      return(FFALSE);
     }
   }
 /*#define UseLocalNZ*/
@@ -3589,9 +3589,9 @@
 
   /* Clean up and return */
   if(localset)
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
   if(localnz)
-    mempool_releaseVector(lp->workarrays, (char *) nzinput, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) nzinput, FFALSE);
 
   if(nzoutput != NULL)
     *nzoutput = countNZ;
@@ -3621,9 +3621,9 @@
                  /*SCAN_PARTIALBLOCK+*/
                  USE_NONBASICVARS+OMIT_FIXED;
     coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->sum+1, sizeof(*coltarget));
-    if(!get_colIndexA(lp, varset, coltarget, FALSE)) {
-      mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
-      return(FALSE);
+    if(!get_colIndexA(lp, varset, coltarget, FFALSE)) {
+      mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
+      return(FFALSE);
     }
   }
 
@@ -3768,7 +3768,7 @@
 
   /* Clean up and return */
   if(localset)
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
   return( TRUE );
 }
 
diff -ru lp_solve_5.5.orig/lp_MDO.c lp_solve_5.5/lp_MDO.c
--- lp_solve_5.5.orig/lp_MDO.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_MDO.c	2019-02-19 11:54:51.568857436 -0600
@@ -46,7 +46,7 @@
     return( test != TRUE );
 #else
     test = test & TRUE;
-    return( test == FALSE );
+    return( test == FFALSE );
 #endif
   }
 }
@@ -156,7 +156,7 @@
 
 int __WINAPI getMDO(lprec *lp, MYBOOL *usedpos, int *colorder, int *size, MYBOOL symmetric)
 {
-  int    error = FALSE;
+  int    error = FFALSE;
   int    nrows = lp->rows+1, ncols = colorder[0];
   int    i, j, kk, n;
   int    *col_end, *row_map = NULL;
@@ -166,7 +166,7 @@
 
  /* Tally the non-zero counts of the unused columns/rows of the 
     basis matrix and store corresponding "net" starting positions */
-  allocINT(lp, &col_end, ncols+1, FALSE);
+  allocINT(lp, &col_end, ncols+1, FFALSE);
   n = prepareMDO(lp, usedpos, colorder, col_end, NULL);
   Bnz = col_end[ncols];
 
@@ -175,7 +175,7 @@
     goto Transfer;
 
  /* Get net number of rows and fill mapper */
-  allocINT(lp, &row_map, nrows, FALSE);
+  allocINT(lp, &row_map, nrows, FFALSE);
   nrows = 0;
   for(i = 0; i <= lp->rows; i++) {
     row_map[i] = i-nrows;
@@ -187,7 +187,7 @@
 
  /* Store row indeces of non-zero values in the basic columns */
   Blen = colamd_recommended(Bnz, nrows, ncols);
-  allocINT(lp, &Brows, Blen, FALSE);
+  allocINT(lp, &Brows, Blen, FFALSE);
   prepareMDO(lp, usedpos, colorder, Brows, row_map);
 #ifdef Paranoia
   verifyMDO(lp, col_end, Brows, nrows, ncols);
diff -ru lp_solve_5.5.orig/lp_mipbb.c lp_solve_5.5/lp_mipbb.c
--- lp_solve_5.5.orig/lp_mipbb.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_mipbb.c	2019-02-19 11:58:25.340863351 -0600
@@ -48,14 +48,14 @@
   if(newBB != NULL) {
 
     if(parentBB == NULL) {
-      allocREAL(lp, &newBB->upbo,  lp->sum + 1, FALSE);
-      allocREAL(lp, &newBB->lowbo, lp->sum + 1, FALSE);
+      allocREAL(lp, &newBB->upbo,  lp->sum + 1, FFALSE);
+      allocREAL(lp, &newBB->lowbo, lp->sum + 1, FFALSE);
       MEMCOPY(newBB->upbo,  lp->orig_upbo,  lp->sum + 1);
       MEMCOPY(newBB->lowbo, lp->orig_lowbo, lp->sum + 1);
     }
     else if(dofullcopy) {
-      allocREAL(lp, &newBB->upbo,  lp->sum + 1, FALSE);
-      allocREAL(lp, &newBB->lowbo, lp->sum + 1, FALSE);
+      allocREAL(lp, &newBB->upbo,  lp->sum + 1, FFALSE);
+      allocREAL(lp, &newBB->lowbo, lp->sum + 1, FFALSE);
       MEMCOPY(newBB->upbo,  parentBB->upbo,  lp->sum + 1);
       MEMCOPY(newBB->lowbo, parentBB->lowbo, lp->sum + 1);
     }
@@ -85,7 +85,7 @@
   /* Do initialization and updates */
   if(parentBB == NULL)
     parentBB = lp->bb_bounds;
-  newBB = create_BB(lp, parentBB, FALSE);
+  newBB = create_BB(lp, parentBB, FFALSE);
   if(newBB != NULL) {
 
     newBB->varno = varno;
@@ -105,7 +105,7 @@
       for(k = 1; k <= lp->nzdrow[0]; k++) {
         ii = lp->nzdrow[k];
 #ifdef UseMilpSlacksRCF  /* Check if we should include ranged constraints */
-        isINT = FALSE;
+        isINT = FFALSE;
 #else
         if(ii <= lp->rows)
           continue;
@@ -168,7 +168,7 @@
 
 STATIC MYBOOL free_BB(BBrec **BB)
 {
-  MYBOOL parentreturned = FALSE;
+  MYBOOL parentreturned = FFALSE;
 
   if((BB != NULL) && (*BB != NULL)) {
     BBrec *parent = (*BB)->parent;
@@ -237,7 +237,7 @@
     }
     if(lp->int_vars+lp->sc_vars > 0)
       free_pseudocost(lp);
-    pop_basis(lp, FALSE);
+    pop_basis(lp, FFALSE);
     lp->rootbounds = NULL;
   }
   else
@@ -256,7 +256,7 @@
   /* Pop the associated basis */
 #if 1
   /* Original version that does not restore previous basis */
-  pop_basis(lp, FALSE);
+  pop_basis(lp, FFALSE);
 #else
   /* Experimental version that restores previous basis */
   pop_basis(lp, BB->isSOS);
@@ -388,7 +388,7 @@
       /* Set direction by pseudocost (normally used in tandem with NODE_PSEUDOxxxSELECT) */
       else if(is_bb_mode(lp, NODE_PSEUDOCOSTMODE)) {
         BB->isfloor = (MYBOOL) (get_pseudobranchcost(lp->bb_PseudoCost, k, TRUE) >
-                                get_pseudobranchcost(lp->bb_PseudoCost, k, FALSE));
+                                get_pseudobranchcost(lp->bb_PseudoCost, k, FFALSE));
         if(is_maxim(lp))
           BB->isfloor = !BB->isfloor;
       }
@@ -432,7 +432,7 @@
   REAL   ult_upbo, ult_lowbo;
   REAL   new_bound, SC_bound, intmargin = BB->lp->epsprimal;
   lprec  *lp = BB->lp;
-  MYBOOL OKstatus = FALSE;
+  MYBOOL OKstatus = FFALSE;
 
   if(lp->bb_break || userabort(lp, MSG_MILPSTRATEGY))
     return( OKstatus );
@@ -602,7 +602,7 @@
       if((BB->vartype != BB_SOS) && (fabs(BB->LObound-BB->UPbound) < intmargin)) {
         BB->nodesleft--;
         if(fabs(BB->lowbo[K]-BB->LObound) < intmargin)
-          BB->isfloor = FALSE;
+          BB->isfloor = FFALSE;
         else if(fabs(BB->upbo[K]-BB->UPbound) < intmargin)
           BB->isfloor = TRUE;
         else {
@@ -638,7 +638,7 @@
 {
   int    k;
   lprec  *lp = BB->lp;
-  MYBOOL OKstatus = FALSE;
+  MYBOOL OKstatus = FFALSE;
 
   /* Undo the most recently imposed B&B bounds using the data
      in the last level of change tracker; this code handles changes
@@ -652,7 +652,7 @@
     /* Handle the special case of B&B restart;
        (typically used with the restart after pseudocost initialization) */
     if((lp->bb_level == 1) && (lp->bb_break == AUTOMATIC)) {
-      lp->bb_break = FALSE;
+      lp->bb_break = FFALSE;
       OKstatus = TRUE;
     }
     return( OKstatus );
@@ -797,7 +797,7 @@
     /* Copy user-specified entering bounds into lp_solve working bounds and run */
     status = spx_run(lp, (MYBOOL) (tilted+restored > 0));
     lp->bb_status     = status;
-    lp->spx_perturbed = FALSE;
+    lp->spx_perturbed = FFALSE;
 
     if(tilted < 0)
       break;
@@ -817,7 +817,7 @@
       else
         impose_bounds(lp, perturbed->upbo, perturbed->lowbo);
       set_action(&lp->spx_action, ACTION_REBASE | ACTION_RECOMPUTE);
-      BB->UBzerobased = FALSE;
+      BB->UBzerobased = FFALSE;
       if(lp->bb_totalnodes == 0)
         lp->real_solution = lp->infinite;
       status = RUNNING;
@@ -845,11 +845,11 @@
 #if 1
         perturb_bounds(lp, perturbed, TRUE, TRUE, TRUE);
 #else
-        perturb_bounds(lp, perturbed, TRUE, TRUE, FALSE);
+        perturb_bounds(lp, perturbed, TRUE, TRUE, FFALSE);
 #endif
         impose_bounds(lp, perturbed->upbo, perturbed->lowbo);
         set_action(&lp->spx_action, ACTION_REBASE | ACTION_RECOMPUTE);
-        BB->UBzerobased = FALSE;
+        BB->UBzerobased = FFALSE;
         status = RUNNING;
         tilted++;
         lp->perturb_count++;
@@ -1025,7 +1025,7 @@
 
       /* Check and set feasibility status */
       if((isfeasible != NULL) && (upbo - lowbo < -lp->epsprimal))
-        *isfeasible = FALSE;
+        *isfeasible = FFALSE;
 
       /* Flag that we can fix the variable by returning the relation code negated */
       else if(fabs(upbo - lowbo) < lp->epsprimal)
@@ -1045,7 +1045,7 @@
 {
   int    countsossc, countnint, k, reasonmsg = MSG_NONE;
   REAL   varsol;
-  MYBOOL is_better = FALSE, is_equal = FALSE, is_feasible = TRUE;
+  MYBOOL is_better = FFALSE, is_equal = FFALSE, is_feasible = TRUE;
   lprec  *lp = BB->lp;
 
   /* Initialize result and return variables */
@@ -1066,13 +1066,13 @@
         2) B&B level relative to the "B&B order" (bb_limitlevel < 0). */
     countsossc =  lp->sos_vars + lp->sc_vars;
     if((lp->bb_limitlevel > 0) && (lp->bb_level > lp->bb_limitlevel+countsossc))
-      return( FALSE );
+      return( FFALSE );
     else if((lp->bb_limitlevel < 0) &&
             (lp->bb_level > 2*(lp->int_vars+countsossc)*abs(lp->bb_limitlevel))) {
       if(lp->bb_limitlevel == DEF_BB_LIMITLEVEL)
         report(lp, IMPORTANT, "findnode_BB: Default B&B limit reached at %d; optionally change strategy or limit.\n\n",
                               lp->bb_level);
-      return( FALSE );
+      return( FFALSE );
     }
 
     /* First initialize or update pseudo-costs from previous optimal solution */
@@ -1093,7 +1093,7 @@
       if(lp->bb_trace)
         report(lp, IMPORTANT, "findnode_BB: Simplex failure due to loss of numeric accuracy\n");
       lp->spx_status = NUMFAILURE;
-      return( FALSE );
+      return( FFALSE );
     }
 
     /* Abandon this branch if the solution is "worse" than a heuristically
@@ -1102,7 +1102,7 @@
        ((lp->solutioncount > 0) &&
         (!bb_better(lp, OF_INCUMBENT | OF_DELTA, OF_TEST_BE | OF_TEST_RELGAP) ||
          !bb_better(lp, OF_INCUMBENT | OF_DELTA, OF_TEST_BE)))) {
-      return( FALSE );
+      return( FFALSE );
     }
 
     /* Collect violated SC variables (since they can also be real-valued); the
@@ -1115,7 +1115,7 @@
 
     /* Look among SOS variables if no SC candidate was found */
     if((SOS_count(lp) > 0) && (*varno == 0)) {
-      *varno = find_sos_bbvar(lp, &countnint, FALSE);
+      *varno = find_sos_bbvar(lp, &countnint, FFALSE);
       if(*varno < 0)
         *varno = 0;
       else if(*varno > 0)
@@ -1129,7 +1129,7 @@
         *vartype = BB_INT;
         if((countnint == 1) && !is_feasible) {
           BB->lastrcf = 0;
-          return( FALSE );
+          return( FFALSE );
         }
       }
     }
@@ -1146,7 +1146,7 @@
 */
       /*  set_action(&lp->nomessage, NOMSG_BBLIMIT); */
       /* } */
-      return( FALSE );
+      return( FFALSE );
     }
 #endif
 
@@ -1191,7 +1191,7 @@
         }
 
         if(lp->bb_trace ||
-           ((lp->verbose >= NORMAL) && (lp->print_sol == FALSE) && (lp->lag_status != RUNNING))) {
+           ((lp->verbose >= NORMAL) && (lp->print_sol == FFALSE) && (lp->lag_status != RUNNING))) {
           report(lp, IMPORTANT,
                  "%s solution " RESULTVALUEMASK " after %10.0f iter, %9.0f nodes (gap %.1f%%)\n",
                  (lp->bb_improvements == 0) ? "Feasible" : "Improved",
@@ -1232,7 +1232,7 @@
       lp->spx_status = NUMFAILURE;
       lp->bb_status = lp->spx_status;
       lp->bb_break = TRUE;
-      return( FALSE );
+      return( FFALSE );
     }
 #endif
     transfer_solution(lp, (MYBOOL) ((lp->do_presolve & PRESOLVE_LASTMASKMODE) != PRESOLVE_NONE));
@@ -1247,7 +1247,7 @@
     if((reasonmsg != MSG_NONE) && (lp->msgmask & reasonmsg) && (lp->usermessage != NULL))
       lp->usermessage(lp, lp->msghandle, reasonmsg);
 
-    if(lp->print_sol != FALSE) {
+    if(lp->print_sol != FFALSE) {
       print_objective(lp);
       print_solution(lp, 1);
     }
@@ -1259,7 +1259,7 @@
     if((countnint == 0) && (lp->solutioncount == 1) && (lp->solutionlimit == 1) &&
        (bb_better(lp, OF_DUALLIMIT, OF_TEST_BE) || bb_better(lp, OF_USERBREAK, OF_TEST_BE | OF_TEST_RELGAP))) {
       lp->bb_break = (MYBOOL) (countnint == 0);
-      return( FALSE );
+      return( FFALSE );
     }
     else if(lp->bb_level > 0) {
 #ifdef MIPboundWithOF
@@ -1273,7 +1273,7 @@
     return( (MYBOOL) (*varno > 0));
   }
   else
-    return( FALSE );
+    return( FFALSE );
 
 }
 
@@ -1322,7 +1322,7 @@
 /* Routine to compute a "strong" pseudo-cost update for a node */
 STATIC MYBOOL strongbranch_BB(lprec *lp, BBrec *BB, int varno, int vartype, int varcus)
 {
-  MYBOOL   success = FALSE;
+  MYBOOL   success = FFALSE;
   int      i;
   BBrec    *strongBB;
 
@@ -1346,7 +1346,7 @@
       /* Compute new count of non-ints */
       strongBB->lastvarcus = 0;
       for(i = 1; i <= lp->columns; i++) {
-        if(is_int(lp, i) && !solution_is_int(lp, lp->rows+i, FALSE))
+        if(is_int(lp, i) && !solution_is_int(lp, lp->rows+i, FFALSE))
           strongBB->lastvarcus++;
       }
 
@@ -1364,7 +1364,7 @@
   pop_basis(lp, TRUE);
   set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);
 
-  lp->is_strongbranch = FALSE;
+  lp->is_strongbranch = FFALSE;
 
   return( success );
 }
diff -ru lp_solve_5.5.orig/lp_MPS.c lp_solve_5.5/lp_MPS.c
--- lp_solve_5.5.orig/lp_MPS.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_MPS.c	2019-02-19 11:59:02.500864379 -0600
@@ -464,7 +464,7 @@
         set_bounds(lp, lp->columns, 10.0 / DEF_INFINITE, DEF_INFINITE / 10.0);
     }
   }
-  *Column_ready = FALSE;
+  *Column_ready = FFALSE;
   *count = 0;
   return(ok);
 }
@@ -475,7 +475,7 @@
   int i = *count;
 
   if(rowValue[i] == 0)
-    return( FALSE );
+    return( FFALSE );
 
   while((i > 0) && (rowIndex[i] < rowIndex[i-1])) {
     swapINT (rowIndex+i, rowIndex+i-1);
@@ -493,7 +493,7 @@
 
   /* Check for non-negativity of the index */
   if(rowIndex[i] < 0)
-    return( FALSE );
+    return( FFALSE );
 
   /* Move the element so that the index list is sorted ascending */
   while((i > 0) && (rowIndex[i] < rowIndex[i-1])) {
@@ -521,7 +521,7 @@
 
 MYBOOL MPS_readfile(lprec **newlp, char *filename, int typeMPS, int verbose)
 {
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
   FILE   *fpin;
 
   fpin = fopen(filename, "r");
@@ -549,7 +549,7 @@
   int    items, row, Lineno, var,
          section = MPSUNDEF, variant = 0, NZ = 0, SOS = 0;
   MYBOOL Int_section, Column_ready, Column_ready1,
-         Unconstrained_rows_found = FALSE, OF_found = FALSE, CompleteStatus = FALSE;
+         Unconstrained_rows_found = FFALSE, OF_found = FFALSE, CompleteStatus = FFALSE;
   double field4, field6;
   REAL   *Last_column = NULL;
   int    count = 0, *Last_columnno = NULL;
@@ -581,8 +581,8 @@
     lp->verbose = verbose;
     strcpy(Last_col_name, "");
     strcpy(OBJNAME, "");
-    Int_section = FALSE;
-    Column_ready = FALSE;
+    Int_section = FFALSE;
+    Column_ready = FFALSE;
     Lineno = 0;
 
     /* let's initialize line to all zero's */
@@ -758,7 +758,7 @@
             else if(*field2) {
               Column_ready1 = (MYBOOL) (strcmp(field2, Last_col_name) != 0);
               if(Column_ready1) {
-                if (find_var(lp, field2, FALSE) >= 0) {
+                if (find_var(lp, field2, FFALSE) >= 0) {
                   report(lp, SEVERE, "Variable name (%s) is already used!\n", field2);
                   break;
                 }
@@ -783,7 +783,7 @@
                 report(lp, FULL, "Switching to integer section\n");
               }
               else if(strcmp(field5, "'INTEND'") == 0) {
-                Int_section = FALSE;
+                Int_section = FFALSE;
                 report(lp, FULL, "Switching to non-integer section\n");
               }
               else
@@ -861,10 +861,10 @@
           report(lp, FULL, "BOUNDS line: %s %s %s %g\n",
                             field1, field2, field3, field4);
 
-          var = find_var(lp, field3, FALSE);
+          var = find_var(lp, field3, FFALSE);
           if(var < 0){ /* bound on undefined var in COLUMNS section ... */
             Column_ready = TRUE;
-            if (!addmpscolumn(lp, FALSE, typeMPS, &Column_ready, &count, Last_column, Last_columnno, field3))
+            if (!addmpscolumn(lp, FFALSE, typeMPS, &Column_ready, &count, Last_column, Last_columnno, field3))
               break;
             Column_ready = TRUE;
             var = find_var(lp, field3, TRUE);
@@ -1112,10 +1112,10 @@
           else {
             char *field = (items == 3) ? field3 /* Native lp_solve and XPRESS formats */ : field2 /* CPLEX format */;
 
-            var = find_var(lp, field, FALSE);  /* Native lp_solve and XPRESS formats */
+            var = find_var(lp, field, FFALSE);  /* Native lp_solve and XPRESS formats */
             if(var < 0){ /* SOS on undefined var in COLUMNS section ... */
               Column_ready = TRUE;
-              if (!addmpscolumn(lp, FALSE, typeMPS, &Column_ready, &count, Last_column, Last_columnno, field))
+              if (!addmpscolumn(lp, FFALSE, typeMPS, &Column_ready, &count, Last_column, Last_columnno, field))
                 break;
               Column_ready = TRUE;
               var = find_var(lp, field, TRUE);
@@ -1137,10 +1137,10 @@
     if((*OBJNAME) && (!OF_found)) {
       report(lp, IMPORTANT,
                   "Error: Objective function specified by OBJNAME card not found\n");
-      CompleteStatus = FALSE;
+      CompleteStatus = FFALSE;
     }
 
-    if(CompleteStatus == FALSE) {
+    if(CompleteStatus == FFALSE) {
       if (*newlp == NULL)
         delete_lp(lp);
     }
@@ -1299,7 +1299,7 @@
 
 MYBOOL __WINAPI MPS_writefileex(lprec *lp, int typeMPS, void *userhandle, write_modeldata_func write_modeldata)
 {
-  int    i, j, jj, je, k, marker, putheader, ChangeSignObj = FALSE, *idx, *idx1;
+  int    i, j, jj, je, k, marker, putheader, ChangeSignObj = FFALSE, *idx, *idx1;
   MYBOOL ok = TRUE, names_used;
   REAL   a, *val, *val1;
   char * (*MPSname)(char *name0, char *name);
@@ -1315,7 +1315,7 @@
   }
   else {
     report(lp, IMPORTANT, "MPS_writefile: unrecognized MPS name type.\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   names_used = lp->names_used;
@@ -1328,11 +1328,11 @@
           for(j = 1; (j < i) && (ok); j++)
     if((lp->col_name[j] != NULL) && (lp->col_name[j]->name != NULL) && (!is_splitvar(lp, j)))
       if(strncmp(lp->col_name[i]->name, lp->col_name[j]->name, 8) == 0)
-        ok = FALSE;
+        ok = FFALSE;
   }
 
   if(!ok) {
-    lp->names_used = FALSE;
+    lp->names_used = FFALSE;
     ok = TRUE;
   }
 
@@ -1452,7 +1452,7 @@
     if(a) {
       if(putheader) {
         write_data(userhandle, write_modeldata, "RANGES\n");
-        putheader = FALSE;
+        putheader = FFALSE;
       }
       a = unscaled_value(lp, a, i);
       k = 1 - k;
@@ -1479,7 +1479,7 @@
         a = unscaled_value(lp, a, i);
         if(putheader) {
           write_data(userhandle, write_modeldata, "BOUNDS\n");
-          putheader = FALSE;
+          putheader = FFALSE;
         }
         write_data(userhandle, write_modeldata, " FX BND       %s  %s\n",
                         MPSname(name0, get_col_name(lp, j)),
@@ -1488,7 +1488,7 @@
       else if(is_binary(lp, j)) {
         if(putheader) {
           write_data(userhandle, write_modeldata, "BOUNDS\n");
-          putheader = FALSE;
+          putheader = FFALSE;
         }
         write_data(userhandle, write_modeldata, " BV BND       %s\n",
                         MPSname(name0, get_col_name(lp, j)));
@@ -1496,7 +1496,7 @@
       else if(is_unbounded(lp, j)) {
         if(putheader) {
           write_data(userhandle, write_modeldata, "BOUNDS\n");
-          putheader = FALSE;
+          putheader = FFALSE;
         }
         write_data(userhandle, write_modeldata, " FR BND       %s\n",
                         MPSname(name0, get_col_name(lp, j)));
@@ -1507,7 +1507,7 @@
           a = unscaled_value(lp, a, i);
           if(putheader) {
             write_data(userhandle, write_modeldata, "BOUNDS\n");
-            putheader = FALSE;
+            putheader = FFALSE;
           }
           if(lp->orig_lowbo[i] != -lp->infinite)
             write_data(userhandle, write_modeldata, " LO BND       %s  %s\n",
@@ -1524,7 +1524,7 @@
             a = unscaled_value(lp, a, i);
           if(putheader) {
             write_data(userhandle, write_modeldata, "BOUNDS\n");
-            putheader = FALSE;
+            putheader = FFALSE;
           }
           if(is_semicont(lp, j)) {
             if(is_int(lp, j))
@@ -1551,7 +1551,7 @@
 
     if(putheader) {
       write_data(userhandle, write_modeldata, "SOS\n");
-      putheader = FALSE;
+      putheader = FFALSE;
     }
     write_data(userhandle, write_modeldata, " S%1d SOS       %s  %s\n",
                     SOS->sos_list[i]->type,
@@ -1682,7 +1682,7 @@
     scan_line = scan_lineFREE;
   else {
     report(lp, IMPORTANT, "MPS_readBAS: unrecognized MPS line type.\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   ok = (MYBOOL) ((filename != NULL) && ((input = fopen(filename,"r")) != NULL));
@@ -1692,7 +1692,7 @@
 
   /* Let's initialize line to all zero's */
   MEMCLEAR(line, BUFSIZ);
-  ok = FALSE;
+  ok = FFALSE;
   while(fgets(line, BUFSIZ - 1, input)) {
     Lineno++;
 
@@ -1738,7 +1738,7 @@
         break;
       }
       /* find first variable index value */
-      in = MPS_getnameidx(lp, field2, FALSE);
+      in = MPS_getnameidx(lp, field2, FFALSE);
 #ifdef OldNameMatch
       if(in < 0)
         in = MPS_getnameidx(lp, field2, TRUE);
@@ -1752,7 +1752,7 @@
       if(field1[0] == 'X') {
         /* find second variable index value */
         ib = in;
-        in = MPS_getnameidx(lp, field3, FALSE);
+        in = MPS_getnameidx(lp, field3, FFALSE);
 #ifdef OldNameMatch
         if(in < 0)
           in = MPS_getnameidx(lp, field3, TRUE);
@@ -1768,7 +1768,7 @@
       else
         lp->is_lower[in] = (MYBOOL) (field1[0] == 'L');
 
-      lp->is_basic[in] = FALSE;
+      lp->is_basic[in] = FFALSE;
 
     }
   }
@@ -1801,7 +1801,7 @@
     MPSname = MPSnameFREE;
   else {
     report(lp, IMPORTANT, "MPS_writeBAS: unrecognized MPS name type.\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   /* Open the file for writing */
diff -ru lp_solve_5.5.orig/lp_params.c lp_solve_5.5/lp_params.c
--- lp_solve_5.5.orig/lp_params.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_params.c	2019-02-19 11:59:35.984865306 -0600
@@ -130,7 +130,7 @@
 
 static REAL __WINAPI get_mip_gap_rel(lprec *lp)
 {
-  return(get_mip_gap(lp, FALSE));
+  return(get_mip_gap(lp, FFALSE));
 }
 
 static void __WINAPI set_mip_gap_abs(lprec *lp, REAL mip_gap)
@@ -140,7 +140,7 @@
 
 static void __WINAPI set_mip_gap_rel(lprec *lp, REAL mip_gap)
 {
-  set_mip_gap(lp, FALSE, mip_gap);
+  set_mip_gap(lp, FFALSE, mip_gap);
 }
 
 static struct _values pivoting[] =
@@ -219,7 +219,7 @@
 
 static struct _values print_sol[] =
 {
-  { FALSE, "0" },
+  { FFALSE, "0" },
   { TRUE,  "1" },
   { setvalue(AUTOMATIC) },
 };
@@ -442,15 +442,15 @@
     case EACCES: /* File or directory specified by newname already exists or could not be created (invalid path); or oldname is a directory and newname specifies a different path. */
       FREE(filename0);
       FREE(header);
-      return(FALSE);
+      return(FFALSE);
       break;
     }
   }
 
   if((fp = ini_create(filename)) == NULL)
-    ret = FALSE;
+    ret = FFALSE;
   else {
-    params_written = FALSE;
+    params_written = FFALSE;
     newline = TRUE;
     if(filename0 != NULL) {
       fp0 = ini_open(filename0);
@@ -458,13 +458,13 @@
         rename(filename0, filename);
         FREE(filename0);
         FREE(header);
-        return(FALSE);
+        return(FFALSE);
       }
       looping = TRUE;
       while(looping) {
         switch(ini_readdata(fp0, buf, sizeof(buf), TRUE)) {
         case 0: /* End of file */
-          looping = FALSE;
+          looping = FFALSE;
           break;
         case 1: /* header */
           ptr1 = strdup(buf);
@@ -525,7 +525,7 @@
   char buf[4096], *header = NULL, *ptr, *ptr1, *ptr2;
 
   if((fp = ini_open(filename)) == NULL)
-    ret = FALSE;
+    ret = FFALSE;
   else {
     /* create hashtable of all callable commands to find them quickly */
     hashfunctions = create_hash_table(sizeof(functions) / sizeof(*functions), 0);
@@ -553,9 +553,9 @@
     line = 0;
     while((ret) && (looping)) {
       line++;
-      switch(ini_readdata(fp, buf, sizeof(buf), FALSE)) {
+      switch(ini_readdata(fp, buf, sizeof(buf), FFALSE)) {
         case 0: /* End of file */
-          looping = FALSE;
+          looping = FFALSE;
           break;
         case 1: /* header */
           switch(state) {
@@ -565,7 +565,7 @@
                 state = 1;
               break;
             case 1:
-              looping = FALSE;
+              looping = FFALSE;
               break;
           }
           break;
@@ -580,7 +580,7 @@
             ptr = strchr(buf, '=');
             if(ptr == NULL) {
               report(lp, IMPORTANT, "read_params: No equal sign on line %d\n", line);
-              ret = FALSE;
+              ret = FFALSE;
             }
             else {
               *ptr = 0;
@@ -588,14 +588,14 @@
               for(ptr2 = ptr - 1; (ptr2 >= ptr1) && (isspace(*ptr2)); ptr2--);
               if(ptr2 <= ptr1) {
                 report(lp, IMPORTANT, "read_params: No parameter name before equal sign on line %d\n", line);
-                ret = FALSE;
+                ret = FFALSE;
               }
               else {
                 ptr2[1] = 0;
                 hp = findhash(ptr1, hashfunctions);
                 if(hp == NULL) {
                   report(lp, IMPORTANT, "read_params: Unknown parameter name (%s) before equal sign on line %d\n", ptr1, line);
-                  ret = FALSE;
+                  ret = FFALSE;
                 }
                 else {
                   i = hp->index;
@@ -612,7 +612,7 @@
                           ptr2++;
                         if(*ptr2) {
                           report(lp, IMPORTANT, "read_params: Invalid integer value on line %d\n", line);
-                          ret = FALSE;
+                          ret = FFALSE;
                         }
                         break;
                       case REALfunction:
@@ -621,7 +621,7 @@
                           ptr2++;
                         if(*ptr2) {
                           report(lp, IMPORTANT, "read_params: Invalid real value on line %d\n", line);
-                          ret = FALSE;
+                          ret = FFALSE;
                         }
                         break;
                     }
@@ -640,14 +640,14 @@
                         hp = findhash(ptr1, hashparameters);
                         if (hp == NULL) {
                           report(lp, IMPORTANT, "read_params: Invalid parameter name (%s) on line %d\n", ptr1, line);
-                          ret = FALSE;
+                          ret = FFALSE;
                         }
                         else {
                           j = hp->index;
                           if((j >= functions[i].elements) ||
                              (strcmp(functions[i].values[j].svalue, ptr1))) {
                             report(lp, IMPORTANT, "read_params: Inappropriate parameter name (%s) on line %d\n", ptr1, line);
-                            ret = FALSE;
+                            ret = FFALSE;
                           }
                           else {
                             intvalue += functions[i].values[j].value;
diff -ru lp_solve_5.5.orig/lp_presolve.c lp_solve_5.5/lp_presolve.c
--- lp_solve_5.5.orig/lp_presolve.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_presolve.c	2019-02-19 12:01:01.680867677 -0600
@@ -80,7 +80,7 @@
   lp->presolve_undo = (presolveundorec *) calloc(1, sizeof(presolveundorec));
   lp->presolve_undo->lp = lp;
   if(lp->presolve_undo == NULL)
-    return( FALSE );
+    return( FFALSE );
   return( TRUE );
 }
 STATIC MYBOOL inc_presolve_space(lprec *lp, int delta, MYBOOL isrows)
@@ -129,12 +129,12 @@
   presolveundorec *psundo = lp->presolve_undo;
 
   if(psundo == NULL)
-    return( FALSE );
+    return( FFALSE );
   psundo->orig_rows = orig_rows;
   psundo->orig_columns = orig_cols;
   psundo->orig_sum = orig_rows + orig_cols;
   if(lp->wasPresolved)
-    presolve_fillUndo(lp, orig_rows, orig_cols, FALSE);
+    presolve_fillUndo(lp, orig_rows, orig_cols, FFALSE);
   return( TRUE );
 }
 STATIC MYBOOL presolve_fillUndo(lprec *lp, int orig_rows, int orig_cols, MYBOOL setOrig)
@@ -178,7 +178,7 @@
     slacks   = lp->full_duals + lp->presolve_undo->orig_rows;
   }
   if(mat == NULL)
-    return( FALSE );
+    return( FFALSE );
 
   /* Loop backward over the undo chain */
   for(j = mat->col_tag[0]; j > 0; j--) {
@@ -224,7 +224,7 @@
   presolveundorec *psundo = lp->presolve_undo;
 
   if(psundo == NULL)
-    return( FALSE );
+    return( FFALSE );
   FREE(psundo->orig_to_var);
   FREE(psundo->var_to_orig);
   FREE(psundo->fixed_rhs);
@@ -242,7 +242,7 @@
 STATIC void presolve_storeDualUndo(presolverec *psdata, int rownr, int colnr)
 {
   lprec    *lp = psdata->lp;
-  MYBOOL   firstdone = FALSE;
+  MYBOOL   firstdone = FFALSE;
   int      ix, iix, item;
   REAL     Aij = get_mat(lp, rownr, colnr);
   MATrec   *mat = lp->matA;
@@ -258,10 +258,10 @@
     if(iix == rownr)
       continue;
     if(!firstdone)
-      firstdone = addUndoPresolve(lp, FALSE, rownr, get_mat(lp, 0, colnr)/Aij,
-                                                    get_mat_byindex(lp, ix, FALSE, TRUE)/Aij, iix);
+      firstdone = addUndoPresolve(lp, FFALSE, rownr, get_mat(lp, 0, colnr)/Aij,
+                                                    get_mat_byindex(lp, ix, FFALSE, TRUE)/Aij, iix);
     else
-      appendUndoPresolve(lp, FALSE, get_mat_byindex(lp, ix, FALSE, TRUE)/Aij, iix);
+      appendUndoPresolve(lp, FFALSE, get_mat_byindex(lp, ix, FFALSE, TRUE)/Aij, iix);
   }
 }
 
@@ -400,14 +400,14 @@
 
 INLINE void presolve_range(lprec *lp, int rownr, psrec *ps, REAL *loValue, REAL *hiValue)
 {
-  *loValue = presolve_sumplumin(lp, rownr,   ps, FALSE);
+  *loValue = presolve_sumplumin(lp, rownr,   ps, FFALSE);
   *hiValue = presolve_sumplumin(lp, rownr,   ps, TRUE);
 }
 
 STATIC void presolve_rangeorig(lprec *lp, int rownr, psrec *ps, REAL *loValue, REAL *hiValue, REAL delta)
 {
   delta = my_chsign(is_chsign(lp, rownr), lp->presolve_undo->fixed_rhs[rownr] + delta);
-  *loValue = presolve_sumplumin(lp, rownr,   ps, FALSE) + delta;
+  *loValue = presolve_sumplumin(lp, rownr,   ps, FFALSE) + delta;
   *hiValue = presolve_sumplumin(lp, rownr,   ps, TRUE) + delta;
 }
 
@@ -435,17 +435,17 @@
       if(rownr != origrownr)
       report(lp, NORMAL, "        ...           Input row base used for testing was %s\n",
                                                     get_row_name(lp, origrownr));
-      status = FALSE;
+      status = FFALSE;
     }
 
     /* Check the upper bound */
-    value = presolve_sumplumin(lp, rownr, psdata->rows, FALSE);
+    value = presolve_sumplumin(lp, rownr, psdata->rows, FFALSE);
     RHS = get_rh_upper(lp, rownr);
     if(value > RHS+lp->epssolution) {
       contype = get_constr_type(lp, rownr);
       report(lp, NORMAL, "presolve_rowfeasible: Upper bound infeasibility in %s row %s (%g >> %g)\n",
                           get_str_constr_type(lp, contype), get_row_name(lp, rownr), value, RHS);
-      status = FALSE;
+      status = FFALSE;
     }
     if(userowmap)
       rownr = nextActiveLink(psdata->rows->varmap, rownr);
@@ -461,7 +461,7 @@
   MATrec *mat = lp->matA;
   int    colnr, ix, ie, nx, jx, je, *cols, *rows, n;
   int    nz = mat->col_end[lp->columns] - 1;
-  MYBOOL status = FALSE;
+  MYBOOL status = FFALSE;
 
   for(colnr = 1; colnr <= lp->columns; colnr++) {
     rows = psdata->cols->next[colnr];
@@ -774,7 +774,7 @@
 #if 1
     my_roundzero(lp->orig_rhs[rownr], epsvalue);
 #else
-    lp->orig_rhs[rownr] = presolve_roundrhs(lp, lp->orig_rhs[rownr], FALSE);
+    lp->orig_rhs[rownr] = presolve_roundrhs(lp, lp->orig_rhs[rownr], FFALSE);
 #endif
   lp->presolve_undo->fixed_rhs[rownr] += fixdelta;
 }
@@ -792,7 +792,7 @@
     n = list[0];
     for(i = 1; i <= n; i++)
       if(isActiveLink(psdata->rows->varmap, list[i])) {
-        presolve_rowremove(psdata, list[i], FALSE);
+        presolve_rowremove(psdata, list[i], FFALSE);
         countR++;
       }
     if(nConRemove != NULL)
@@ -812,7 +812,7 @@
             status = presolve_setstatus(psdata, INFEASIBLE);
             break;
           }
-          presolve_colremove(psdata, ix, FALSE);
+          presolve_colremove(psdata, ix, FFALSE);
           countC++;
         }
         else if(SOS_is_member(SOS, 0, ix))
@@ -968,7 +968,7 @@
     return( status );
 
   /* Allocate working member list */
-  if(!allocINT(lp, &fixed, lp->columns+1, FALSE) )
+  if(!allocINT(lp, &fixed, lp->columns+1, FFALSE) )
     return( lp->spx_status );
 
   /* Check if we have SOS'es that are already satisfied or fixable/satisfiable */
@@ -1007,7 +1007,7 @@
         }
       }
       /* Remove the SOS */
-      delete_SOSrec(lp->SOS, i /* , FALSE */);
+      delete_SOSrec(lp->SOS, i /* , FFALSE */);
     }
     /* Otherwise, try to fix variables outside the SOS type window */
     else if(fixed[0] > 0) {
@@ -1054,11 +1054,11 @@
   int      i, k, j;
   SOSrec   *SOS;
   REAL     newvalue;
-  MYBOOL   *fixed = NULL, status = FALSE;
+  MYBOOL   *fixed = NULL, status = FFALSE;
 
   /* Allocate working member list */
   if(!allocMYBOOL(lp, &fixed, lp->columns+1, TRUE) )
-    return(FALSE);
+    return(FFALSE);
 
   /* Fix variables in SOS's where colnr is a member */
   i = SOS_count(lp);
@@ -1100,7 +1100,7 @@
     if(SOS_is_member(lp->SOS, i, colnr)) {
       /* Always delete SOS1's */
       if(SOS->type == SOS1)
-        delete_SOSrec(lp->SOS, i /* , FALSE */);
+        delete_SOSrec(lp->SOS, i /* , FFALSE */);
       /* Only delete leading or trailing SOS members in higher-order SOS'es that are fixed at 0;
         (note that this section of the code will never be called in the current setup) */
       else {
@@ -1244,14 +1244,14 @@
   if((reflotest > refuptest + epsvalue) ||
 #endif
      !presolve_singletonbounds(psdata, rownr, colnr, &coeff_bl, &coeff_bu, NULL))
-    return( FALSE );
+    return( FFALSE );
 
   /* Base data is Ok, now check against against each other */
   epsvalue = MAX(reflotest-coeff_bu, coeff_bl-refuptest) / epsvalue;
   if(epsvalue > PRESOLVE_BOUNDSLACK) {
     report(lp, NORMAL, "presolve_altsingletonvalid: Singleton variable %s in row %s infeasible (%g)\n",
                        get_col_name(lp, colnr), get_row_name(lp, rownr), MAX(reflotest-coeff_bu, coeff_bl-refuptest));
-    return( FALSE );
+    return( FFALSE );
   }
   else
     return( TRUE );
@@ -1261,7 +1261,7 @@
                                    REAL *lobound, REAL *upbound, REAL *aval, MYBOOL *rowbinds)
 {
   lprec    *lp = psdata->lp;
-  MYBOOL   rowbindsvar = FALSE, status = FALSE;
+  MYBOOL   rowbindsvar = FFALSE, status = FFALSE;
   REAL     coeff_a, LHS, RHS, netX, Xupper, Xlower, epsvalue = psdata->epsvalue;
 
   /* Get variable bounds for netting */
@@ -1292,7 +1292,7 @@
       LHS -= netX-coeff_a*Xlower;
       LHS /= coeff_a;
       if(LHS < Xupper - epsvalue) {
-        Xupper = presolve_roundrhs(lp, LHS, FALSE);
+        Xupper = presolve_roundrhs(lp, LHS, FFALSE);
         status = AUTOMATIC;
       }
       else if(LHS < Xupper + epsvalue)
@@ -1300,7 +1300,7 @@
     }
   }
 
-  netX = presolve_sumplumin(lp, rownr, psdata->rows, FALSE);
+  netX = presolve_sumplumin(lp, rownr, psdata->rows, FFALSE);
   if(!my_infinite(lp, RHS) && !my_infinite(lp, netX)) {
     if(coeff_a < 0) {
       if(!my_infinite(lp, Xupper)) {
@@ -1318,7 +1318,7 @@
       RHS -= netX-coeff_a*Xlower;
       RHS /= coeff_a;
       if(RHS < Xupper - epsvalue) {
-        Xupper = presolve_roundrhs(lp, RHS, FALSE);
+        Xupper = presolve_roundrhs(lp, RHS, FFALSE);
         status |= AUTOMATIC;
       }
       else if(RHS < Xupper + epsvalue)
@@ -1343,10 +1343,10 @@
 {
   if(psdata->forceupdate) {
     presolve_updatesums(psdata);
-    psdata->forceupdate = FALSE;
+    psdata->forceupdate = FFALSE;
   }
   if(!presolve_rowfeasible(psdata, 0, TRUE))
-    return( FALSE );
+    return( FFALSE );
   else
     return( TRUE );
 }
@@ -1375,7 +1375,7 @@
 #ifdef Paranoia
   if(((LOold > LOnew) && !is_semicont(lp, colnr)) || (UPold < UPnew)) {
     report(lp, SEVERE, "presolve_coltighten: Inconsistent new bounds requested for column %d\n", colnr);
-    return( FALSE );
+    return( FFALSE );
   }
 #endif
   if(count != NULL)
@@ -1487,7 +1487,7 @@
       else {
         report(lp, NORMAL, "presolve_coltighten: Found column %s with LB %g > UB %g\n",
                             get_col_name(lp, colnr), LOnew, UPnew);
-        return( FALSE );
+        return( FFALSE );
       }
     }
     if(lp->spx_trace || (lp->verbose > DETAILED))
@@ -1588,7 +1588,7 @@
 {
   lprec    *lp = psdata->lp;
   int      i, ix, ie;
-  MYBOOL   isneg, lofinite, upfinite, doupdate = FALSE, chsign = is_chsign(lp, rownr);
+  MYBOOL   isneg, lofinite, upfinite, doupdate = FFALSE, chsign = is_chsign(lp, rownr);
   REAL     lobound, upbound, lovalue, upvalue,
            Value, fixvalue, fixprod, mult;
   MATrec   *mat = lp->matA;
@@ -1612,7 +1612,7 @@
     }
     set_dv_bounds(psdata, rownr, fixvalue, fixvalue);
     if(fixvalue != 0)
-      addUndoPresolve(lp, FALSE, rownr, fixvalue, 0, 0);
+      addUndoPresolve(lp, FFALSE, rownr, fixvalue, 0, 0);
     mult = -1;
   }
   else {
@@ -1673,7 +1673,7 @@
     if(isneg) {
       if((ps->negupper[i] < lp->infinite) && lofinite) {
         ps->negupper[i] += mult*lovalue;
-        ps->negupper[i] = presolve_roundrhs(lp, ps->negupper[i], FALSE);
+        ps->negupper[i] = presolve_roundrhs(lp, ps->negupper[i], FFALSE);
       }
       else if(remove && !lofinite)
         doupdate = TRUE;
@@ -1683,7 +1683,7 @@
     else {
       if((ps->pluupper[i] < lp->infinite) && upfinite) {
         ps->pluupper[i] += mult*upvalue;
-        ps->pluupper[i] = presolve_roundrhs(lp, ps->pluupper[i], FALSE);
+        ps->pluupper[i] = presolve_roundrhs(lp, ps->pluupper[i], FFALSE);
       }
       else if(remove && !upfinite)
         doupdate = TRUE;
@@ -1721,7 +1721,7 @@
          (lovalue > Value)) {
         report(lp, IMPORTANT, "presolve: Row %s (%g << %g) infeasibility in column %s (OF=%g)\n",
                               get_row_name(lp, rownr), lovalue, upvalue, get_col_name(lp, i), Value);
-        return( FALSE );
+        return( FFALSE );
       }
     }
   }
@@ -1775,7 +1775,7 @@
 {
   lprec    *lp = psdata->lp;
   int      i, ix, ie;
-  MYBOOL   isneg, lofinite, upfinite, doupdate = FALSE, doOF = TRUE;
+  MYBOOL   isneg, lofinite, upfinite, doupdate = FFALSE, doOF = TRUE;
   REAL     lobound, upbound, lovalue, upvalue,
            Value, fixvalue, mult;
   MATrec   *mat = lp->matA;
@@ -1882,7 +1882,7 @@
     if(isneg) {
       if((ps->negupper[i] < lp->infinite) && lofinite) {
         ps->negupper[i] += mult*lovalue;
-        ps->negupper[i] = presolve_roundrhs(lp, ps->negupper[i], FALSE);
+        ps->negupper[i] = presolve_roundrhs(lp, ps->negupper[i], FFALSE);
       }
       else if(remove && !lofinite)
         doupdate = TRUE;
@@ -1892,7 +1892,7 @@
     else {
       if((ps->pluupper[i] < lp->infinite) && upfinite) {
         ps->pluupper[i] += mult*upvalue;
-        ps->pluupper[i] = presolve_roundrhs(lp, ps->pluupper[i], FALSE);
+        ps->pluupper[i] = presolve_roundrhs(lp, ps->pluupper[i], FFALSE);
       }
       else if(remove && !upfinite)
         doupdate = TRUE;
@@ -1943,13 +1943,13 @@
           report(lp, NORMAL, "presolve_colfix: Variable %s (%g << %g) infeasibility in row %s (%g << %g)\n",
                               get_col_name(lp, colnr), lovalue, upvalue,
                               get_row_name(lp, i), get_rh_lower(lp,i), get_rh_upper(lp, i));
-          return( FALSE );
+          return( FFALSE );
         }
       }
     }
 BlockEnd:
     if(doOF) {
-      doOF = FALSE;
+      doOF = FFALSE;
       if(ix < ie)
         goto Restart;
     }
@@ -2001,7 +2001,7 @@
   if(((loX < 0) && (upX > 0)) ||
      (fabs(upX-loX) < lp->epsvalue) ||
      SOS_is_member_of_type(lp->SOS, colnr, SOSn))
-    return( FALSE );
+    return( FFALSE );
   isMI = (MYBOOL) (upX <= 0);
 
   /* Retrieve OF (standard form assuming maximization) */
@@ -2027,18 +2027,18 @@
            upR = get_rh_upper(lp, i);
       if(!presolve_singletonbounds(psdata, i, colnr, &loR, &upR, &val)) {
         *status = presolve_setstatus(psdata, INFEASIBLE);
-        return( FALSE );
+        return( FFALSE );
       }
       if(loR > loX + psdata->epsvalue)
         loX = presolve_roundrhs(lp, loR, TRUE);
       if(upR < upX - psdata->epsvalue)
-        upX = presolve_roundrhs(lp, upR, FALSE);
+        upX = presolve_roundrhs(lp, upR, FFALSE);
       continue;
     }
     else
       isDualFREE = my_infinite(lp, get_rh_range(lp, i)) ||                                          /* Explicitly free */
                    ((presolve_sumplumin(lp, i, psdata->rows, TRUE)-eps <= get_rh_upper(lp, i)) &&   /* Implicitly free */
-                    (presolve_sumplumin(lp, i, psdata->rows, FALSE)+eps >= get_rh_lower(lp, i)));
+                    (presolve_sumplumin(lp, i, psdata->rows, FFALSE)+eps >= get_rh_lower(lp, i)));
     if(isDualFREE) {
       if(signOF == 0)  /* Test on the basis of identical signs in the constraints */
         signOF = my_sign(*value);
@@ -2055,7 +2055,7 @@
     }
     else if(signOF > 0) {
       if(my_infinite(lp, loX))
-        isDualFREE = FALSE;
+        isDualFREE = FFALSE;
       else {
         if(is_int(lp, colnr))
           *fixValue = ceil(loX-PRESOLVE_EPSVALUE);
@@ -2065,7 +2065,7 @@
     }
     else {
       if(my_infinite(lp, upX))
-        isDualFREE = FALSE;
+        isDualFREE = FFALSE;
       else {
         if(is_int(lp, colnr) && (upX != 0))
           *fixValue = floor(upX+PRESOLVE_EPSVALUE);
@@ -2074,7 +2074,7 @@
       }
     }
     if((*fixValue != 0) && SOS_is_member(lp->SOS, 0, colnr))
-      return( FALSE );
+      return( FFALSE );
 
   }
 
@@ -2088,7 +2088,7 @@
   int      i, ix, item;
   REAL     loLim, absvalue, epsvalue = psdata->epsvalue;
   MATrec   *mat = lp->matA;
-  MYBOOL   chsign, canfix = FALSE;
+  MYBOOL   chsign, canfix = FFALSE;
 
   if(!is_binary(lp, colnr))
     return( canfix );
@@ -2134,7 +2134,7 @@
   int      i, ix, item;
   REAL     loLim, upLim, range, absvalue, epsvalue = psdata->epsvalue, tolgap;
   MATrec   *mat = lp->matA;
-  MYBOOL   chsign, status = FALSE;
+  MYBOOL   chsign, status = FFALSE;
 
   if(!is_binary(lp, colnr))
     return( status );
@@ -2153,7 +2153,7 @@
     chsign = is_chsign(lp, i);
 
     /* Get the constraint value limits based on variable bounds, normalized to LE constraint */
-    loLim = presolve_sumplumin(lp, i, psdata->rows, FALSE);
+    loLim = presolve_sumplumin(lp, i, psdata->rows, FFALSE);
     upLim = presolve_sumplumin(lp, i, psdata->rows, TRUE);
     if(chsign) {
       loLim = my_chsign(chsign, loLim);
@@ -2278,7 +2278,7 @@
     firstix = ix;
     for(RT1 = 0; (ix > 0) && (RT1 < RT2) && (status == RUNNING);
         ix = prevActiveLink(psdata->rows->varmap, ix), RT1++)  {
-      candelete = FALSE;
+      candelete = FFALSE;
       if(presolve_rowlength(psdata, ix) != j)
         continue;
 
@@ -2292,8 +2292,8 @@
         continue;
 
       /* We have a candidate row; check if the entries have a fixed non-zero ratio */
-      Value1 = get_mat_byindex(lp, iix, TRUE, FALSE);
-      Value2 = get_mat_byindex(lp, jjx, TRUE, FALSE);
+      Value1 = get_mat_byindex(lp, iix, TRUE, FFALSE);
+      Value2 = get_mat_byindex(lp, jjx, TRUE, FFALSE);
       bound = Value1 / Value2;
       Value1 = bound;
 
@@ -2304,8 +2304,8 @@
         iix = presolve_nextcol(psdata, ix, &item1);
         if(ROW_MAT_COLNR(iix) != ROW_MAT_COLNR(jjx))
           break;
-        Value1 = get_mat_byindex(lp, iix, TRUE, FALSE);
-        Value2 = get_mat_byindex(lp, jjx, TRUE, FALSE);
+        Value1 = get_mat_byindex(lp, iix, TRUE, FFALSE);
+        Value2 = get_mat_byindex(lp, jjx, TRUE, FFALSE);
 
         /* If the ratio is different from the reference value we have a mismatch */
         Value1 = Value1 / Value2;
@@ -2431,7 +2431,7 @@
       Rvalue = fabs(lp->orig_rhs[i]-Rvalue);
       if(is_constr_type(lp, i, EQ) && (Rvalue > epsvalue)) {
         report(lp, NORMAL, "presolve_reduceGCD: Infeasible equality constraint %d\n", i);
-        status = FALSE;
+        status = FFALSE;
         break;
       }
       if(!my_infinite(lp, lp->orig_upbo[i]))
@@ -2464,8 +2464,8 @@
     return( status );
 
   /* Get the OF row */
-  allocINT(lp, &rownr,  map->count+1, FALSE);
-  allocREAL(lp, &ratio, map->count+1, FALSE);
+  allocINT(lp, &rownr,  map->count+1, FFALSE);
+  allocREAL(lp, &ratio, map->count+1, FFALSE);
 
   /* Loop over each row trying to find equal entries in the OF */
   rownr[0] = 0;
@@ -2543,7 +2543,7 @@
 {
   int    jx, jjx, i = 0, item;
   MATrec *mat = lp->matA;
-  MYBOOL error = FALSE;
+  MYBOOL error = FFALSE;
 
   do {
 
@@ -2608,8 +2608,8 @@
 
   /* Create condensed row map */
   allocINT(lp, &rmapin, lp->rows+1, TRUE);
-  allocINT(lp, &rmapout, psdata->EQmap->count+1, FALSE);
-  allocINT(lp, &cmapout, lp->columns+1, FALSE);
+  allocINT(lp, &rmapout, psdata->EQmap->count+1, FFALSE);
+  allocINT(lp, &cmapout, lp->columns+1, FFALSE);
   n = 0;
   for(i = firstActiveLink(psdata->EQmap); i != 0; i = nextActiveLink(psdata->EQmap, i)) {
     n++;
@@ -2666,8 +2666,8 @@
 
   /* Tally counts */
   createLink(lp->rows, &EQ2, NULL);
-  if((EQ2 == NULL) || !allocREAL(lp, &colvalue, nrows+1, FALSE) ||
-                      !allocREAL(lp, &delvalue, nrows+1, FALSE))
+  if((EQ2 == NULL) || !allocREAL(lp, &colvalue, nrows+1, FFALSE) ||
+                      !allocREAL(lp, &delvalue, nrows+1, FFALSE))
     goto Finish;
   for(i = firstActiveLink(psdata->EQmap); i > 0; i = nextActiveLink(psdata->EQmap, i)) {
     if(presolve_rowlength(psdata, i) == 2)
@@ -2785,11 +2785,11 @@
     if(freshupdate)
       mat_expandcolumn(mat, jjx, colvalue, NULL, TRUE);
     else
-      mat_expandcolumn(rev, colindex[jjx], colvalue, NULL, FALSE);
+      mat_expandcolumn(rev, colindex[jjx], colvalue, NULL, FFALSE);
     if((colindex == NULL) || (colindex[jx] == 0))
       mat_expandcolumn(mat, jx, delvalue, NULL, TRUE);
     else
-      mat_expandcolumn(rev, colindex[jx], delvalue, NULL, FALSE);
+      mat_expandcolumn(rev, colindex[jx], delvalue, NULL, FFALSE);
 
     /* Add variable reconstruction information */
     addUndoPresolve(lp, TRUE, jx, Value1, Value2, jjx);
@@ -2807,7 +2807,7 @@
           if(is_int(lp, jjx))
             lp->orig_upbo[k] = floor(bound + lp->epsint);
           else
-            lp->orig_upbo[k] = presolve_roundrhs(lp, bound, FALSE);
+            lp->orig_upbo[k] = presolve_roundrhs(lp, bound, FFALSE);
         }
       }
       else {
@@ -2829,7 +2829,7 @@
           if(is_int(lp, jjx))
             lp->orig_upbo[k] = floor(bound + lp->epsint);
           else
-            lp->orig_upbo[k] = presolve_roundrhs(lp, bound, FALSE);
+            lp->orig_upbo[k] = presolve_roundrhs(lp, bound, FFALSE);
         }
       }
       else {
@@ -2950,12 +2950,12 @@
       DV = createUndoLadder(lp, nrows, lp->columns / RESIZEFACTOR);
       rev = DV->tracker;
       rev->epsvalue = mat->epsvalue;
-      allocINT(lp, &(rev->col_tag), mat->columns_alloc+1, FALSE);
+      allocINT(lp, &(rev->col_tag), mat->columns_alloc+1, FFALSE);
       allocINT(lp, &colindex, lp->columns+1, TRUE);
       rev->col_tag[0] = 0;
     }
     n = rev->col_tag[0] = incrementUndoLadder(DV);
-    mat_setcol(rev, n, 0, colvalue, NULL, FALSE, FALSE);
+    mat_setcol(rev, n, 0, colvalue, NULL, FFALSE, FFALSE);
     rev->col_tag[n] = jjx;
 
     /* Save index to updated vector, but specially handle case where we have
@@ -2965,7 +2965,7 @@
     colindex[jjx] = n;
 
     /* Delete the column dependent variable */
-    jx = presolve_colremove(psdata, jx, FALSE);
+    jx = presolve_colremove(psdata, jx, FFALSE);
     iVarsFixed++;
 
     /* Check if we have been lucky enough to have eliminated the independent
@@ -2976,11 +2976,11 @@
                          jx, jjx, get_row_name(lp, i));
 #endif
       if(presolve_colfix(psdata, jjx, 0.0, TRUE, nc))
-        jjx = presolve_colremove(psdata, jjx, FALSE);
+        jjx = presolve_colremove(psdata, jjx, FFALSE);
     }
 
     /* Delete the row */
-    presolve_rowremove(psdata, i, FALSE);
+    presolve_rowremove(psdata, i, FFALSE);
     iRowsRemoved++;
   }
 
@@ -2989,7 +2989,7 @@
     mat_mapreplace(mat, psdata->rows->varmap, psdata->cols->varmap, rev);
     presolve_validate(psdata, TRUE);
 #ifdef PresolveForceUpdateMax
-    mat_computemax(mat /* , FALSE */);
+    mat_computemax(mat /* , FFALSE */);
 #endif
     psdata->forceupdate = TRUE;
   }
@@ -3016,7 +3016,7 @@
 {
   int    i, ix, ie;
   REAL   Tlower, Tupper;
-  MYBOOL status, rowbinds, isfree = FALSE;
+  MYBOOL status, rowbinds, isfree = FFALSE;
   MATrec *mat = lp->matA;
 
   if(my_infinite(lp, get_lowbo(lp, colnr)) && my_infinite(lp, get_upbo(lp, colnr)))
@@ -3039,7 +3039,7 @@
 STATIC MYBOOL presolve_impliedcolfix(presolverec *psdata, int rownr, int colnr, MYBOOL isfree)
 {
   lprec    *lp = psdata->lp;
-  MYBOOL   signflip, undoadded = FALSE;
+  MYBOOL   signflip, undoadded = FFALSE;
   MATrec   *mat = lp->matA;
   int      jx, i, ib, ie = mat->row_end[rownr];
   REAL     varLo = 0, varHi = 0, varRange, conRange = 0, matValue = 0, dual, RHS = lp->orig_rhs[rownr],
@@ -3047,10 +3047,10 @@
 
   /* We cannot have semi-continuous or non-qualifying integers */
   if(is_semicont(lp, colnr) || is_SOS_var(lp, colnr))
-    return( FALSE );
+    return( FFALSE );
   if(is_int(lp, colnr)) {
     if(!isActiveLink(psdata->INTmap, rownr) || !is_presolve(lp, PRESOLVE_KNAPSACK))
-      return( FALSE );
+      return( FFALSE );
     /* colnr must have a coefficient equal to the smallest in the row */
     varRange = lp->infinite;
     i = 0;
@@ -3069,21 +3069,21 @@
       /* Cannot accept case where result can be fractional */
       else if((pivot > dual + psdata->epsvalue) ||
                ((pivot > 0) && (fabs(fmod(dual, pivot)) > psdata->epsvalue)))
-        return( FALSE );
+        return( FFALSE );
     }
   }
 
   /* Ascertain that the pivot value is large enough to preserve stability */
   pivot = matAij;
   if(fabs(pivot) < psdata->epspivot*mat->colmax[colnr])
-    return( FALSE );
+    return( FFALSE );
 
   /* Must ascertain that the row variables are not SOS'es; this is because
      the eliminated variable will be a function of another variable. */
   if(SOS_count(lp) > 0) {
     for(ib = mat->row_end[rownr-1]; ib < ie; ib++)
       if(SOS_is_member(lp->SOS, 0, ROW_MAT_COLNR(ib)))
-        return( FALSE );
+        return( FFALSE );
   }
 
   /* Calculate the dual value */
@@ -3107,7 +3107,7 @@
                    non-infinite. */
     if(isfree) {
       SETMIN(RHS, presolve_sumplumin(lp, rownr, psdata->rows, TRUE));
-      matValue = presolve_sumplumin(lp, rownr, psdata->rows, FALSE);
+      matValue = presolve_sumplumin(lp, rownr, psdata->rows, FFALSE);
       conRange = get_rh_lower(lp, rownr);
       conRange = RHS - MAX(matValue, conRange);
       signflip = (MYBOOL) ((dual > 0) &&
@@ -3156,7 +3156,7 @@
         undoadded = addUndoPresolve(lp, TRUE, colnr, matValue, 0.0, 0);
       /* Add undo information for the dual of the deleted constraint */
       if(dual != 0)
-        addUndoPresolve(lp, FALSE, rownr, dual, 0.0, 0);
+        addUndoPresolve(lp, FFALSE, rownr, dual, 0.0, 0);
     }
 
     /* Prepare for deleting implied slack variable.  The following two cases are
@@ -3256,14 +3256,14 @@
 
   size++;
 
-  allocINT(lp, &ps->empty, size, FALSE);
+  allocINT(lp, &ps->empty, size, FFALSE);
   ps->empty[0] = 0;
 
-  allocREAL(lp, &ps->pluupper,  size, FALSE);
-  allocREAL(lp, &ps->negupper,  size, FALSE);
-  allocREAL(lp, &ps->plulower,  size, FALSE);
-  allocREAL(lp, &ps->neglower,  size, FALSE);
-  allocINT(lp,  &ps->infcount,  size, FALSE);
+  allocREAL(lp, &ps->pluupper,  size, FFALSE);
+  allocREAL(lp, &ps->negupper,  size, FFALSE);
+  allocREAL(lp, &ps->plulower,  size, FFALSE);
+  allocREAL(lp, &ps->neglower,  size, FFALSE);
+  allocINT(lp,  &ps->infcount,  size, FFALSE);
 
   ps->next = (int **) calloc(size, sizeof(*(ps->next)));
 
@@ -3329,14 +3329,14 @@
 
   /* Save incoming primal bounds */
   k = lp->sum + 1;
-  allocREAL(lp, &psdata->pv_lobo, k, FALSE);
+  allocREAL(lp, &psdata->pv_lobo, k, FFALSE);
   MEMCOPY(psdata->pv_lobo, lp->orig_lowbo, k);
-  allocREAL(lp, &psdata->pv_upbo, k, FALSE);
+  allocREAL(lp, &psdata->pv_upbo, k, FFALSE);
   MEMCOPY(psdata->pv_upbo, lp->orig_upbo, k);
 
   /* Create and initialize dual value (Langrangean and slack) limits */
-  allocREAL(lp, &psdata->dv_lobo, k, FALSE);
-  allocREAL(lp, &psdata->dv_upbo, k, FALSE);
+  allocREAL(lp, &psdata->dv_lobo, k, FFALSE);
+  allocREAL(lp, &psdata->dv_upbo, k, FFALSE);
   for(i = 0; i <= nrows; i++) {
     psdata->dv_lobo[i] = (is_constr_type(lp, i, EQ) ? -lp->infinite : 0);
     psdata->dv_upbo[i] = lp->infinite;
@@ -3516,7 +3516,7 @@
   /* Loop over active columns */
   for(j = firstActiveLink(psdata->cols->varmap); j != 0;
       j = nextActiveLink(psdata->cols->varmap, j)) {
-    presolve_colfix(psdata, j, lp->infinite, FALSE, NULL);
+    presolve_colfix(psdata, j, lp->infinite, FFALSE, NULL);
   }
 
 #ifdef UseDualPresolve
@@ -3530,7 +3530,7 @@
   /* Loop over active rows */
   for(j = firstActiveLink(psdata->rows->varmap); j != 0;
       j = nextActiveLink(psdata->rows->varmap, j)) {
-    presolve_rowfix(psdata, j, lp->infinite, FALSE, NULL);
+    presolve_rowfix(psdata, j, lp->infinite, FFALSE, NULL);
   }
 #endif
 
@@ -3540,7 +3540,7 @@
 STATIC MYBOOL presolve_finalize(presolverec *psdata)
 {
   lprec    *lp = psdata->lp;
-  MYBOOL   compactvars = FALSE;
+  MYBOOL   compactvars = FFALSE;
   int      ke, n;
 
   /* Save eliminated rows and columns for restoration purposes */
@@ -3551,7 +3551,7 @@
 #endif
 
   /* Check if OF columns are to be deleted */
-  lp->presolve_undo->OFcolsdeleted = FALSE;
+  lp->presolve_undo->OFcolsdeleted = FFALSE;
   for(n = firstInactiveLink(psdata->cols->varmap); (n != 0) && !lp->presolve_undo->OFcolsdeleted;
       n = nextInactiveLink(psdata->cols->varmap, n))
     lp->presolve_undo->OFcolsdeleted = (MYBOOL) (lp->orig_obj[n] != 0);
@@ -3752,7 +3752,7 @@
   /* Let us start from the top of the list, going forward and looking
     for the longest possible dominating row */
   if(!allocREAL(lp, &rowvalues, lp->columns + 1, TRUE) ||
-     !allocINT(lp, &coldel, lp->columns + 1, FALSE))
+     !allocINT(lp, &coldel, lp->columns + 1, FFALSE))
     goto Finish;
 
   for(ib = 0; ib < n; ib++) {
@@ -3946,7 +3946,7 @@
   /* Let us start from the top of the list, going forward and looking
     for the longest possible dominated column */
   if(!allocREAL(lp, &colvalues, lp->rows + 1, TRUE) ||
-     !allocINT(lp, &coldel, lp->columns + 1, FALSE))
+     !allocINT(lp, &coldel, lp->columns + 1, FFALSE))
     goto Finish;
 
   for(ib = 0; ib < n; ib++) {
@@ -4151,8 +4151,8 @@
   /* Let us start from the top of the list, going forward and looking
     for the longest possible dominated column */
   if(!allocREAL(lp, &colvalues, nrows + 1, TRUE) ||
-     !allocREAL(lp, &colobj, n + 1, FALSE) ||
-     !allocINT(lp, &coldel, n + 1, FALSE))
+     !allocREAL(lp, &colobj, n + 1, FFALSE) ||
+     !allocINT(lp, &coldel, n + 1, FFALSE))
     goto Finish;
 
   for(ib = 0; ib < n; ib++) {
@@ -4227,7 +4227,7 @@
 
     /* Find the dominant columns, fix and delete the others */
     if(coldel[0] > 1) {
-      qsortex(colobj+1, coldel[0], 0, sizeof(*colobj), FALSE, compareREAL, coldel+1, sizeof(*coldel));
+      qsortex(colobj+1, coldel[0], 0, sizeof(*colobj), FFALSE, compareREAL, coldel+1, sizeof(*coldel));
       /* if(rhsval+lp->epsvalue < lp->infinite) { */
         jb = (NATURAL) (rhsval+lp->epsvalue);
         /* printf("%f / %d\n", rhsval, jb); */
@@ -4301,7 +4301,7 @@
   /* Let us start from the top of the list, going forward and looking
     for the longest possible identical column */
   if(!allocREAL(lp, &colvalues, lp->rows + 1, TRUE) ||
-     !allocINT(lp, &coldel, lp->columns + 1, FALSE))
+     !allocINT(lp, &coldel, lp->columns + 1, FFALSE))
     goto Finish;
 
   for(ib = 0; ib < n; ib++) {
@@ -4524,7 +4524,7 @@
 
   /* Create associated sorted map of indeces to equality constraints;
      note that we need to have a unit offset for compatibility. */
-  allocINT(lp, &nzidx, lp->columns + 1, FALSE);
+  allocINT(lp, &nzidx, lp->columns + 1, FFALSE);
   createLink(lp->rows, &EQlist, NULL);
   for(ib = 0; ib < n; ib++) {
     i = QS[ib].int4.intval;
@@ -4741,11 +4741,11 @@
 
   /* Let us condense the matrix if we modified the constraint matrix */
   if(iCoeffChanged > 0) {
-    mat->row_end_valid = FALSE;
+    mat->row_end_valid = FFALSE;
     mat_zerocompact(mat);
     presolve_validate(psdata, TRUE);
 #ifdef PresolveForceUpdateMax
-    mat_computemax(mat /* , FALSE */);
+    mat_computemax(mat /* , FFALSE */);
 #endif
     psdata->forceupdate = TRUE;
   }
@@ -4760,14 +4760,14 @@
 STATIC int presolve_SOS1(presolverec *psdata, int *nCoeffChanged, int *nConRemove, int *nVarFixed, int *nSOS, int *nSum)
 {
   lprec    *lp = psdata->lp;
-  MYBOOL   candelete, SOS_GUBactive = FALSE;
+  MYBOOL   candelete, SOS_GUBactive = FFALSE;
   int      iCoeffChanged = 0, iConRemove = 0, iSOS = 0,
            i,ix,iix, j,jx,jjx, status = RUNNING;
   REAL     Value1;
   MATrec   *mat = lp->matA;
 
   for(i = lastActiveLink(psdata->rows->varmap); i > 0; ) {
-    candelete = FALSE;
+    candelete = FFALSE;
     Value1 = get_rh(lp, i);
     jx = get_constr_type(lp, i);
     if((Value1 == 1) && (presolve_rowlength(psdata, i) >= MIN_SOS1LENGTH) &&
@@ -4889,9 +4889,9 @@
 
     /* Clear unnecessary semicont-definitions */
     if((lp->sc_vars > 0) && (Value1 == 0) && is_semicont(lp, j))
-      set_semicont(lp, j, FALSE);
+      set_semicont(lp, j, FFALSE);
 
-    candelete = FALSE;
+    candelete = FFALSE;
     item = 0;
     ix = lp->rows + j;
 
@@ -5079,7 +5079,7 @@
     else if(impliedslack &&
              (countNZ > 1) &&
              is_constr_type(lp, i, EQ) &&
-             presolve_impliedcolfix(psdata, i, j, FALSE)) {
+             presolve_impliedcolfix(psdata, i, j, FFALSE)) {
       report(lp, DETAILED, "presolve_freeandslacks: Eliminated implied slack variable %s via row %s\n",
                             get_col_name(lp, j), get_row_name(lp, i));
       psdata->forceupdate = TRUE;
@@ -5120,7 +5120,7 @@
           }
           else {
             *target += ValueA * coeff_bu;
-            *target = presolve_roundrhs(lp, *target, FALSE);
+            *target = presolve_roundrhs(lp, *target, FFALSE);
           }
         }
       }
@@ -5144,7 +5144,7 @@
         }
         else {
           *target -= ValueA * coeff_bu;
-          *target = presolve_roundrhs(lp, *target, FALSE);
+          *target = presolve_roundrhs(lp, *target, FFALSE);
         }
       }
       presolve_colfix(psdata, j, coeff_bl, TRUE, &iVarFixed);
@@ -5182,7 +5182,7 @@
 #ifdef Paranoia
     if(!presolve_testrow(psdata, nextActiveLink(psdata->rows->varmap, i))) {
 #else
-    if((j > 1) && !psdata->forceupdate && !presolve_rowfeasible(psdata, i, FALSE)) {
+    if((j > 1) && !psdata->forceupdate && !presolve_rowfeasible(psdata, i, FFALSE)) {
 #endif
       status = presolve_setstatus(psdata, INFEASIBLE);
       break;
@@ -5209,7 +5209,7 @@
         iRangeTighten++;
       }
       if(upsum < uprhs-epsvalue) {
-        set_rh_upper(lp, i, presolve_roundrhs(lp, upsum, FALSE));
+        set_rh_upper(lp, i, presolve_roundrhs(lp, upsum, FFALSE));
         iRangeTighten++;
       }
     }
@@ -5218,7 +5218,7 @@
     if(tightenbounds && mat_validate(mat)) {
 #if 1
       if(j > 1)
-        status = presolve_rowtighten(psdata, i, &iBoundTighten, FALSE);
+        status = presolve_rowtighten(psdata, i, &iBoundTighten, FFALSE);
 #else
       if((MIP_count(lp) > 0) && (j > 1))
         status = presolve_rowtighten(psdata, i, &iBoundTighten, TRUE);
@@ -5250,14 +5250,14 @@
 
   for(i = lastActiveLink(psdata->rows->varmap); (i > 0) && (status == RUNNING); ) {
 
-    candelete = FALSE;
+    candelete = FFALSE;
 
    /* First identify any full row infeasibilities
       Note: Handle singletons below to ensure that conflicting multiple singleton
             rows with this variable do not provoke notice of infeasibility */
     j = presolve_rowlengthex(psdata, i);
     if((j > 1) &&
-       !psdata->forceupdate && !presolve_rowfeasible(psdata, i, FALSE)) {
+       !psdata->forceupdate && !presolve_rowfeasible(psdata, i, FFALSE)) {
       status = presolve_setstatus(psdata, INFEASIBLE);
       break;
     }
@@ -5305,7 +5305,7 @@
       /* Proceed to fix and remove variable (if it is not a SOS member) */
       if(status == RUNNING) {
         if((fabs(Value2-Value1) < epsvalue) && (fabs(Value2) > epsvalue)) {
-          MYBOOL isSOS     = (MYBOOL) (SOS_is_member(lp->SOS, 0, j) != FALSE),
+          MYBOOL isSOS     = (MYBOOL) (SOS_is_member(lp->SOS, 0, j) != FFALSE),
                  deleteSOS = isSOS && presolve_candeletevar(psdata, j);
           if((Value1 != 0) && deleteSOS) {
             if(!presolve_fixSOS1(psdata, j, Value1, &iConRemove, &iVarFixed))
@@ -5466,7 +5466,7 @@
 #endif
 
   /* Update inf norms and check for potential factorization trouble */
-  mat_computemax(mat /*, FALSE */);
+  mat_computemax(mat /*, FFALSE */);
 #if 0
   Value1 = fabs(lp->negrange);
   if(is_obj_in_basis(lp) && (mat->dynrange < Value1) && vec_computeext(lp->orig_obj, 1, lp->columns, TRUE, &i, &j)) {
@@ -5542,7 +5542,7 @@
         /* Accumulate constraint bounds based on bounds on individual variables. */
         j = 0;
         while(presolve_statuscheck(psdata, &status) && psdata->forceupdate) {
-          psdata->forceupdate = FALSE;
+          psdata->forceupdate = FFALSE;
           /* Update sums, but limit iteration count to avoid possible
             "endless" loops with only marginal bound improvements */
           if(presolve_updatesums(psdata) && (j < MAX_PSBOUNDTIGHTENLOOPS)) {
@@ -5627,7 +5627,7 @@
       if(presolve_statuscheck(psdata, &status) && (psdata->EQmap->count > 1) &&
          is_presolve(lp, PRESOLVE_LINDEP)) {
 #if 0
-        REPORT_mat_mmsave(lp, "A.mtx", NULL, FALSE, "Constraint matrix A");
+        REPORT_mat_mmsave(lp, "A.mtx", NULL, FFALSE, "Constraint matrix A");
 #endif
         presolve_singularities(psdata, &iCoeffChanged, &iConRemove, &iVarFixed, &iSum);
       }
@@ -5823,7 +5823,7 @@
 
     /* Produce presolved model statistics */
     if(nConRemove+nVarFixed+nBoundTighten+nVarFixed+nCoeffChanged > 0) {
-      REPORT_modelinfo(lp, FALSE, "REDUCED");
+      REPORT_modelinfo(lp, FFALSE, "REDUCED");
       if(nSum > 0) {
         report(lp, NORMAL, "Row-types:   %7d LE,          %7d GE,             %7d EQ.\n",
                            j, jjx, jx);
@@ -5848,7 +5848,7 @@
   write_lp(lp, "test_out.lp");   /* Must put here due to variable name mapping */
 #endif
 #if 0
-  REPORT_debugdump(lp, "testint2.txt", FALSE);
+  REPORT_debugdump(lp, "testint2.txt", FFALSE);
 #endif
 
   return( status );
@@ -5888,9 +5888,9 @@
 
   /* Check if we can clear the variable map */
   if(varmap_canunlock(lp))
-    lp->varmap_locked = FALSE;
+    lp->varmap_locked = FFALSE;
 #if 0
-  REPORT_mat_mmsave(lp, "basis.mtx", NULL, FALSE);  /* Write the current basis matrix (no OF) */
+  REPORT_mat_mmsave(lp, "basis.mtx", NULL, FFALSE);  /* Write the current basis matrix (no OF) */
 #endif
 
   return( TRUE );
diff -ru lp_solve_5.5.orig/lp_price.c lp_solve_5.5/lp_price.c
--- lp_solve_5.5.orig/lp_price.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_price.c	2019-02-19 12:01:35.652868617 -0600
@@ -388,7 +388,7 @@
 
 #ifdef Paranoia
   if(candidate->varno <= 0)
-    return( FALSE );
+    return( FFALSE );
   else
 #endif
   if(fabs(candidate->pivot) >= lp->infinite)
@@ -501,7 +501,7 @@
 
    Allowed variable set: Any pivot PRIMAL:larger or DUAL:smaller than threshold value of 0 */
 {
-  MYBOOL Action = FALSE,
+  MYBOOL Action = FFALSE,
 #ifdef ExtractedValidityTest
          Accept = TRUE;
 #else    /* Check for validity and compare result with previous best */
@@ -511,7 +511,7 @@
     if(candidatecount != NULL)
       (*candidatecount)++;
     if(collectMP) {
-      if(addCandidateVar(candidate, current->lp->multivars, (findCompare_func *) compareImprovementQS, FALSE) < 0)
+      if(addCandidateVar(candidate, current->lp->multivars, (findCompare_func *) compareImprovementQS, FFALSE) < 0)
         return(Action);
     }
     if(current->varno > 0)
@@ -537,7 +537,7 @@
   /* 1. Check for ratio and pivot validity (to have the extra flexibility that all
         bound-flip candidates are also possible as basis-entering variables */
   if(!validSubstitutionVar(candidate))
-    return( FALSE );
+    return( FFALSE );
 
   /* 2. If the free-list is empty we need to see if we have a better candidate,
         and for this the candidate list has to be sorted by merit */
@@ -572,7 +572,7 @@
 
    Allowed variable set: "Equal-valued" smallest thetas! */
 {
-  MYBOOL Action = FALSE,
+  MYBOOL Action = FFALSE,
 #ifdef ExtractedValidityTest
          Accept = TRUE;
 #else  /* Check for validity and comparison result with previous best */
@@ -653,7 +653,7 @@
   }
   else {
     *delta = 1;  /* Step forwards - "right" */
-    lp->_piv_left_ = FALSE;
+    lp->_piv_left_ = FFALSE;
   }
 }
 
@@ -788,7 +788,7 @@
       idea is to relax the tolerance to account for this and only
       marginally weakening the (user-specified) tolerance. */
     if((sfeas-xfeas) < f*lp->epsprimal)
-      testOK = FALSE;
+      testOK = FFALSE;
   }
   return( testOK );
 }
@@ -835,7 +835,7 @@
   int      i, ix, iy, iz, ninfeas, nloop = 0;
   REAL     f, sinfeas, xinfeas, epsvalue = lp->epsdual;
   pricerec current, candidate;
-  MYBOOL   collectMP = FALSE;
+  MYBOOL   collectMP = FFALSE;
   int      *coltarget = NULL;
 
   /* Identify pivot column according to pricing strategy; set
@@ -843,9 +843,9 @@
   current.pivot    = lp->epsprimal;    /* Minimum acceptable improvement */
   current.varno    = 0;
   current.lp       = lp;
-  current.isdual   = FALSE;
+  current.isdual   = FFALSE;
   candidate.lp     = lp;
-  candidate.isdual = FALSE;
+  candidate.isdual = FFALSE;
   *candidatecount  = 0;
 
   /* Update local value of pivot setting and determine active multiple pricing set */
@@ -859,7 +859,7 @@
       coltarget = NULL;
     }
     else
-      coltarget = multi_indexSet(lp->multivars, FALSE);
+      coltarget = multi_indexSet(lp->multivars, FFALSE);
   }
 
   /* Compute reduced costs c - c*Inv(B), if necessary
@@ -869,7 +869,7 @@
     /* Recompute from scratch only at the beginning, otherwise update */
     if((lp->current_iter > 0) && (refactRecent(lp) == AUTOMATIC))
 #endif
-    compute_reducedcosts(lp, FALSE, 0, coltarget, (MYBOOL) ((nloop <= 1) || (partialloop > 1)),
+    compute_reducedcosts(lp, FFALSE, 0, coltarget, (MYBOOL) ((nloop <= 1) || (partialloop > 1)),
                              NULL, NULL,
                              drow, nzdrow,
                              MAT_ROUNDDEFAULT);
@@ -908,7 +908,7 @@
     ninfeas++;
     SETMAX(xinfeas, f);
     sinfeas += f;
-    candidate.pivot = normalizeEdge(lp, i, f, FALSE);
+    candidate.pivot = normalizeEdge(lp, i, f, FFALSE);
     candidate.varno = i;
     if(findImprovementVar(&current, &candidate, collectMP, candidatecount))
       break;
@@ -923,8 +923,8 @@
       coltarget = multi_indexSet(lp->multivars, TRUE);
     }
     else if((current.varno == 0) && (lp->multivars->retries == 0)) {
-      ix = partial_blockStart(lp, FALSE);
-      iy = partial_blockEnd(lp, FALSE);
+      ix = partial_blockStart(lp, FFALSE);
+      iy = partial_blockEnd(lp, FFALSE);
       lp->multivars->used = 0;
       lp->multivars->retries++;
       goto doLoop;
@@ -963,7 +963,7 @@
   LREAL    f, savef;
   REAL     Heps, Htheta, Hlimit, epsvalue, epspivot, p = 0.0;
   pricerec current, candidate;
-  MYBOOL   isupper = !lp->is_lower[colnr], HarrisTwoPass = FALSE;
+  MYBOOL   isupper = !lp->is_lower[colnr], HarrisTwoPass = FFALSE;
 
   /* Update local value of pivot setting */
   lp->_piv_rule_ = get_piv_rule(lp);
@@ -1039,11 +1039,11 @@
   current.theta    = lp->infinite;
   current.pivot    = 0;
   current.varno    = 0;
-  current.isdual   = FALSE;
+  current.isdual   = FFALSE;
   current.epspivot = epspivot;
   current.lp       = lp;
   candidate.epspivot = epspivot;
-  candidate.isdual = FALSE;
+  candidate.isdual = FFALSE;
   candidate.lp     = lp;
   savef  = 0;
   for(; Hpass <= 2; Hpass++) {
@@ -1133,7 +1133,7 @@
         i++;
       if(i > lp->rows) { /* Empty column with upper bound! */
         lp->is_lower[colnr] = !lp->is_lower[colnr];
-/*        lp->is_lower[colnr] = FALSE; */
+/*        lp->is_lower[colnr] = FFALSE; */
         lp->rhs[0] += lp->upbo[colnr]*pcol[0];
       }
       else /* if(pcol[i]<0) */
@@ -1151,7 +1151,7 @@
 
  /* Return working array to pool */
   if(nzpcol == NULL)
-    mempool_releaseVector(lp->workarrays, (char *) nzlist, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) nzlist, FFALSE);
 
   if(lp->spx_trace)
     report(lp, DETAILED, "row_prim: %d, pivot size = " RESULTVALUEMASK "\n",
@@ -1172,7 +1172,7 @@
   REAL      up, lo = 0,
             epsvalue, sinfeas, xinfeas;
   pricerec  current, candidate;
-  MYBOOL    collectMP = FALSE;
+  MYBOOL    collectMP = FFALSE;
 
   /* Initialize */
   if(rhvec == NULL)
@@ -1262,7 +1262,7 @@
   if(updateinfeas)
     lp->suminfeas = fabs(sinfeas);
   if((ninfeas > 1) &&
-     !verify_stability(lp, FALSE, xinfeas, sinfeas, ninfeas)) {
+     !verify_stability(lp, FFALSE, xinfeas, sinfeas, ninfeas)) {
     report(lp, IMPORTANT, "rowdual: Check for reduced accuracy and tolerance settings.\n");
     current.varno = 0;
   }
@@ -1294,11 +1294,11 @@
     j =  1; i = lp->rows+j; lp->upbo[i] = 0;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  2; drow[i] = -1;
     j =  2; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -2; drow[i] =  2;
     j =  3; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  1; drow[i] =  5;
-    j =  4; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] =  3; drow[i] = -6;
-    j =  5; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] = -4; drow[i] = -2;
+    j =  4; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] =  3; drow[i] = -6;
+    j =  5; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] = -4; drow[i] = -2;
     j =  6; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -1; drow[i] =  0;
-    j =  7; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] =  1; drow[i] =  0;
-    j =  8; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] = -2; drow[i] =  0;
+    j =  7; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] =  1; drow[i] =  0;
+    j =  8; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] = -2; drow[i] =  0;
     j =  9; i = lp->rows+j; lp->upbo[i] = 5;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -1; drow[i] =  4;
     j = 10; i = lp->rows+j; lp->upbo[i] = F;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -2; drow[i] = 10;
     nzprow[0] = i-lp->rows;
@@ -1309,13 +1309,13 @@
   else if(which == 1) {       /* Maros Example-1 - presorted in correct order */
     j =  1; i = lp->rows+j; lp->upbo[i] = 0;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  2; drow[i] = -1;
     j =  2; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  1; drow[i] =  5;
-    j =  3; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] = -4; drow[i] = -2;
-    j =  4; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] = -2; drow[i] =  0;
+    j =  3; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] = -4; drow[i] = -2;
+    j =  4; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] = -2; drow[i] =  0;
 
     j =  5; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -1; drow[i] =  0;
-    j =  6; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] =  1; drow[i] =  0;
+    j =  6; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] =  1; drow[i] =  0;
     j =  7; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -2; drow[i] =  2;
-    j =  8; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] =  3; drow[i] = -6;
+    j =  8; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] =  3; drow[i] = -6;
     j =  9; i = lp->rows+j; lp->upbo[i] = 5;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -1; drow[i] =  4;
     j = 10; i = lp->rows+j; lp->upbo[i] = F;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -2; drow[i] = 10;
     nzprow[0] = i-lp->rows;
@@ -1327,8 +1327,8 @@
   else if(which == 10) {       /* Maros Example-2 - raw data */
     j =  1; i = lp->rows+j; lp->upbo[i] = 5;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] = -2; drow[i] =  2;
     j =  2; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  3; drow[i] =  3;
-    j =  3; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] = -2; drow[i] =  0;
-    j =  4; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] = FALSE; nzprow[j] = i; prow[i] = -1; drow[i] = -2;
+    j =  3; i = lp->rows+j; lp->upbo[i] = 1;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] = -2; drow[i] =  0;
+    j =  4; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] = FFALSE; nzprow[j] = i; prow[i] = -1; drow[i] = -2;
     j =  5; i = lp->rows+j; lp->upbo[i] = 2;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  1; drow[i] =  0;
     j =  6; i = lp->rows+j; lp->upbo[i] = F;  lp->is_lower[i] =  TRUE; nzprow[j] = i; prow[i] =  3; drow[i] =  9;
     nzprow[0] = i-lp->rows;
@@ -1354,7 +1354,7 @@
   REAL     epsvalue = lp->epsvalue;
 #endif
   pricerec current, candidate;
-  MYBOOL   isbatch = FALSE, /* Requires that lp->longsteps->size > lp->sum */
+  MYBOOL   isbatch = FFALSE, /* Requires that lp->longsteps->size > lp->sum */
            dolongsteps = (MYBOOL) (lp->longsteps != NULL);
 
   /* Initialize */
@@ -1479,7 +1479,7 @@
   /* Initialize the long-step structures if indicated */
   if(dolongsteps) {
     if((nzprow[0] <= 1) || (nbound == 0)) {  /* Don't bother */
-      dolongsteps = FALSE;
+      dolongsteps = FFALSE;
       lp->longsteps->indexSet[0] = 0;
     }
     else {
@@ -1565,7 +1565,7 @@
 
   blockdata = IF(isrow, lp->rowblocks, lp->colblocks);
   items     = IF(isrow, lp->rows, lp->columns);
-  allocREAL(lp, &sum, items+1, FALSE);
+  allocREAL(lp, &sum, items+1, FFALSE);
 
   /* Loop over items and compute the average column index for each */
   sum[0] = 0;
@@ -1693,7 +1693,7 @@
 
   blockdata = IF(isrow, lp->rowblocks, lp->colblocks);
   if(blockdata == NULL)
-    return( FALSE );
+    return( FFALSE );
   else if(blockdata->blocknow < blockdata->blockcount) {
     blockdata->blocknow++;
     return( TRUE);
@@ -1820,8 +1820,8 @@
   int i, n = multi->used;
 
   multi->used   = 0;
-  multi->sorted = FALSE;
-  multi->dirty  = FALSE;
+  multi->sorted = FFALSE;
+  multi->dirty  = FFALSE;
   if(multi->freeList != NULL) {
     for(i = 1; i <= multi->size; i++)
       multi->freeList[i] = multi->size - i;
@@ -1947,8 +1947,8 @@
   }
   multi->used  = index;
   if(multi->sorted && (index == 1))
-    multi->sorted = FALSE;
-  multi->dirty = FALSE;
+    multi->sorted = FFALSE;
+  multi->dirty = FFALSE;
 
   /* Return TRUE if the step is now positive */
   return( (MYBOOL) (multi->step_last >= multi->epszero) );
@@ -1965,12 +1965,12 @@
   int *coltarget = multi->indexSet;
 
   if(coltarget == NULL)
-    return( FALSE );
+    return( FFALSE );
 
   while((i <= multi->used) && (coltarget[i] != varnr))
     i++;
   if(i > multi->used)
-    return( FALSE );
+    return( FFALSE );
 
   for(; i < multi->used; i++)
     coltarget[i] = coltarget[i+1];
@@ -2084,7 +2084,7 @@
   if(list == NULL)
     list = &(multi->indexSet);
   if((multi->used > 0) &&
-     ((*list != NULL) || allocINT(multi->lp, list, multi->size+1, FALSE))) {
+     ((*list != NULL) || allocINT(multi->lp, list, multi->size+1, FFALSE))) {
     int i, colnr;
 
     for(i = 0; i < multi->used; i++) {
diff -ru lp_solve_5.5.orig/lp_pricePSE.c lp_solve_5.5/lp_pricePSE.c
--- lp_solve_5.5.orig/lp_pricePSE.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_pricePSE.c	2019-02-19 12:01:58.856869259 -0600
@@ -68,7 +68,7 @@
 
   /* Reallocate vector for new size */
   if(!allocREAL(lp, &(lp->edgeVector), lp->sum_alloc+1, AUTOMATIC))
-    return( FALSE );
+    return( FFALSE );
 
   /* Signal that we have not yet initialized the price vector */
   MEMCLEAR(lp->edgeVector, lp->sum_alloc+1);
@@ -80,7 +80,7 @@
 STATIC MYBOOL initPricer(lprec *lp)
 {
   if(!applyPricer(lp))
-    return( FALSE );
+    return( FFALSE );
 
   /* Free any pre-existing pricer */
   freePricer(lp);
@@ -171,7 +171,7 @@
   }
 
   /* Otherwise do the full Steepest Edge norm initialization */
-  ok = allocREAL(lp, &sEdge, m+1, FALSE);
+  ok = allocREAL(lp, &sEdge, m+1, FFALSE);
   if(!ok)
     return( ok );
 
@@ -203,7 +203,7 @@
       if(lp->is_basic[i])
         continue;
 
-      fsolve(lp, i, sEdge, NULL, 0, 0.0, FALSE);
+      fsolve(lp, i, sEdge, NULL, 0, 0.0, FFALSE);
 
       /* Compute the edge norm */
       seNorm = 1;
@@ -227,11 +227,11 @@
 STATIC MYBOOL formWeights(lprec *lp, int colnr, REAL *pcol, REAL **w)
 /* This computes Bw = a, where B is the basis and a is a column of A */
 {
-  MYBOOL ok = allocREAL(lp, w, lp->rows+1, FALSE);
+  MYBOOL ok = allocREAL(lp, w, lp->rows+1, FFALSE);
 
   if(ok) {
     if(pcol == NULL)
-      fsolve(lp, colnr, *w, NULL, 0.0, 0.0, FALSE);
+      fsolve(lp, colnr, *w, NULL, 0.0, 0.0, FFALSE);
     else {
       MEMCOPY(*w, pcol, lp->rows+1);
 /*    *w[0] = 0; */ /* Test */
@@ -265,7 +265,7 @@
 {
   REAL   *vEdge = NULL, cEdge, hold, *newEdge, *w = NULL;
   int    i, m, n, exitcol, errlevel = DETAILED;
-  MYBOOL forceRefresh = FALSE, isDual, isDEVEX, ok = FALSE;
+  MYBOOL forceRefresh = FFALSE, isDual, isDEVEX, ok = FFALSE;
 
   if(!applyPricer(lp))
     return(ok);
@@ -298,7 +298,7 @@
 
     /* Don't need to compute cross-products with DEVEX */
     if(!isDEVEX) {
-      ok = allocREAL(lp, &vEdge, m+1, FALSE);
+      ok = allocREAL(lp, &vEdge, m+1, FFALSE);
       if(!ok)
         return( ok );
 
@@ -385,9 +385,9 @@
 
     /* Initialize column target array */
     coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->sum+1, sizeof(*coltarget));
-    ok = get_colIndexA(lp, SCAN_SLACKVARS+SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE);
+    ok = get_colIndexA(lp, SCAN_SLACKVARS+SCAN_USERVARS+USE_NONBASICVARS, coltarget, FFALSE);
     if(!ok) {
-      mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+      mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
       return( ok );
     }
 
@@ -410,7 +410,7 @@
     vTemp[0] = 0;
     prod_xA(lp, coltarget, vTemp, NULL, lp->epsmachine, 0.0,
                            vAlpha, NULL, MAT_ROUNDDEFAULT);
-    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);
+    mempool_releaseVector(lp->workarrays, (char *) coltarget, FFALSE);
 
     /* Update the squared steepest edge norms; first store some constants */
     cEdge = lp->edgeVector[colnr];
@@ -494,7 +494,7 @@
 
   if(!ok)
     return( ok );
-  ok = FALSE;
+  ok = FFALSE;
 
   /* Verify */
   if(lp->edgeVector == NULL)
diff -ru lp_solve_5.5.orig/lp_scale.c lp_solve_5.5/lp_scale.c
--- lp_solve_5.5.orig/lp_scale.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_scale.c	2019-02-19 12:02:23.228869934 -0600
@@ -76,7 +76,7 @@
 }
 
 /* Compute the scale factor by the formulae:
-      FALSE: SUM (log |Aij|) ^ 2
+      FFALSE: SUM (log |Aij|) ^ 2
       TRUE:  SUM (log |Aij| - RowScale[i] - ColScale[j]) ^ 2 */
 REAL CurtisReidMeasure(lprec *lp, MYBOOL _Advanced, REAL *FRowScale, REAL *FColScale)
 {
@@ -171,8 +171,8 @@
   allocINT(lp,  &ColCount, colMax+1, TRUE);
   allocREAL(lp, &residual_even, colMax+1, TRUE);
 
-  allocREAL(lp, &RowScalem2, lp->rows+1, FALSE);
-  allocREAL(lp, &ColScalem2, colMax+1, FALSE);
+  allocREAL(lp, &RowScalem2, lp->rows+1, FFALSE);
+  allocREAL(lp, &ColScalem2, colMax+1, FFALSE);
 
   /* Set origin for row scaling */
   for(i = 1; i <= colMax; i++) {
@@ -362,7 +362,7 @@
   }
 
   /* Do validation, if indicated */
-  if(FALSE && mat_validate(mat)){
+  if(FFALSE && mat_validate(mat)){
     double check, error;
 
     /* CHECK: M RowScale + E ColScale = RowSum */
@@ -445,18 +445,18 @@
   int  Result;
 
   if(!lp->scaling_used) {
-    allocREAL(lp, &lp->scalars, lp->sum_alloc + 1, FALSE);
+    allocREAL(lp, &lp->scalars, lp->sum_alloc + 1, FFALSE);
     for(Result = 0; Result <= lp->sum; Result++)
       lp->scalars[Result] = 1;
     lp->scaling_used = TRUE;
   }
 
   if(scaledelta == NULL)
-    allocREAL(lp, &scalechange, lp->sum + 1, FALSE);
+    allocREAL(lp, &scalechange, lp->sum + 1, FFALSE);
   else
     scalechange = scaledelta;
 
-  Result=CurtisReidScales(lp, FALSE, scalechange, &scalechange[lp->rows]);
+  Result=CurtisReidScales(lp, FFALSE, scalechange, &scalechange[lp->rows]);
   if(Result>0) {
 
     /* Do the scaling*/
@@ -479,7 +479,7 @@
   *value = fabs(*value);
 #ifdef Paranoia
   if(*value < lp->epsmachine) {
-    Accept = FALSE;
+    Accept = FFALSE;
     report(lp, SEVERE, "transform_for_scale: A zero-valued entry was passed\n");
   }
   else
@@ -558,7 +558,7 @@
    scale is used to normalize another value */
 {
   long int power2;
-  MYBOOL   isSmall = FALSE;
+  MYBOOL   isSmall = FFALSE;
 
   if(scale == 1)
     return( scale );
@@ -591,7 +591,7 @@
     if(fabs(scalechange[i]-1) > lp->epsprimal)
       break;
   if(i <= 0)
-    return( FALSE );
+    return( FFALSE );
 
  /* Update the pre-existing column scalar */
   if(updateonly)
@@ -614,7 +614,7 @@
       break;
   }
   if(i < 0)
-    return( FALSE );
+    return( FFALSE );
 
  /* Update the pre-existing row scalar */
   if(updateonly)
@@ -744,7 +744,7 @@
     return(0.0);
 
   if(!lp->scaling_used) {
-    allocREAL(lp, &lp->scalars, lp->sum_alloc + 1, FALSE);
+    allocREAL(lp, &lp->scalars, lp->sum_alloc + 1, FFALSE);
     for(i = 0; i <= lp->sum; i++) {
       lp->scalars[i] = 1;
     }
@@ -758,7 +758,7 @@
     }
 #endif
   if(scaledelta == NULL)
-    allocREAL(lp, &scalechange, lp->sum + 1, FALSE);
+    allocREAL(lp, &scalechange, lp->sum + 1, FFALSE);
   else
     scalechange = scaledelta;
 
@@ -768,7 +768,7 @@
 
   row_count = lp->rows;
   allocREAL(lp, &row_max, row_count + 1, TRUE);
-  allocREAL(lp, &row_min, row_count + 1, FALSE);
+  allocREAL(lp, &row_min, row_count + 1, FFALSE);
 
   /* Initialise min and max values of rows */
   for(i = 0; i <= row_count; i++) {
@@ -926,7 +926,7 @@
     /* Allocate array for incremental scaling if appropriate */
     if((lp->solvecount > 1) && (lp->bb_level < 1) &&
        ((lp->scalemode & SCALE_DYNUPDATE) != 0))
-      allocREAL(lp, &scalenew, lp->sum + 1, FALSE);
+      allocREAL(lp, &scalenew, lp->sum + 1, FFALSE);
 
     if(is_scaletype(lp, SCALE_CURTISREID)) {
       scalingmetric = scaleCR(lp, scalenew);
@@ -974,8 +974,8 @@
     if(lp->scalars != NULL) {
       FREE(lp->scalars);
     }
-    lp->scaling_used = FALSE;
-    lp->columns_scaled = FALSE;
+    lp->scaling_used = FFALSE;
+    lp->columns_scaled = FFALSE;
   }
   if(scalenew != NULL)
     FREE(scalenew);
@@ -1019,7 +1019,7 @@
   for(i = lp->rows + 1; i<= lp->sum; i++)
     lp->scalars[i] = 1;
 
-  lp->columns_scaled = FALSE;
+  lp->columns_scaled = FFALSE;
   set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);
 }
 
@@ -1066,8 +1066,8 @@
     }
 
     FREE(lp->scalars);
-    lp->scaling_used = FALSE;
-    lp->columns_scaled = FALSE;
+    lp->scaling_used = FFALSE;
+    lp->columns_scaled = FFALSE;
 
     set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);
   }
diff -ru lp_solve_5.5.orig/lp_simplex.c lp_solve_5.5/lp_simplex.c
--- lp_solve_5.5.orig/lp_simplex.c	2019-02-19 10:42:21.372737063 -0600
+++ lp_solve_5.5/lp_simplex.c	2019-02-19 12:03:59.848872607 -0600
@@ -67,7 +67,7 @@
     return( (MYBOOL) (deltaOF < monitor->epsvalue) );
   }
   else
-    return( FALSE );
+    return( FFALSE );
 }
 
 STATIC MYBOOL stallMonitor_shortSteps(lprec *lp)
@@ -81,7 +81,7 @@
     return( (MYBOOL) (deltaOF > monitor->limitstall[TRUE]) );
   }
   else
-    return( FALSE );
+    return( FFALSE );
 }
 
 STATIC void stallMonitor_reset(lprec *lp)
@@ -103,11 +103,11 @@
 {
   OBJmonrec *monitor = NULL;
   if(lp->monitor != NULL)
-    return( FALSE );
+    return( FFALSE );
 
   monitor = (OBJmonrec *) calloc(sizeof(*monitor), 1);
   if(monitor == NULL)
-    return( FALSE );
+    return( FFALSE );
 
   monitor->lp = lp;
   strcpy(monitor->spxfunc, funcname);
@@ -116,14 +116,14 @@
   monitor->oldpivstrategy = lp->piv_strategy;
   monitor->oldpivrule = get_piv_rule(lp);
   if(MAX_STALLCOUNT <= 1)
-    monitor->limitstall[FALSE] = 0;
+    monitor->limitstall[FFALSE] = 0;
   else
-    monitor->limitstall[FALSE] = MAX(MAX_STALLCOUNT,
+    monitor->limitstall[FFALSE] = MAX(MAX_STALLCOUNT,
                                      (int) pow((REAL) (lp->rows+lp->columns)/2, 0.667));
 #if 1
-  monitor->limitstall[FALSE] *= 2+2;  /* Expand degeneracy/stalling tolerance range */
+  monitor->limitstall[FFALSE] *= 2+2;  /* Expand degeneracy/stalling tolerance range */
 #endif
-  monitor->limitstall[TRUE] = monitor->limitstall[FALSE];
+  monitor->limitstall[TRUE] = monitor->limitstall[FFALSE];
   if(monitor->oldpivrule == PRICER_DEVEX) /* Increase tolerance since primal Steepest Edge is expensive */
     monitor->limitstall[TRUE] *= 2;
   if(MAX_RULESWITCH <= 0)
@@ -152,7 +152,7 @@
   REAL   deltaobj = lp->suminfeas;
 
   /* Accept unconditionally if this is the first or second call */
-  monitor->active = FALSE;
+  monitor->active = FFALSE;
   if(monitor->Icount <= 1) {
     if(monitor->Icount == 1) {
       monitor->prevobj = lp->rhs[0];
@@ -211,7 +211,7 @@
 #endif
 
 #if 1
-  isCreeping = FALSE;
+  isCreeping = FFALSE;
 #else
   isCreeping |= stallMonitor_creepingObj(lp);
 /*  isCreeping |= stallMonitor_shortSteps(lp); */
@@ -256,7 +256,7 @@
         lp->spx_status = DEGENERATE;
         report(lp, msglevel, "%s: Stalling at iter %10.0f; no alternative strategy left.\n",
                              monitor->spxfunc, (double) get_total_iter(lp));
-        acceptance = FALSE;
+        acceptance = FFALSE;
         return( acceptance );
       }
 
@@ -293,7 +293,7 @@
       else {
         report(lp, msglevel, "%s: Stalling at iter %10.0f; proceed to bound relaxation.\n",
                              monitor->spxfunc, (double) get_total_iter(lp));
-        acceptance = FALSE;
+        acceptance = FFALSE;
         lp->spx_status = DEGENERATE;
         return( acceptance );
       }
@@ -405,11 +405,11 @@
 
      /* Create temporary sparse array storage */
       if(nzarray == NULL)
-        allocREAL(lp, &avalue, 2, FALSE);
+        allocREAL(lp, &avalue, 2, FFALSE);
       else
         avalue = nzarray;
       if(idxarray == NULL)
-        allocINT(lp, &rownr, 2, FALSE);
+        allocINT(lp, &rownr, 2, FFALSE);
       else
         rownr = idxarray;
 
@@ -437,7 +437,7 @@
     else {
       report(lp, CRITICAL, "add_artificial: Could not find replacement basis variable for row %d\n",
                            forrownr);
-      lp->basis_valid = FALSE;
+      lp->basis_valid = FFALSE;
     }
 
   }
@@ -515,7 +515,7 @@
     rownr = get_artificialRow(lp, j);
     colnr = find_rowReplacement(lp, rownr, prow, NULL);
 #if 0
-    performiteration(lp, rownr, colnr, 0.0, TRUE, FALSE, prow, NULL,
+    performiteration(lp, rownr, colnr, 0.0, TRUE, FFALSE, prow, NULL,
                                                           NULL, NULL, NULL);
 #else
     set_basisvar(lp, rownr, colnr);
@@ -562,7 +562,7 @@
 
 STATIC int primloop(lprec *lp, MYBOOL primalfeasible, REAL primaloffset)
 {
-  MYBOOL primal = TRUE, bfpfinal = FALSE, changedphase = FALSE, forceoutEQ = AUTOMATIC,
+  MYBOOL primal = TRUE, bfpfinal = FFALSE, changedphase = FFALSE, forceoutEQ = AUTOMATIC,
          primalphase1, pricerCanChange, minit, stallaccept, pendingunbounded;
   int    i, j, k, colnr = 0, rownr = 0, lastnr = 0,
          candidatecount = 0, minitcount = 0, ok = TRUE;
@@ -628,13 +628,13 @@
   }
 
   /* Create work arrays and optionally the multiple pricing structure */
-  ok = allocREAL(lp, &(lp->bsolveVal), lp->rows + 1, FALSE) &&
+  ok = allocREAL(lp, &(lp->bsolveVal), lp->rows + 1, FFALSE) &&
        allocREAL(lp, &prow, lp->sum + 1, TRUE) &&
        allocREAL(lp, &pcol, lp->rows + 1, TRUE);
   if(is_piv_mode(lp, PRICE_MULTIPLE) && (lp->multiblockdiv > 1)) {
-    lp->multivars = multi_create(lp, FALSE);
+    lp->multivars = multi_create(lp, FFALSE);
     ok &= (lp->multivars != NULL) &&
-          multi_resize(lp->multivars, lp->sum / lp->multiblockdiv, 2, FALSE, TRUE);
+          multi_resize(lp->multivars, lp->sum / lp->multiblockdiv, 2, FFALSE, TRUE);
   }
   if(!ok)
     goto Finish;
@@ -643,9 +643,9 @@
   lp->spx_status = RUNNING;
   minit = ITERATE_MAJORMAJOR;
   epsvalue = lp->epspivot;
-  pendingunbounded = FALSE;
+  pendingunbounded = FFALSE;
 
-  ok = stallMonitor_create(lp, FALSE, "primloop");
+  ok = stallMonitor_create(lp, FFALSE, "primloop");
   if(!ok)
     goto Finish;
 
@@ -667,7 +667,7 @@
    /* Find best column to enter the basis */
 RetryCol:
 #if 0
-    if(verify_solution(lp, FALSE, "spx_loop") > 0)
+    if(verify_solution(lp, FFALSE, "spx_loop") > 0)
       i = 1; /* This is just a debug trap */
 #endif
     if(!changedphase) {
@@ -700,14 +700,14 @@
       colnr = lp->rejectpivot[1];
       rownr = 0;
       lp->rejectpivot[0] = 0;
-      ok = FALSE;
+      ok = FFALSE;
       break;
     }
 #endif
 
     /* Check if we found an entering variable (indicating that we are still dual infeasible) */
     if(colnr > 0) {
-      changedphase = FALSE;
+      changedphase = FFALSE;
       fsolve(lp, colnr, pcol, NULL, lp->epsmachine, 1.0, TRUE);  /* Solve entering column for Pi */
 
       /* Do special anti-degeneracy column selection, if specified */
@@ -748,7 +748,7 @@
         rownr = findAnti_artificial(lp, colnr);
 
       if(rownr > 0) {
-        pendingunbounded = FALSE;
+        pendingunbounded = FFALSE;
         lp->rejectpivot[0] = 0;
         set_action(&lp->spx_action, ACTION_ITERATE);
         if(!lp->obj_in_basis)  /* We must manually copy the reduced cost for RHS update */
@@ -801,7 +801,7 @@
             if((lp->usermessage != NULL) && (lp->msgmask & MSG_LPFEASIBLE))
               lp->usermessage(lp, lp->msghandle, MSG_LPFEASIBLE);
           }
-          changedphase = FALSE;
+          changedphase = FFALSE;
           primalfeasible = TRUE;
           lp->simplex_mode = SIMPLEX_Phase2_PRIMAL;
           set_OF_p1extra(lp, 0.0);
@@ -830,7 +830,7 @@
 
                 /* Delete row before column due to basis "compensation logic" */
                 if(lp->is_basic[k]) {
-                  lp->is_basic[lp->rows+j] = FALSE;
+                  lp->is_basic[lp->rows+j] = FFALSE;
                   del_constraint(lp, k);
                 }
                 else
@@ -874,7 +874,7 @@
          is not necessary after the relaxed problem has been solved satisfactorily. */
       if((lp->bb_level <= 1) || (lp->improve & IMPROVE_BBSIMPLEX) /* || (lp->bb_rule & NODE_RCOSTFIXING) */) { /* NODE_RCOSTFIXING fix */
         set_action(&lp->piv_strategy, PRICE_FORCEFULL);
-          i = rowdual(lp, lp->rhs, FALSE, FALSE, NULL);
+          i = rowdual(lp, lp->rhs, FFALSE, FFALSE, NULL);
         clear_action(&lp->piv_strategy, PRICE_FORCEFULL);
         if(i > 0) {
           lp->spx_status = LOSTFEAS;
@@ -943,7 +943,7 @@
 #endif
       if(!invert(lp, INITSOL_USEZERO, bfpfinal))
         lp->spx_status = SINGULAR_BASIS;
-      bfpfinal = FALSE;
+      bfpfinal = FFALSE;
     }
   }
 
@@ -983,9 +983,9 @@
 
 STATIC int dualloop(lprec *lp, MYBOOL dualfeasible, int dualinfeasibles[], REAL dualoffset)
 {
-  MYBOOL primal = FALSE, inP1extra, dualphase1 = FALSE, changedphase = TRUE,
+  MYBOOL primal = FFALSE, inP1extra, dualphase1 = FFALSE, changedphase = TRUE,
          pricerCanChange, minit, stallaccept, longsteps,
-         forceoutEQ = FALSE, bfpfinal = FALSE;
+         forceoutEQ = FFALSE, bfpfinal = FFALSE;
   int    i, colnr = 0, rownr = 0, lastnr = 0,
          candidatecount = 0, minitcount = 0,
 #ifdef FixInaccurateDualMinit
@@ -1006,7 +1006,7 @@
 
   /* Allocate work arrays */
   ok = allocREAL(lp, &prow,   lp->sum + 1,  TRUE) &&
-       allocINT (lp, &nzprow, lp->sum + 1,  FALSE) &&
+       allocINT (lp, &nzprow, lp->sum + 1,  FFALSE) &&
        allocREAL(lp, &pcol,   lp->rows + 1, TRUE);
   if(!ok)
     goto Finish;
@@ -1033,7 +1033,7 @@
 #elif 0
   longsteps = (MYBOOL) ((MIP_count(lp) > 0) && (lp->solutioncount >= 1));
 #else
-  longsteps = FALSE;
+  longsteps = FFALSE;
 #endif
 #ifdef UseLongStepDualPhase1
   longsteps = !dualfeasible && (MYBOOL) (dualinfeasibles != NULL);
@@ -1048,7 +1048,7 @@
 #ifdef UseLongStepPruning
     lp->longsteps->objcheck = TRUE;
 #endif
-    boundswaps = multi_indexSet(lp->longsteps, FALSE);
+    boundswaps = multi_indexSet(lp->longsteps, FFALSE);
   }
 
   /* Do regular dual simplex variable initializations */
@@ -1082,7 +1082,7 @@
 #if 1
   if(is_anti_degen(lp, ANTIDEGEN_DYNAMIC) && (bin_count(lp, TRUE)*2 > lp->columns)) {
     switch (forceoutEQ) {
-      case FALSE:     forceoutEQ = AUTOMATIC;
+      case FFALSE:     forceoutEQ = AUTOMATIC;
                       break;
  /*     case AUTOMATIC: forceoutEQ = TRUE;
                       break;
@@ -1100,7 +1100,7 @@
       break;
 
     /* Store current LP index for reference at next iteration */
-    changedphase = FALSE;
+    changedphase = FFALSE;
 
     /* Compute (pure) dual phase1 offsets / reduced costs if appropriate */
     dualphase1 &= (MYBOOL) (lp->simplex_mode == SIMPLEX_Phase1_DUAL);
@@ -1137,7 +1137,7 @@
       rownr = lp->rejectpivot[1];
       colnr = 0;
       lp->rejectpivot[0] = 0;
-      ok = FALSE;
+      ok = FFALSE;
       break;
     }
 #endif
@@ -1196,13 +1196,13 @@
           if(!refactRecent(lp)) {
             report(lp, DETAILED, "...trying to recover by refactorizing basis.\n");
             set_action(&lp->spx_action, ACTION_REINVERT);
-            bfpfinal = FALSE;
+            bfpfinal = FFALSE;
           }
           else {
             if(lp->bb_totalnodes == 0)
               report(lp, DETAILED, "...cannot recover by refactorizing basis.\n");
             lp->spx_status = NUMFAILURE;
-            ok = FALSE;
+            ok = FFALSE;
           }
         }
         else {
@@ -1277,7 +1277,7 @@
           if((lp->spx_trace && (lp->bb_totalnodes == 0)) ||
              (lp->bb_trace && (lp->bb_totalnodes > 0)))
             report(lp, DETAILED, "dualloop: Model lost dual feasibility.\n");
-          ok = FALSE;
+          ok = FFALSE;
           break;
         }
 
@@ -1297,7 +1297,7 @@
                (lp->bb_trace && (lp->bb_totalnodes > 0)))
             report(lp, DETAILED, "The model is primal infeasible.\n");
           }
-          ok = FALSE;
+          ok = FFALSE;
           break;
         }
       }
@@ -1330,7 +1330,7 @@
           colnr = find_rowReplacement(lp, rownr, prow, nzprow);
           if(colnr > 0) {
             theta = 0;
-            performiteration(lp, rownr, colnr, theta, TRUE, FALSE, prow, NULL,
+            performiteration(lp, rownr, colnr, theta, TRUE, FFALSE, prow, NULL,
                                                             NULL, NULL, NULL);
             lp->fixedvars--;
           }
@@ -1348,11 +1348,11 @@
             report(lp, DETAILED, "The model is primal infeasible and dual unbounded.\n");
         }
         set_OF_p1extra(lp, 0);
-        inP1extra = FALSE;
+        inP1extra = FFALSE;
         set_action(&lp->spx_action, ACTION_REINVERT);
         lp->spx_status = INFEASIBLE;
         lp->simplex_mode = SIMPLEX_UNDEFINED;
-        ok = FALSE;
+        ok = FFALSE;
       }
 
       /* Check if we are FEASIBLE (and possibly also optimal) for the case that the
@@ -1368,7 +1368,7 @@
             lp->usermessage(lp, lp->msghandle, MSG_LPFEASIBLE);
         }
         set_OF_p1extra(lp, 0);
-        inP1extra = FALSE;
+        inP1extra = FFALSE;
         set_action(&lp->spx_action, ACTION_REINVERT);
 
 #if 1
@@ -1406,7 +1406,7 @@
         colnr = 0;
         if((dualoffset != 0) || (lp->bb_level <= 1) || (lp->improve & IMPROVE_BBSIMPLEX) || (lp->bb_rule & NODE_RCOSTFIXING)) { /* NODE_RCOSTFIXING fix */
           set_action(&lp->piv_strategy, PRICE_FORCEFULL);
-            colnr = colprim(lp, drow, nzdrow, FALSE, 1, &candidatecount, FALSE, NULL);
+            colnr = colprim(lp, drow, nzdrow, FFALSE, 1, &candidatecount, FFALSE, NULL);
           clear_action(&lp->piv_strategy, PRICE_FORCEFULL);
           if((dualoffset == 0) && (colnr > 0)) {
             lp->spx_status = LOSTFEAS;
@@ -1456,7 +1456,7 @@
       if(!lp->is_strongbranch && (lp->solutioncount >= 1) && !lp->spx_perturbed && !inP1extra &&
           bb_better(lp, OF_WORKING, OF_TEST_WE)) {
         lp->spx_status = FATHOMED;
-        ok = FALSE;
+        ok = FFALSE;
         break;
       }
 
@@ -1467,7 +1467,7 @@
       if(longsteps && dualphase1 && !inP1extra) {
         dualfeasible = isDualFeasible(lp, lp->epsprimal, NULL, dualinfeasibles, NULL);
         if(dualfeasible) {
-          dualphase1 = FALSE;
+          dualphase1 = FFALSE;
           changedphase = TRUE;
           lp->simplex_mode = SIMPLEX_Phase2_DUAL;
         }
@@ -1492,7 +1492,7 @@
           if(!isDualFeasible(lp, lp->epsdual, &colnr, NULL, NULL)) {
 #else
           set_action(&lp->piv_strategy, PRICE_FORCEFULL);
-            colnr = colprim(lp, drow, nzdrow, FALSE, 1, &candidatecount, FALSE, NULL);
+            colnr = colprim(lp, drow, nzdrow, FFALSE, 1, &candidatecount, FFALSE, NULL);
           clear_action(&lp->piv_strategy, PRICE_FORCEFULL);
           if(colnr > 0) {
 #endif
@@ -1502,7 +1502,7 @@
         }
 #endif
 
-        bfpfinal = FALSE;
+        bfpfinal = FFALSE;
 #ifdef ResetMinitOnReinvert
         minit = ITERATE_MAJORMAJOR;
 #endif
@@ -1536,7 +1536,7 @@
   set_OF_p1extra(lp, 0);
   singular_count  = 0;
   lost_feas_count = 0;
-  lost_feas_state = FALSE;
+  lost_feas_state = FFALSE;
   lp->simplex_mode = SIMPLEX_DYNAMIC;
 
   /* Compute the number of fixed basic and bounded variables (used in long duals) */
@@ -1554,7 +1554,7 @@
       lp->boundedvars++;
   }
 #ifdef UseLongStepDualPhase1
-  allocINT(lp, &infeasibles, lp->columns + 1, FALSE);
+  allocINT(lp, &infeasibles, lp->columns + 1, FFALSE);
   infeasibles[0] = 0;
 #endif
 
@@ -1649,7 +1649,7 @@
 
     /* Check for outcomes that may involve trying another simplex loop */
     if(lp->spx_status == SINGULAR_BASIS) {
-      lost_feas_state = FALSE;
+      lost_feas_state = FFALSE;
       singular_count++;
       if(singular_count >= DEF_MAXSINGULARITIES) {
         report(lp, IMPORTANT, "spx_run: Failure due to too many singular bases.\n");
@@ -1744,7 +1744,7 @@
 
   status = RUNNING;
   lp->bb_limitOF = my_chsign(is_maxim(lp), -lp->infinite);
-  if(FALSE && (lp->int_vars > 0)) {
+  if(FFALSE && (lp->int_vars > 0)) {
 
     /* 1. Copy the problem into a new relaxed instance, extracting Lagrangean constraints */
     hlp = make_lag(lp);
@@ -1779,7 +1779,7 @@
   }
 
   /* Allocate iteration arrays */
-  if(!allocREAL(lp, &OrigObj, lp->columns + 1, FALSE) ||
+  if(!allocREAL(lp, &OrigObj, lp->columns + 1, FFALSE) ||
      !allocREAL(lp, &ModObj,  lp->columns + 1, TRUE) ||
      !allocREAL(lp, &SubGrad, get_Lrows(lp) + 1, TRUE) ||
      !allocREAL(lp, &BestFeasSol, lp->sum + 1, TRUE)) {
@@ -1803,9 +1803,9 @@
 
   Phi      = DEF_LAGCONTRACT; /* In the range 0-2.0 to guarantee convergence */
 /*  Phi      = 0.15; */
-  LagFeas  = FALSE;
-  Converged= FALSE;
-  AnyFeas  = FALSE;
+  LagFeas  = FFALSE;
+  Converged= FFALSE;
+  AnyFeas  = FFALSE;
   citer    = 0;
   nochange = 0;
 
@@ -1840,14 +1840,14 @@
       if(LagFeas) {
         if(lp->lag_con_type[i] == EQ) {
           if(fabs(hold) > lp->epsprimal)
-            LagFeas = FALSE;
+            LagFeas = FFALSE;
         }
         else if(hold < -lp->epsprimal)
-          LagFeas = FALSE;
+          LagFeas = FFALSE;
       }
       /* Test for convergence and update */
       if(Converged && (fabs(my_reldiff(hold , SubGrad[i])) > /* lp->lag_accept */ DEF_LAGACCEPT))
-        Converged = FALSE;
+        Converged = FFALSE;
       SubGrad[i] = hold;
       SqrsumSubGrad += hold * hold;
     }
@@ -1961,7 +1961,7 @@
     same_basis = compare_basis(lp);
     if(LagFeas &&
        !same_basis) {
-      pop_basis(lp, FALSE);
+      pop_basis(lp, FFALSE);
       push_basis(lp, NULL, NULL, NULL);
       Phi *= DEF_LAGCONTRACT;
     }
@@ -2022,7 +2022,7 @@
   FREE(SubGrad);
   FREE(OrigObj);
   FREE(ModObj);
-  pop_basis(lp, FALSE);
+  pop_basis(lp, FFALSE);
 
   lp->do_presolve = oldpresolve;
 
@@ -2041,7 +2041,7 @@
   lp->bb_totalnodes    = 0;
   lp->bb_improvements  = 0;
   lp->bb_strongbranches= 0;
-  lp->is_strongbranch  = FALSE;
+  lp->is_strongbranch  = FFALSE;
   lp->bb_level         = 0;
   lp->bb_solutionlevel = 0;
   lp->best_solution[0] = my_chsign(is_maxim(lp), lp->infinite);
@@ -2066,7 +2066,7 @@
     lp->solutioncount = 0;
     lp->real_solution = lp->infinite;
     set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT);
-    lp->bb_break = FALSE;
+    lp->bb_break = FFALSE;
 
     /* Do the call to the real underlying solver (note that
        run_BB is replaceable with any compatible MIP solver) */
diff -ru lp_solve_5.5.orig/lp_SOS.c lp_solve_5.5/lp_SOS.c
--- lp_solve_5.5.orig/lp_SOS.c	2019-02-19 10:42:21.376737063 -0600
+++ lp_solve_5.5/lp_SOS.c	2019-02-19 12:04:39.152873695 -0600
@@ -147,7 +147,7 @@
     SOS->name = NULL;
   else
   {
-    allocCHAR(group->lp, &SOS->name, (int) (strlen(name)+1), FALSE);
+    allocCHAR(group->lp, &SOS->name, (int) (strlen(name)+1), FFALSE);
     strcpy(SOS->name, name);
   }
   if(type < 0)
@@ -248,8 +248,8 @@
   lp->sos_vars = n;
   if(lp->sos_vars > 0) /* Prevent memory loss in case of multiple solves */
     FREE(lp->sos_priority);
-  allocINT(lp, &lp->sos_priority, n, FALSE);
-  allocREAL(lp, &order, n, FALSE);
+  allocINT(lp, &lp->sos_priority, n, FFALSE);
+  allocREAL(lp, &order, n, FFALSE);
 
   /* Move variable data to the master SOS list and sort by ascending weight */
   n = 0;
@@ -263,7 +263,7 @@
       n++;
     }
   }
-  hpsortex(order, n, 0, sizeof(*order), FALSE, compareREAL, lp->sos_priority);
+  hpsortex(order, n, 0, sizeof(*order), FFALSE, compareREAL, lp->sos_priority);
   FREE(order);
 
   /* Remove duplicate SOS variables */
@@ -296,7 +296,7 @@
 #ifdef Paranoia
   if((sosindex <= 0) || (sosindex > group->sos_count)) {
     report(group->lp, IMPORTANT, "delete_SOSrec: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -345,7 +345,7 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_member_sortlist: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -355,7 +355,7 @@
   if(sosindex == 0) {
     for(i = 1; i <= group->sos_count; i++) {
       if(!SOS_member_sortlist(group, i))
-        return(FALSE);
+        return(FFALSE);
     }
   }
   else {
@@ -453,12 +453,12 @@
 
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_shift_col: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
   else if((column < 1) || (delta == 0)) {
     report(lp, IMPORTANT, "SOS_shift_col: Invalid column %d specified with delta %d\n",
                           column, delta);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -468,7 +468,7 @@
   if(sosindex == 0) {
     for(i = 1; i <= group->sos_count; i++) {
       if(!SOS_shift_col(group, i, column, delta, usedmap, forceresort))
-        return(FALSE);
+        return(FFALSE);
     }
   }
   else {
@@ -629,7 +629,7 @@
 #ifdef Paranoia
   if((sosindex < 1) || (sosindex > group->sos_count)) {
     report(group->lp, IMPORTANT, "SOS_get_type: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -645,7 +645,7 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_infeasible: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -695,7 +695,7 @@
   SOS = group->sos_list[sosindex-1];
   n = SOS->members[0];
 
-  n = searchFor(member, SOS->membersSorted, n, 0, FALSE);
+  n = searchFor(member, SOS->membersSorted, n, 0, FFALSE);
   if(n >= 0)
     n = SOS->membersMapped[n];
 
@@ -733,11 +733,11 @@
 
 int SOS_is_member(SOSgroup *group, int sosindex, int column)
 {
-  int    i, n = FALSE, *list;
+  int    i, n = FFALSE, *list;
   lprec  *lp;
 
   if(group == NULL)
-    return( FALSE );
+    return( FFALSE );
   lp = group->lp;
 
 #ifdef Paranoia
@@ -756,7 +756,7 @@
    /* Search for the variable */
     i = SOS_member_index(group, sosindex, column);
 
-   /* Signal active status if found, otherwise return FALSE */
+   /* Signal active status if found, otherwise return FFALSE */
     if(i > 0) {
       list = group->sos_list[sosindex-1]->members;
       if(list[i] < 0)
@@ -781,7 +781,7 @@
         ((sostype == SOSn) && (n > 2))) && SOS_is_member(group, k, column))
       return(TRUE);
   }
-  return(FALSE);
+  return(FFALSE);
 }
 
 
@@ -792,7 +792,7 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(group->lp, IMPORTANT, "SOS_set_GUB: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
   if((sosindex == 0) && (group->sos_count == 1))
@@ -815,7 +815,7 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(group->lp, IMPORTANT, "SOS_is_GUB: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -827,7 +827,7 @@
       if(SOS_is_GUB(group, i))
         return(TRUE);
     }
-    return(FALSE);
+    return(FFALSE);
   }
   else
     return( group->sos_list[sosindex-1]->isGUB );
@@ -840,18 +840,18 @@
   lprec  *lp;
 
   if(group == NULL)
-    return( FALSE );
+    return( FFALSE );
   lp = group->lp;
 
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_is_marked: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
   if(!(lp->var_type[column] & (ISSOS | ISGUB)))
-    return(FALSE);
+    return(FFALSE);
 
   if(sosindex == 0) {
     for(i = group->memberpos[column-1]; i < group->memberpos[column]; i++) {
@@ -871,7 +871,7 @@
       if(list[i] == column)
         return(TRUE);
   }
-  return(FALSE);
+  return(FFALSE);
 }
 
 
@@ -883,12 +883,12 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_is_active: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
   if(!(lp->var_type[column] & (ISSOS | ISGUB)))
-    return(FALSE);
+    return(FFALSE);
 
   if(sosindex == 0) {
     for(i = group->memberpos[column-1]; i < group->memberpos[column]; i++) {
@@ -909,7 +909,7 @@
       if(list[n+i] == column)
         return(TRUE);
   }
-  return(FALSE);
+  return(FFALSE);
 }
 
 
@@ -921,12 +921,12 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_is_full: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
   if(!(lp->var_type[column] & (ISSOS | ISGUB)))
-    return(FALSE);
+    return(FFALSE);
 
   if(sosindex == 0) {
     for(i = group->memberpos[column-1]; i < group->memberpos[column]; i++) {
@@ -959,7 +959,7 @@
     }
   }
 
-  return(FALSE);
+  return(FFALSE);
 }
 
 
@@ -969,25 +969,25 @@
   lprec  *lp;
 
   if(group == NULL)
-    return( FALSE );
+    return( FFALSE );
   lp = group->lp;
 
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_can_activate: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
   if(!(lp->var_type[column] & (ISSOS | ISGUB)))
-    return(FALSE);
+    return(FFALSE);
 
   if(sosindex == 0) {
     for(i = group->memberpos[column-1]; i < group->memberpos[column]; i++) {
       nn = group->membership[i];
       n = SOS_can_activate(group, nn, column);
-      if(n == FALSE)
-        return(FALSE);
+      if(n == FFALSE)
+        return(FFALSE);
     }
   }
   else if(SOS_is_member(group, sosindex, column)) {
@@ -1004,7 +1004,7 @@
 
     /* Cannot activate a variable if the SOS is full */
     if(list[n+nn] != 0)
-      return(FALSE);
+      return(FFALSE);
 
     /* Check if there are variables quasi-active via non-zero lower bounds */
     nz = 0;
@@ -1013,7 +1013,7 @@
         nz++;
         /* Reject outright if selected column has a non-zero lower bound */
         if(list[i] == column)
-          return(FALSE);
+          return(FFALSE);
       }
 #ifdef Paranoia
     if(nz > nn)
@@ -1026,7 +1026,7 @@
         nz++;
     }
     if(nz == nn)
-      return(FALSE);
+      return(FFALSE);
 
     /* Accept if the SOS is empty */
     if(list[n+1] == 0)
@@ -1042,7 +1042,7 @@
         if(list[n+i] == 0)
           break;
         if(list[n+i] == column)
-          return(FALSE);
+          return(FFALSE);
       }
       i--;
       nn = list[n+i];
@@ -1055,7 +1055,7 @@
           break;
       if(i > n) {
         report(lp, CRITICAL, "SOS_can_activate: Internal index error at SOS %d\n", sosindex);
-        return(FALSE);
+        return(FFALSE);
       }
 
       /* SOS accepts an additional variable; confirm neighbourness of candidate */
@@ -1068,7 +1068,7 @@
         return(TRUE);
 
       /* It is not the right neighbour; return false */
-      return(FALSE);
+      return(FFALSE);
     }
   }
   return(TRUE);
@@ -1083,12 +1083,12 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_set_marked: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
   if(!(lp->var_type[column] & (ISSOS | ISGUB)))
-    return(FALSE);
+    return(FFALSE);
 
   if(sosindex == 0) {
 
@@ -1125,10 +1125,10 @@
     if(asactive) {
       for(i = 1; i <= nn; i++) {
         if(list[n+i] == column)
-          return(FALSE);
+          return(FFALSE);
         else if(list[n+i] == 0) {
           list[n+i] = column;
-          return(FALSE);
+          return(FFALSE);
         }
       }
     }
@@ -1146,12 +1146,12 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_unmark: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
   if(!(lp->var_type[column] & (ISSOS | ISGUB)))
-    return(FALSE);
+    return(FFALSE);
 
 
   if(sosindex == 0) {
@@ -1159,7 +1159,7 @@
     /* Undefine a SOS3 member variable that has temporarily been set as integer */
     if(lp->var_type[column] & ISSOSTEMPINT) {
       lp->var_type[column] &= !ISSOSTEMPINT;
-      set_int(lp, column, FALSE);
+      set_int(lp, column, FFALSE);
     }
 
     nn = 0;
@@ -1197,7 +1197,7 @@
         list[n+nn] = 0;
         return(TRUE);
       }
-      return(FALSE);
+      return(FFALSE);
     }
     else
       return(TRUE);
@@ -1214,7 +1214,7 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_fix_unmarked: Invalid SOS index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
@@ -1365,7 +1365,7 @@
 #ifdef Paranoia
   if((sosindex < 0) || (sosindex > group->sos_count)) {
     report(lp, IMPORTANT, "SOS_fix_list: Invalid index %d\n", sosindex);
-    return(FALSE);
+    return(FFALSE);
   }
 #endif
 
diff -ru lp_solve_5.5.orig/lp_utils.c lp_solve_5.5/lp_utils.c
--- lp_solve_5.5.orig/lp_utils.c	2019-02-19 10:42:21.376737063 -0600
+++ lp_solve_5.5/lp_utils.c	2019-02-19 12:05:12.316874613 -0600
@@ -47,7 +47,7 @@
   if(((*ptr) == NULL) && (size > 0)) {
     lp->report(lp, CRITICAL, "alloc of %d 'char' failed\n", size);
     lp->spx_status = NOMEMORY;
-    return( FALSE );
+    return( FFALSE );
   }
   else
     return( TRUE );
@@ -66,7 +66,7 @@
   if(((*ptr) == NULL) && (size > 0)) {
     lp->report(lp, CRITICAL, "alloc of %d 'MYBOOL' failed\n", size);
     lp->spx_status = NOMEMORY;
-    return( FALSE );
+    return( FFALSE );
   }
   else
     return( TRUE );
@@ -85,7 +85,7 @@
   if(((*ptr) == NULL) && (size > 0)) {
     lp->report(lp, CRITICAL, "alloc of %d 'INT' failed\n", size);
     lp->spx_status = NOMEMORY;
-    return( FALSE );
+    return( FFALSE );
   }
   else
     return( TRUE );
@@ -104,7 +104,7 @@
   if(((*ptr) == NULL) && (size > 0)) {
     lp->report(lp, CRITICAL, "alloc of %d 'REAL' failed\n", size);
     lp->spx_status = NOMEMORY;
-    return( FALSE );
+    return( FFALSE );
   }
   else
     return( TRUE );
@@ -123,7 +123,7 @@
   if(((*ptr) == NULL) && (size > 0)) {
     lp->report(lp, CRITICAL, "alloc of %d 'LREAL' failed\n", size);
     lp->spx_status = NOMEMORY;
-    return( FALSE );
+    return( FFALSE );
   }
   else
     return( TRUE );
@@ -138,7 +138,7 @@
     *ptr = NULL;
   }
   else {
-    status = FALSE;
+    status = FFALSE;
     lp->report(lp, CRITICAL, "free() failed on line %d of file %s\n",
                              __LINE__, __FILE__);
   }
@@ -311,7 +311,7 @@
       break;
 
   if((i < 0) || (mempool->vectorsize[i] < 0))
-    return( FALSE );
+    return( FFALSE );
 
   if(forcefree) {
     FREE(mempool->vectorarray[i]);
@@ -345,7 +345,7 @@
   REAL *newlist;
 
   size += 1;
-  if(allocREAL(lp, &newlist, size, FALSE))
+  if(allocREAL(lp, &newlist, size, FFALSE))
     MEMCOPY(newlist, origlist, size);
   return(newlist);
 }
@@ -354,7 +354,7 @@
   MYBOOL *newlist;
 
   size += 1;
-  if(allocMYBOOL(lp, &newlist, size, FALSE))
+  if(allocMYBOOL(lp, &newlist, size, FFALSE))
     MEMCOPY(newlist, origlist, size);
   return(newlist);
 }
@@ -363,7 +363,7 @@
   int *newlist;
 
   size += 1;
-  if(allocINT(lp, &newlist, size, FALSE))
+  if(allocINT(lp, &newlist, size, FFALSE))
     MEMCOPY(newlist, origlist, size);
   return(newlist);
 }
@@ -600,7 +600,7 @@
 /* ---------------------------------------------------------------------------------- */
 STATIC REAL rand_uniform(lprec *lp, REAL range)
 {
-  static MYBOOL randomized = FALSE; /* static ok here for reentrancy/multithreading */
+  static MYBOOL randomized = FFALSE; /* static ok here for reentrancy/multithreading */
 
   if(!randomized) {
     randomized = TRUE;
@@ -659,7 +659,7 @@
   MYBOOL status = TRUE;
 
   if((linkmap == NULL) || (*linkmap == NULL))
-    status = FALSE;
+    status = FFALSE;
   else {
     if((*linkmap)->map != NULL)
       free((*linkmap)->map);
@@ -681,7 +681,7 @@
      (linkmap->map[0] == itemnr))
     return( TRUE );
   else
-    return( FALSE );
+    return( FFALSE );
 }
 
 STATIC int countActiveLink(LLrec *linkmap)
@@ -710,7 +710,7 @@
   size = linkmap->size;
 
   if(linkmap->map[newitem] != 0)
-    return( FALSE );
+    return( FFALSE );
 
   /* Link forward */
   k = linkmap->map[2*size+1];
@@ -736,7 +736,7 @@
   size = linkmap->size;
 
   if(linkmap->map[newitem] != 0)
-    return( FALSE );
+    return( FFALSE );
 
   if(afteritem == linkmap->map[2*size+1])
     appendLink(linkmap, newitem);
@@ -762,7 +762,7 @@
 STATIC MYBOOL setLink(LLrec *linkmap, int newitem)
 {
   if(isActiveLink(linkmap, newitem))
-    return( FALSE );
+    return( FFALSE );
   else
     return( insertLink(linkmap, prevActiveLink(linkmap, newitem), newitem) );
 }
@@ -774,7 +774,7 @@
 
   k = firstActiveLink(linkmap);
   if(k != 0)
-    return( FALSE );
+    return( FFALSE );
   for(k = 1; k <= size; k++)
     appendLink(linkmap, k);
   return( TRUE );
@@ -936,7 +936,7 @@
 {
   LLrec *testmap;
 
-  testmap = cloneLink(linkmap, -1, FALSE);
+  testmap = cloneLink(linkmap, -1, FFALSE);
   if(doappend) {
     appendLink(testmap, itemnr);
     removeLink(testmap, itemnr);
@@ -1006,9 +1006,9 @@
 
   /* Test for validity of the target and create it if necessary */
   if(target == NULL)
-    return( FALSE );
+    return( FFALSE );
   if(*target == NULL)
-    allocREAL(NULL, target, PV->startpos[PV->count], FALSE);
+    allocREAL(NULL, target, PV->startpos[PV->count], FFALSE);
 
   /* Expand the packed vector into the target */
   i = PV->startpos[0];
@@ -1025,7 +1025,7 @@
 
 STATIC REAL getvaluePackedVector(PVrec *PV, int index)
 {
-  index = searchFor(index, PV->startpos, PV->count, 0, FALSE);
+  index = searchFor(index, PV->startpos, PV->count, 0, FFALSE);
   index = abs(index)-1;
   if(index >= 0)
     return( PV->value[index] );
@@ -1036,7 +1036,7 @@
 STATIC MYBOOL freePackedVector(PVrec **PV)
 {
   if((PV == NULL) || (*PV == NULL))
-    return( FALSE );
+    return( FFALSE );
 
   FREE((*PV)->value);
   FREE((*PV)->startpos);
diff -ru lp_solve_5.5.orig/lp_wlp.c lp_solve_5.5/lp_wlp.c
--- lp_solve_5.5.orig/lp_wlp.c	2019-02-19 10:42:21.376737063 -0600
+++ lp_solve_5.5/lp_wlp.c	2019-02-19 11:56:14.376859727 -0600
@@ -59,7 +59,7 @@
       if(!first)
         nchars += write_data(userhandle, write_modeldata, " ");
       else
-        first = FALSE;
+        first = FFALSE;
       sprintf(buf, "%+.12g", (double)a);
       if(strcmp(buf, "-1") == 0)
         nchars += write_data(userhandle, write_modeldata, "-");
@@ -95,14 +95,14 @@
 
   if(!mat_validate(lp->matA)) {
     report(lp, IMPORTANT, "LP_writefile: Could not validate the data matrix.\n");
-    return(FALSE);
+    return(FFALSE);
   }
 
   /* Write name of model */
   ptr = get_lp_name(lp);
   if(ptr != NULL) {
     if(*ptr)
-      write_lpcomment(userhandle, write_modeldata, ptr, FALSE);
+      write_lpcomment(userhandle, write_modeldata, ptr, FFALSE);
     else
       ptr = NULL;
   }
@@ -183,7 +183,7 @@
   }
 
   /* Write bounds on variables */
-  ok = FALSE;
+  ok = FFALSE;
   for(i = nrows + 1; i <= lp->sum; i++)
     if(!is_splitvar(lp, i - nrows)) {
       if(lp->orig_lowbo[i] == lp->orig_upbo[i]) {
diff -ru lp_solve_5.5.orig/shared/commonlib.c lp_solve_5.5/shared/commonlib.c
--- lp_solve_5.5.orig/shared/commonlib.c	2019-02-19 10:42:21.376737063 -0600
+++ lp_solve_5.5/shared/commonlib.c	2019-02-19 12:11:34.268885181 -0600
@@ -116,7 +116,7 @@
   char *ptr;
 
   if((descname == NULL) || (stdname == NULL) || (((int) strlen(descname)) >= buflen - 6))
-    return( FALSE );
+    return( FFALSE );
 
   strcpy(stdname, descname);
   if((ptr = strrchr(descname, '/')) == NULL)
@@ -982,7 +982,7 @@
 
    _searchenv( searchfile, envvar, pathbuffer );
    if(pathbuffer[0] == '\0')
-     return( FALSE );
+     return( FFALSE );
    else {
      if(foundpath != NULL)
        strcpy(foundpath, pathbuffer);
diff -ru lp_solve_5.5.orig/shared/commonlib.h lp_solve_5.5/shared/commonlib.h
--- lp_solve_5.5.orig/shared/commonlib.h	2019-02-19 10:42:21.376737063 -0600
+++ lp_solve_5.5/shared/commonlib.h	2019-02-19 11:54:00.028856010 -0600
@@ -84,8 +84,8 @@
   #define NULL 	       0
 #endif
 
-#ifndef FALSE
-  #define FALSE        0
+#ifndef FFALSE
+  #define FFALSE        0
   #define TRUE         1
 #endif
 
diff -ru lp_solve_5.5.orig/shared/myblas.c lp_solve_5.5/shared/myblas.c
--- lp_solve_5.5.orig/shared/myblas.c	2019-02-19 10:42:21.376737063 -0600
+++ lp_solve_5.5/shared/myblas.c	2019-02-19 12:11:58.152885842 -0600
@@ -42,7 +42,7 @@
 {
   if(mustinitBLAS) {
     load_BLAS(NULL);
-    mustinitBLAS = FALSE;
+    mustinitBLAS = FFALSE;
   }
 }
 
@@ -72,7 +72,7 @@
 
   if(libname == NULL) {
     if(!mustinitBLAS && is_nativeBLAS())
-      return( FALSE );
+      return( FFALSE );
     BLAS_dscal = my_dscal;
     BLAS_dcopy = my_dcopy;
     BLAS_daxpy = my_daxpy;
@@ -82,7 +82,7 @@
     BLAS_dload = my_dload;
     BLAS_dnormi = my_dnormi;
     if(mustinitBLAS)
-      mustinitBLAS = FALSE;
+      mustinitBLAS = FFALSE;
   }
   else {
 #ifdef LoadableBlasLib
@@ -151,7 +151,7 @@
         (BLAS_dnormi == NULL))
       ) {
       load_BLAS(NULL);
-      result = FALSE;
+      result = FFALSE;
     }
   }
   return( result );
