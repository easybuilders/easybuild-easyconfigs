fix for:
/tmp/easybuild/Libint/2.7.2/GCC-12.3.0-lmax-6-cp2k/libint-2.7.2/libint-2.7.2/tests/unit/catch.hpp:10822:58: error: call to non-constexpr function long int sysconf(int)
10822 |     static constexpr std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;
      |                                                          ^~~~~~~~~~~

see https://github.com/evaleev/libint/issues/328 + https://github.com/evaleev/libint/pull/334

From 37aed36be4cb037867758b0a9a17db29d5c87f4d Mon Sep 17 00:00:00 2001
From: Eduard Valeyev <eduard@valeyev.net>
Date: Mon, 4 Mar 2024 09:17:09 -0500
Subject: [PATCH] bump Catch2 to 2.13.10, resolves #328

see https://github.com/catchorg/Catch2/releases/tag/v2.13.10
---
 tests/unit/catch.hpp | 5182 +++++++++++++++++++++---------------------
 1 file changed, 2639 insertions(+), 2543 deletions(-)

diff --git a/tests/unit/catch.hpp b/tests/unit/catch.hpp
index 4eb22c23c..9b309bddc 100644
--- a/tests/unit/catch.hpp
+++ b/tests/unit/catch.hpp
@@ -1,9 +1,9 @@
 /*
- *  Catch v2.13.4
- *  Generated: 2020-12-29 14:48:00.116107
+ *  Catch v2.13.10
+ *  Generated: 2022-10-16 11:01:23.452308
  *  ----------------------------------------------------------
  *  This file has been merged from multiple headers. Please don't edit it directly
- *  Copyright (c) 2020 Two Blue Cubes Ltd. All rights reserved.
+ *  Copyright (c) 2022 Two Blue Cubes Ltd. All rights reserved.
  *
  *  Distributed under the Boost Software License, Version 1.0. (See accompanying
  *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
@@ -15,7 +15,7 @@
 
 #define CATCH_VERSION_MAJOR 2
 #define CATCH_VERSION_MINOR 13
-#define CATCH_VERSION_PATCH 4
+#define CATCH_VERSION_PATCH 10
 
 #ifdef __clang__
 #    pragma clang system_header
@@ -36,7 +36,7 @@
 #       pragma clang diagnostic ignored "-Wcovered-switch-default"
 #    endif
 #elif defined __GNUC__
-// Because REQUIREs trigger GCC's -Wparentheses, and because still
+     // Because REQUIREs trigger GCC's -Wparentheses, and because still
      // supported version of g++ have only buggy support for _Pragmas,
      // Wparentheses have to be suppressed globally.
 #    pragma GCC diagnostic ignored "-Wparentheses" // See #674 for details
@@ -66,13 +66,16 @@
 #if !defined(CATCH_CONFIG_IMPL_ONLY)
 // start catch_platform.h
 
+// See e.g.:
+// https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-18.1/TargetConditionals.h.auto.html
 #ifdef __APPLE__
-# include <TargetConditionals.h>
-# if TARGET_OS_OSX == 1
-#  define CATCH_PLATFORM_MAC
-# elif TARGET_OS_IPHONE == 1
-#  define CATCH_PLATFORM_IPHONE
-# endif
+#  include <TargetConditionals.h>
+#  if (defined(TARGET_OS_OSX) && TARGET_OS_OSX == 1) || \
+      (defined(TARGET_OS_MAC) && TARGET_OS_MAC == 1)
+#    define CATCH_PLATFORM_MAC
+#  elif (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE == 1)
+#    define CATCH_PLATFORM_IPHONE
+#  endif
 
 #elif defined(linux) || defined(__linux) || defined(__linux__)
 #  define CATCH_PLATFORM_LINUX
@@ -93,7 +96,7 @@
 // start catch_user_interfaces.h
 
 namespace Catch {
-unsigned int rngSeed();
+    unsigned int rngSeed();
 }
 
 // end catch_user_interfaces.h
@@ -132,9 +135,9 @@ unsigned int rngSeed();
 
 #endif
 
-// We have to avoid both ICC and Clang, because they try to mask themselves
-// as gcc, and we want only GCC in this block
-#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__)
+// Only GCC compiler should be used in this block, so other compilers trying to
+// mask themselves as GCC should be ignored.
+#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__) && !defined(__LCC__)
 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )
 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )
 
@@ -183,13 +186,13 @@ unsigned int rngSeed();
 ////////////////////////////////////////////////////////////////////////////////
 // Assume that non-Windows platforms support posix signals by default
 #if !defined(CATCH_PLATFORM_WINDOWS)
-#define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
+    #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
 #endif
 
 ////////////////////////////////////////////////////////////////////////////////
 // We know some environments not to support full POSIX signals
 #if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
-#define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
+    #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
 #endif
 
 #ifdef __OS400__
@@ -237,9 +240,6 @@ unsigned int rngSeed();
 // Visual C++
 #if defined(_MSC_VER)
 
-#  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
-#  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )
-
 // Universal Windows platform does not support SEH
 // Or console colours (or console at all...)
 #  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
@@ -248,13 +248,18 @@ unsigned int rngSeed();
 #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
 #  endif
 
+#  if !defined(__clang__) // Handle Clang masquerading for msvc
+
 // MSVC traditional preprocessor needs some workaround for __VA_ARGS__
 // _MSVC_TRADITIONAL == 0 means new conformant preprocessor
 // _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor
-#  if !defined(__clang__) // Handle Clang masquerading for msvc
 #    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)
 #      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
 #    endif // MSVC_TRADITIONAL
+
+// Only do this if we're not using clang on Windows, which uses `diagnostic push` & `diagnostic pop`
+#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
+#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )
 #  endif // __clang__
 
 #endif // _MSC_VER
@@ -279,7 +284,7 @@ unsigned int rngSeed();
 ////////////////////////////////////////////////////////////////////////////////
 // Embarcadero C++Build
 #if defined(__BORLANDC__)
-#define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
+    #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
 #endif
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -290,7 +295,7 @@ unsigned int rngSeed();
 // Otherwise all supported compilers support COUNTER macro,
 // but user still might want to turn it off
 #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
-#define CATCH_INTERNAL_CONFIG_COUNTER
+    #define CATCH_INTERNAL_CONFIG_COUNTER
 #endif
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -299,7 +304,7 @@ unsigned int rngSeed();
 // This means that it is detected as Windows, but does not provide
 // the same set of capabilities as real Windows does.
 #if defined(UNDER_RTSS) || defined(RTX64_BUILD)
-#define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
+    #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
     #define CATCH_INTERNAL_CONFIG_NO_ASYNC
     #define CATCH_CONFIG_COLOUR_NONE
 #endif
@@ -310,28 +315,28 @@ unsigned int rngSeed();
 
 // Various stdlib support checks that require __has_include
 #if defined(__has_include)
-// Check if string_view is available and usable
-#if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)
-#    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
-#endif
-
-// Check if optional is available and usable
-#  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
-#    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
-#  endif // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
-
-// Check if byte is available and usable
-#  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
-#    include <cstddef>
-#    if __cpp_lib_byte > 0
-#      define CATCH_INTERNAL_CONFIG_CPP17_BYTE
-#    endif
-#  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
-
-// Check if variant is available and usable
-#  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
-#    if defined(__clang__) && (__clang_major__ < 8)
-// work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852
+  // Check if string_view is available and usable
+  #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)
+  #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
+  #endif
+
+  // Check if optional is available and usable
+  #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
+  #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
+  #  endif // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
+
+  // Check if byte is available and usable
+  #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
+  #    include <cstddef>
+  #    if defined(__cpp_lib_byte) && (__cpp_lib_byte > 0)
+  #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE
+  #    endif
+  #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
+
+  // Check if variant is available and usable
+  #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
+  #    if defined(__clang__) && (__clang_major__ < 8)
+         // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852
          // fix should be in clang 8, workaround in libstdc++ 8.2
   #      include <ciso646>
   #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
@@ -339,10 +344,10 @@ unsigned int rngSeed();
   #      else
   #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
   #      endif // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
-#    else
-#      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
-#    endif // defined(__clang__) && (__clang_major__ < 8)
-#  endif // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
+  #    else
+  #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
+  #    endif // defined(__clang__) && (__clang_major__ < 8)
+  #  endif // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
 #endif // defined(__has_include)
 
 #if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
@@ -478,61 +483,61 @@ std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);
 
 namespace Catch {
 
-struct CaseSensitive { enum Choice {
-    Yes,
-    No
-  }; };
+    struct CaseSensitive { enum Choice {
+        Yes,
+        No
+    }; };
 
-class NonCopyable {
-  NonCopyable( NonCopyable const& )              = delete;
-  NonCopyable( NonCopyable && )                  = delete;
-  NonCopyable& operator = ( NonCopyable const& ) = delete;
-  NonCopyable& operator = ( NonCopyable && )     = delete;
+    class NonCopyable {
+        NonCopyable( NonCopyable const& )              = delete;
+        NonCopyable( NonCopyable && )                  = delete;
+        NonCopyable& operator = ( NonCopyable const& ) = delete;
+        NonCopyable& operator = ( NonCopyable && )     = delete;
 
- protected:
-  NonCopyable();
-  virtual ~NonCopyable();
-};
+    protected:
+        NonCopyable();
+        virtual ~NonCopyable();
+    };
 
-struct SourceLineInfo {
+    struct SourceLineInfo {
 
-  SourceLineInfo() = delete;
-  SourceLineInfo( char const* _file, std::size_t _line ) noexcept
-      :   file( _file ),
-          line( _line )
-  {}
+        SourceLineInfo() = delete;
+        SourceLineInfo( char const* _file, std::size_t _line ) noexcept
+        :   file( _file ),
+            line( _line )
+        {}
 
-  SourceLineInfo( SourceLineInfo const& other )            = default;
-  SourceLineInfo& operator = ( SourceLineInfo const& )     = default;
-  SourceLineInfo( SourceLineInfo&& )              noexcept = default;
-  SourceLineInfo& operator = ( SourceLineInfo&& ) noexcept = default;
+        SourceLineInfo( SourceLineInfo const& other )            = default;
+        SourceLineInfo& operator = ( SourceLineInfo const& )     = default;
+        SourceLineInfo( SourceLineInfo&& )              noexcept = default;
+        SourceLineInfo& operator = ( SourceLineInfo&& ) noexcept = default;
 
-  bool empty() const noexcept { return file[0] == '\0'; }
-  bool operator == ( SourceLineInfo const& other ) const noexcept;
-  bool operator < ( SourceLineInfo const& other ) const noexcept;
+        bool empty() const noexcept { return file[0] == '\0'; }
+        bool operator == ( SourceLineInfo const& other ) const noexcept;
+        bool operator < ( SourceLineInfo const& other ) const noexcept;
 
-  char const* file;
-  std::size_t line;
-};
+        char const* file;
+        std::size_t line;
+    };
 
-std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
+    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
 
-// Bring in operator<< from global namespace into Catch namespace
-// This is necessary because the overload of operator<< above makes
-// lookup stop at namespace Catch
-using ::operator<<;
+    // Bring in operator<< from global namespace into Catch namespace
+    // This is necessary because the overload of operator<< above makes
+    // lookup stop at namespace Catch
+    using ::operator<<;
 
-// Use this in variadic streaming macros to allow
-//    >> +StreamEndStop
-// as well as
-//    >> stuff +StreamEndStop
-struct StreamEndStop {
-  std::string operator+() const;
-};
-template<typename T>
-T const& operator + ( T const& value, StreamEndStop ) {
-  return value;
-}
+    // Use this in variadic streaming macros to allow
+    //    >> +StreamEndStop
+    // as well as
+    //    >> stuff +StreamEndStop
+    struct StreamEndStop {
+        std::string operator+() const;
+    };
+    template<typename T>
+    T const& operator + ( T const& value, StreamEndStop ) {
+        return value;
+    }
 }
 
 #define CATCH_INTERNAL_LINEINFO \
@@ -541,9 +546,9 @@ T const& operator + ( T const& value, StreamEndStop ) {
 // end catch_common.h
 namespace Catch {
 
-struct RegistrarForTagAliases {
-  RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
-};
+    struct RegistrarForTagAliases {
+        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
+    };
 
 } // end namespace Catch
 
@@ -562,26 +567,26 @@ struct RegistrarForTagAliases {
 
 namespace Catch {
 
-class TestSpec;
+    class TestSpec;
 
-struct ITestInvoker {
-  virtual void invoke () const = 0;
-  virtual ~ITestInvoker();
-};
+    struct ITestInvoker {
+        virtual void invoke () const = 0;
+        virtual ~ITestInvoker();
+    };
 
-class TestCase;
-struct IConfig;
+    class TestCase;
+    struct IConfig;
 
-struct ITestCaseRegistry {
-  virtual ~ITestCaseRegistry();
-  virtual std::vector<TestCase> const& getAllTests() const = 0;
-  virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
-};
+    struct ITestCaseRegistry {
+        virtual ~ITestCaseRegistry();
+        virtual std::vector<TestCase> const& getAllTests() const = 0;
+        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
+    };
 
-bool isThrowSafe( TestCase const& testCase, IConfig const& config );
-bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
-std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
-std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );
+    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
+    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
+    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
 
 }
 
@@ -595,90 +600,90 @@ std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
 
 namespace Catch {
 
-/// A non-owning string class (similar to the forthcoming std::string_view)
-/// Note that, because a StringRef may be a substring of another string,
-/// it may not be null terminated.
-class StringRef {
- public:
-  using size_type = std::size_t;
-  using const_iterator = const char*;
+    /// A non-owning string class (similar to the forthcoming std::string_view)
+    /// Note that, because a StringRef may be a substring of another string,
+    /// it may not be null terminated.
+    class StringRef {
+    public:
+        using size_type = std::size_t;
+        using const_iterator = const char*;
 
- private:
-  static constexpr char const* const s_empty = "";
+    private:
+        static constexpr char const* const s_empty = "";
 
-  char const* m_start = s_empty;
-  size_type m_size = 0;
+        char const* m_start = s_empty;
+        size_type m_size = 0;
 
- public: // construction
-  constexpr StringRef() noexcept = default;
+    public: // construction
+        constexpr StringRef() noexcept = default;
 
-  StringRef( char const* rawChars ) noexcept;
+        StringRef( char const* rawChars ) noexcept;
 
-  constexpr StringRef( char const* rawChars, size_type size ) noexcept
-      :   m_start( rawChars ),
-          m_size( size )
-  {}
+        constexpr StringRef( char const* rawChars, size_type size ) noexcept
+        :   m_start( rawChars ),
+            m_size( size )
+        {}
 
-  StringRef( std::string const& stdString ) noexcept
-      :   m_start( stdString.c_str() ),
-          m_size( stdString.size() )
-  {}
+        StringRef( std::string const& stdString ) noexcept
+        :   m_start( stdString.c_str() ),
+            m_size( stdString.size() )
+        {}
 
-  explicit operator std::string() const {
-    return std::string(m_start, m_size);
-  }
+        explicit operator std::string() const {
+            return std::string(m_start, m_size);
+        }
 
- public: // operators
-  auto operator == ( StringRef const& other ) const noexcept -> bool;
-  auto operator != (StringRef const& other) const noexcept -> bool {
-    return !(*this == other);
-  }
+    public: // operators
+        auto operator == ( StringRef const& other ) const noexcept -> bool;
+        auto operator != (StringRef const& other) const noexcept -> bool {
+            return !(*this == other);
+        }
 
-  auto operator[] ( size_type index ) const noexcept -> char {
-    assert(index < m_size);
-    return m_start[index];
-  }
+        auto operator[] ( size_type index ) const noexcept -> char {
+            assert(index < m_size);
+            return m_start[index];
+        }
 
- public: // named queries
-  constexpr auto empty() const noexcept -> bool {
-    return m_size == 0;
-  }
-  constexpr auto size() const noexcept -> size_type {
-    return m_size;
-  }
+    public: // named queries
+        constexpr auto empty() const noexcept -> bool {
+            return m_size == 0;
+        }
+        constexpr auto size() const noexcept -> size_type {
+            return m_size;
+        }
 
-  // Returns the current start pointer. If the StringRef is not
-  // null-terminated, throws std::domain_exception
-  auto c_str() const -> char const*;
+        // Returns the current start pointer. If the StringRef is not
+        // null-terminated, throws std::domain_exception
+        auto c_str() const -> char const*;
 
- public: // substrings and searches
-  // Returns a substring of [start, start + length).
-  // If start + length > size(), then the substring is [start, size()).
-  // If start > size(), then the substring is empty.
-  auto substr( size_type start, size_type length ) const noexcept -> StringRef;
+    public: // substrings and searches
+        // Returns a substring of [start, start + length).
+        // If start + length > size(), then the substring is [start, size()).
+        // If start > size(), then the substring is empty.
+        auto substr( size_type start, size_type length ) const noexcept -> StringRef;
 
-  // Returns the current start pointer. May not be null-terminated.
-  auto data() const noexcept -> char const*;
+        // Returns the current start pointer. May not be null-terminated.
+        auto data() const noexcept -> char const*;
 
-  constexpr auto isNullTerminated() const noexcept -> bool {
-    return m_start[m_size] == '\0';
-  }
+        constexpr auto isNullTerminated() const noexcept -> bool {
+            return m_start[m_size] == '\0';
+        }
 
- public: // iterators
-  constexpr const_iterator begin() const { return m_start; }
-  constexpr const_iterator end() const { return m_start + m_size; }
-};
+    public: // iterators
+        constexpr const_iterator begin() const { return m_start; }
+        constexpr const_iterator end() const { return m_start + m_size; }
+    };
 
-auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;
-auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;
+    auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;
+    auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;
 
-constexpr auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
-  return StringRef( rawChars, size );
-}
+    constexpr auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
+        return StringRef( rawChars, size );
+    }
 } // namespace Catch
 
 constexpr auto operator "" _catch_sr( char const* rawChars, std::size_t size ) noexcept -> Catch::StringRef {
-  return Catch::StringRef( rawChars, size );
+    return Catch::StringRef( rawChars, size );
 }
 
 // end catch_stringref.h
@@ -916,30 +921,30 @@ constexpr auto operator "" _catch_sr( char const* rawChars, std::size_t size ) n
 #include <type_traits>
 
 namespace Catch {
-template<typename T>
-struct always_false : std::false_type {};
-
-template <typename> struct true_given : std::true_type {};
-struct is_callable_tester {
-  template <typename Fun, typename... Args>
-  true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);
-  template <typename...>
-  std::false_type static test(...);
-};
+    template<typename T>
+    struct always_false : std::false_type {};
+
+    template <typename> struct true_given : std::true_type {};
+    struct is_callable_tester {
+        template <typename Fun, typename... Args>
+        true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);
+        template <typename...>
+        std::false_type static test(...);
+    };
 
-template <typename T>
-struct is_callable;
+    template <typename T>
+    struct is_callable;
 
-template <typename Fun, typename... Args>
-struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};
+    template <typename Fun, typename... Args>
+    struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};
 
 #if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703
-// std::result_of is deprecated in C++17 and removed in C++20. Hence, it is
-// replaced with std::invoke_result here.
-template <typename Func, typename... U>
-using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;
+    // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is
+    // replaced with std::invoke_result here.
+    template <typename Func, typename... U>
+    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;
 #else
-// Keep ::type here because we still support C++11
+    // Keep ::type here because we still support C++11
     template <typename Func, typename... U>
     using FunctionReturnType = typename std::remove_reference<typename std::remove_cv<typename std::result_of<Func(U...)>::type>::type>::type;
 #endif
@@ -947,7 +952,7 @@ using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_
 } // namespace Catch
 
 namespace mpl_{
-struct na;
+    struct na;
 }
 
 // end catch_meta.hpp
@@ -955,38 +960,38 @@ namespace Catch {
 
 template<typename C>
 class TestInvokerAsMethod : public ITestInvoker {
-  void (C::*m_testAsMethod)();
- public:
-  TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
+    void (C::*m_testAsMethod)();
+public:
+    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
 
-  void invoke() const override {
-    C obj;
-    (obj.*m_testAsMethod)();
-  }
+    void invoke() const override {
+        C obj;
+        (obj.*m_testAsMethod)();
+    }
 };
 
 auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker*;
 
 template<typename C>
 auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {
-  return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );
+    return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );
 }
 
 struct NameAndTags {
-  NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;
-  StringRef name;
-  StringRef tags;
+    NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;
+    StringRef name;
+    StringRef tags;
 };
 
 struct AutoReg : NonCopyable {
-  AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
-  ~AutoReg();
+    AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
+    ~AutoReg();
 };
 
 } // end namespace Catch
 
 #if defined(CATCH_CONFIG_DISABLE)
-#define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
+    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
         static void TestName()
     #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
         namespace{                        \
@@ -1007,57 +1012,57 @@ struct AutoReg : NonCopyable {
 
     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
-            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, typename TestType, __VA_ARGS__ )
     #else
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
-            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
     #endif
 
     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
-            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, Signature, __VA_ARGS__ )
     #else
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
-            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, Signature, __VA_ARGS__ ) )
     #endif
 
     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
-            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
     #else
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
-            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
     #endif
 
     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
-            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
     #else
         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
-            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
     #endif
 #endif
 
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
         static void TestName(); \
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
         static void TestName()
-#define INTERNAL_CATCH_TESTCASE( ... ) \
-        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
+    #define INTERNAL_CATCH_TESTCASE( ... ) \
+        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ), __VA_ARGS__ )
 
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
 
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         namespace{ \
@@ -1068,18 +1073,18 @@ struct AutoReg : NonCopyable {
         } \
         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
         void TestName::test()
-#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
-        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
+        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ), ClassName, __VA_ARGS__ )
 
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
 
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
@@ -1109,22 +1114,22 @@ struct AutoReg : NonCopyable {
         INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, typename TestType, __VA_ARGS__ )
 #else
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
 #endif
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, Signature, __VA_ARGS__ )
 #else
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, Signature, __VA_ARGS__ ) )
 #endif
 
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
@@ -1158,22 +1163,22 @@ struct AutoReg : NonCopyable {
         static void TestFuncName()
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, typename T,__VA_ARGS__)
 #else
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, typename T, __VA_ARGS__ ) )
 #endif
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, Signature, __VA_ARGS__)
 #else
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, Signature, __VA_ARGS__ ) )
 #endif
 
-#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
@@ -1200,10 +1205,10 @@ struct AutoReg : NonCopyable {
         template<typename TestType>                                   \
         static void TestFunc()
 
-#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
-        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )
+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), Name, Tags, TmplList )
 
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
@@ -1233,22 +1238,22 @@ struct AutoReg : NonCopyable {
         INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
 #else
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
 #endif
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
 #else
-#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_C_L_A_S_S_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
 #endif
 
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
@@ -1285,22 +1290,22 @@ struct AutoReg : NonCopyable {
         void TestName<TestType>::test()
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
 #else
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
 #endif
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
 #else
-#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
 #endif
 
-#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
@@ -1331,7 +1336,7 @@ struct AutoReg : NonCopyable {
         void TestName<TestType>::test()
 
 #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
-        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )
+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_ ), INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_M_P_L_A_T_E_T_E_S_T_F_U_N_C_ ), ClassName, Name, Tags, TmplList )
 
 // end catch_test_registry.h
 // start catch_capture.hpp
@@ -1344,61 +1349,61 @@ struct AutoReg : NonCopyable {
 
 namespace Catch {
 
-// ResultWas::OfType enum
-struct ResultWas { enum OfType {
-    Unknown = -1,
-    Ok = 0,
-    Info = 1,
-    Warning = 2,
+    // ResultWas::OfType enum
+    struct ResultWas { enum OfType {
+        Unknown = -1,
+        Ok = 0,
+        Info = 1,
+        Warning = 2,
 
-    FailureBit = 0x10,
+        FailureBit = 0x10,
 
-    ExpressionFailed = FailureBit | 1,
-    ExplicitFailure = FailureBit | 2,
+        ExpressionFailed = FailureBit | 1,
+        ExplicitFailure = FailureBit | 2,
 
-    Exception = 0x100 | FailureBit,
+        Exception = 0x100 | FailureBit,
 
-    ThrewException = Exception | 1,
-    DidntThrowException = Exception | 2,
+        ThrewException = Exception | 1,
+        DidntThrowException = Exception | 2,
 
-    FatalErrorCondition = 0x200 | FailureBit
+        FatalErrorCondition = 0x200 | FailureBit
 
-  }; };
+    }; };
 
-bool isOk( ResultWas::OfType resultType );
-bool isJustInfo( int flags );
+    bool isOk( ResultWas::OfType resultType );
+    bool isJustInfo( int flags );
 
-// ResultDisposition::Flags enum
-struct ResultDisposition { enum Flags {
-    Normal = 0x01,
+    // ResultDisposition::Flags enum
+    struct ResultDisposition { enum Flags {
+        Normal = 0x01,
 
-    ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
-    FalseTest = 0x04,           // Prefix expression with !
-    SuppressFail = 0x08         // Failures are reported but do not fail the test
-  }; };
+        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
+        FalseTest = 0x04,           // Prefix expression with !
+        SuppressFail = 0x08         // Failures are reported but do not fail the test
+    }; };
 
-ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
+    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
 
-bool shouldContinueOnFailure( int flags );
-inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
-bool shouldSuppressFailure( int flags );
+    bool shouldContinueOnFailure( int flags );
+    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
+    bool shouldSuppressFailure( int flags );
 
 } // end namespace Catch
 
 // end catch_result_type.h
 namespace Catch {
 
-struct AssertionInfo
-{
-  StringRef macroName;
-  SourceLineInfo lineInfo;
-  StringRef capturedExpression;
-  ResultDisposition::Flags resultDisposition;
-
-  // We want to delete this constructor but a compiler bug in 4.8 means
-  // the struct is then treated as non-aggregate
-  //AssertionInfo() = delete;
-};
+    struct AssertionInfo
+    {
+        StringRef macroName;
+        SourceLineInfo lineInfo;
+        StringRef capturedExpression;
+        ResultDisposition::Flags resultDisposition;
+
+        // We want to delete this constructor but a compiler bug in 4.8 means
+        // the struct is then treated as non-aggregate
+        //AssertionInfo() = delete;
+    };
 
 } // end namespace Catch
 
@@ -1419,35 +1424,35 @@ struct AssertionInfo
 
 namespace Catch {
 
-std::ostream& cout();
-std::ostream& cerr();
-std::ostream& clog();
+    std::ostream& cout();
+    std::ostream& cerr();
+    std::ostream& clog();
 
-class StringRef;
+    class StringRef;
 
-struct IStream {
-  virtual ~IStream();
-  virtual std::ostream& stream() const = 0;
-};
+    struct IStream {
+        virtual ~IStream();
+        virtual std::ostream& stream() const = 0;
+    };
 
-auto makeStream( StringRef const &filename ) -> IStream const*;
+    auto makeStream( StringRef const &filename ) -> IStream const*;
 
-class ReusableStringStream : NonCopyable {
-  std::size_t m_index;
-  std::ostream* m_oss;
- public:
-  ReusableStringStream();
-  ~ReusableStringStream();
+    class ReusableStringStream : NonCopyable {
+        std::size_t m_index;
+        std::ostream* m_oss;
+    public:
+        ReusableStringStream();
+        ~ReusableStringStream();
 
-  auto str() const -> std::string;
+        auto str() const -> std::string;
 
-  template<typename T>
-  auto operator << ( T const& value ) -> ReusableStringStream& {
-    *m_oss << value;
-    return *this;
-  }
-  auto get() -> std::ostream& { return *m_oss; }
-};
+        template<typename T>
+        auto operator << ( T const& value ) -> ReusableStringStream& {
+            *m_oss << value;
+            return *this;
+        }
+        auto get() -> std::ostream& { return *m_oss; }
+    };
 }
 
 // end catch_stream.h
@@ -1457,32 +1462,32 @@ class ReusableStringStream : NonCopyable {
 
 namespace Catch {
 
-namespace Detail {
-struct EnumInfo {
-  StringRef m_name;
-  std::vector<std::pair<int, StringRef>> m_values;
+    namespace Detail {
+        struct EnumInfo {
+            StringRef m_name;
+            std::vector<std::pair<int, StringRef>> m_values;
 
-  ~EnumInfo();
+            ~EnumInfo();
 
-  StringRef lookup( int value ) const;
-};
-} // namespace Detail
+            StringRef lookup( int value ) const;
+        };
+    } // namespace Detail
 
-struct IMutableEnumValuesRegistry {
-  virtual ~IMutableEnumValuesRegistry();
+    struct IMutableEnumValuesRegistry {
+        virtual ~IMutableEnumValuesRegistry();
 
-  virtual Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values ) = 0;
+        virtual Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values ) = 0;
 
-  template<typename E>
-  Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) {
-    static_assert(sizeof(int) >= sizeof(E), "Cannot serialize enum to int");
-    std::vector<int> intValues;
-    intValues.reserve( values.size() );
-    for( auto enumValue : values )
-      intValues.push_back( static_cast<int>( enumValue ) );
-    return registerEnum( enumName, allEnums, intValues );
-  }
-};
+        template<typename E>
+        Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) {
+            static_assert(sizeof(int) >= sizeof(E), "Cannot serialize enum to int");
+            std::vector<int> intValues;
+            intValues.reserve( values.size() );
+            for( auto enumValue : values )
+                intValues.push_back( static_cast<int>( enumValue ) );
+            return registerEnum( enumName, allEnums, intValues );
+        }
+    };
 
 } // Catch
 
@@ -1544,55 +1549,55 @@ inline id performOptionalSelector( id obj, SEL sel ) {
 #endif
 
 namespace Catch {
-namespace Detail {
+    namespace Detail {
 
-extern const std::string unprintableString;
+        extern const std::string unprintableString;
 
-std::string rawMemoryToString( const void *object, std::size_t size );
+        std::string rawMemoryToString( const void *object, std::size_t size );
 
-template<typename T>
-std::string rawMemoryToString( const T& object ) {
-  return rawMemoryToString( &object, sizeof(object) );
-}
+        template<typename T>
+        std::string rawMemoryToString( const T& object ) {
+          return rawMemoryToString( &object, sizeof(object) );
+        }
 
-template<typename T>
-class IsStreamInsertable {
-  template<typename Stream, typename U>
-  static auto test(int)
-  -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());
+        template<typename T>
+        class IsStreamInsertable {
+            template<typename Stream, typename U>
+            static auto test(int)
+                -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());
 
-  template<typename, typename>
-  static auto test(...)->std::false_type;
+            template<typename, typename>
+            static auto test(...)->std::false_type;
 
- public:
-  static const bool value = decltype(test<std::ostream, const T&>(0))::value;
-};
+        public:
+            static const bool value = decltype(test<std::ostream, const T&>(0))::value;
+        };
 
-template<typename E>
-std::string convertUnknownEnumToString( E e );
+        template<typename E>
+        std::string convertUnknownEnumToString( E e );
 
-template<typename T>
-typename std::enable_if<
-    !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
-    std::string>::type convertUnstreamable( T const& ) {
-  return Detail::unprintableString;
-}
-template<typename T>
-typename std::enable_if<
-    !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
-    std::string>::type convertUnstreamable(T const& ex) {
-  return ex.what();
-}
+        template<typename T>
+        typename std::enable_if<
+            !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
+        std::string>::type convertUnstreamable( T const& ) {
+            return Detail::unprintableString;
+        }
+        template<typename T>
+        typename std::enable_if<
+            !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
+         std::string>::type convertUnstreamable(T const& ex) {
+            return ex.what();
+        }
 
-template<typename T>
-typename std::enable_if<
-    std::is_enum<T>::value
-    , std::string>::type convertUnstreamable( T const& value ) {
-  return convertUnknownEnumToString( value );
-}
+        template<typename T>
+        typename std::enable_if<
+            std::is_enum<T>::value
+        , std::string>::type convertUnstreamable( T const& value ) {
+            return convertUnknownEnumToString( value );
+        }
 
 #if defined(_MANAGED)
-//! Convert a CLR string to a utf8 std::string
+        //! Convert a CLR string to a utf8 std::string
         template<typename T>
         std::string clrReferenceToString( T^ ref ) {
             if (ref == nullptr)
@@ -1603,215 +1608,215 @@ typename std::enable_if<
         }
 #endif
 
-} // namespace Detail
+    } // namespace Detail
 
-// If we decide for C++14, change these to enable_if_ts
-template <typename T, typename = void>
-struct StringMaker {
-  template <typename Fake = T>
-  static
-  typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
-  convert(const Fake& value) {
-    ReusableStringStream rss;
-    // NB: call using the function-like syntax to avoid ambiguity with
-    // user-defined templated operator<< under clang.
-    rss.operator<<(value);
-    return rss.str();
-  }
+    // If we decide for C++14, change these to enable_if_ts
+    template <typename T, typename = void>
+    struct StringMaker {
+        template <typename Fake = T>
+        static
+        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
+            convert(const Fake& value) {
+                ReusableStringStream rss;
+                // NB: call using the function-like syntax to avoid ambiguity with
+                // user-defined templated operator<< under clang.
+                rss.operator<<(value);
+                return rss.str();
+        }
 
-  template <typename Fake = T>
-  static
-  typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
-  convert( const Fake& value ) {
+        template <typename Fake = T>
+        static
+        typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
+            convert( const Fake& value ) {
 #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
-    return Detail::convertUnstreamable(value);
+            return Detail::convertUnstreamable(value);
 #else
-    return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
+            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
 #endif
-  }
-};
+        }
+    };
 
-namespace Detail {
+    namespace Detail {
 
-// This function dispatches all stringification requests inside of Catch.
-// Should be preferably called fully qualified, like ::Catch::Detail::stringify
-template <typename T>
-std::string stringify(const T& e) {
-  return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
-}
+        // This function dispatches all stringification requests inside of Catch.
+        // Should be preferably called fully qualified, like ::Catch::Detail::stringify
+        template <typename T>
+        std::string stringify(const T& e) {
+            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
+        }
 
-template<typename E>
-std::string convertUnknownEnumToString( E e ) {
-  return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));
-}
+        template<typename E>
+        std::string convertUnknownEnumToString( E e ) {
+            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));
+        }
 
 #if defined(_MANAGED)
-template <typename T>
+        template <typename T>
         std::string stringify( T^ e ) {
             return ::Catch::StringMaker<T^>::convert(e);
         }
 #endif
 
-} // namespace Detail
+    } // namespace Detail
 
-// Some predefined specializations
+    // Some predefined specializations
 
-template<>
-struct StringMaker<std::string> {
-  static std::string convert(const std::string& str);
-};
+    template<>
+    struct StringMaker<std::string> {
+        static std::string convert(const std::string& str);
+    };
 
 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW
-template<>
-struct StringMaker<std::string_view> {
-  static std::string convert(std::string_view str);
-};
+    template<>
+    struct StringMaker<std::string_view> {
+        static std::string convert(std::string_view str);
+    };
 #endif
 
-template<>
-struct StringMaker<char const *> {
-  static std::string convert(char const * str);
-};
-template<>
-struct StringMaker<char *> {
-  static std::string convert(char * str);
-};
+    template<>
+    struct StringMaker<char const *> {
+        static std::string convert(char const * str);
+    };
+    template<>
+    struct StringMaker<char *> {
+        static std::string convert(char * str);
+    };
 
 #ifdef CATCH_CONFIG_WCHAR
-template<>
-struct StringMaker<std::wstring> {
-  static std::string convert(const std::wstring& wstr);
-};
+    template<>
+    struct StringMaker<std::wstring> {
+        static std::string convert(const std::wstring& wstr);
+    };
 
 # ifdef CATCH_CONFIG_CPP17_STRING_VIEW
-template<>
-struct StringMaker<std::wstring_view> {
-  static std::string convert(std::wstring_view str);
-};
+    template<>
+    struct StringMaker<std::wstring_view> {
+        static std::string convert(std::wstring_view str);
+    };
 # endif
 
-template<>
-struct StringMaker<wchar_t const *> {
-  static std::string convert(wchar_t const * str);
-};
-template<>
-struct StringMaker<wchar_t *> {
-  static std::string convert(wchar_t * str);
-};
+    template<>
+    struct StringMaker<wchar_t const *> {
+        static std::string convert(wchar_t const * str);
+    };
+    template<>
+    struct StringMaker<wchar_t *> {
+        static std::string convert(wchar_t * str);
+    };
 #endif
 
-// TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,
-//      while keeping string semantics?
-template<int SZ>
-struct StringMaker<char[SZ]> {
-  static std::string convert(char const* str) {
-    return ::Catch::Detail::stringify(std::string{ str });
-  }
-};
-template<int SZ>
-struct StringMaker<signed char[SZ]> {
-  static std::string convert(signed char const* str) {
-    return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
-  }
-};
-template<int SZ>
-struct StringMaker<unsigned char[SZ]> {
-  static std::string convert(unsigned char const* str) {
-    return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
-  }
-};
+    // TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,
+    //      while keeping string semantics?
+    template<int SZ>
+    struct StringMaker<char[SZ]> {
+        static std::string convert(char const* str) {
+            return ::Catch::Detail::stringify(std::string{ str });
+        }
+    };
+    template<int SZ>
+    struct StringMaker<signed char[SZ]> {
+        static std::string convert(signed char const* str) {
+            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
+        }
+    };
+    template<int SZ>
+    struct StringMaker<unsigned char[SZ]> {
+        static std::string convert(unsigned char const* str) {
+            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
+        }
+    };
 
 #if defined(CATCH_CONFIG_CPP17_BYTE)
-template<>
-struct StringMaker<std::byte> {
-  static std::string convert(std::byte value);
-};
+    template<>
+    struct StringMaker<std::byte> {
+        static std::string convert(std::byte value);
+    };
 #endif // defined(CATCH_CONFIG_CPP17_BYTE)
-template<>
-struct StringMaker<int> {
-  static std::string convert(int value);
-};
-template<>
-struct StringMaker<long> {
-  static std::string convert(long value);
-};
-template<>
-struct StringMaker<long long> {
-  static std::string convert(long long value);
-};
-template<>
-struct StringMaker<unsigned int> {
-  static std::string convert(unsigned int value);
-};
-template<>
-struct StringMaker<unsigned long> {
-  static std::string convert(unsigned long value);
-};
-template<>
-struct StringMaker<unsigned long long> {
-  static std::string convert(unsigned long long value);
-};
+    template<>
+    struct StringMaker<int> {
+        static std::string convert(int value);
+    };
+    template<>
+    struct StringMaker<long> {
+        static std::string convert(long value);
+    };
+    template<>
+    struct StringMaker<long long> {
+        static std::string convert(long long value);
+    };
+    template<>
+    struct StringMaker<unsigned int> {
+        static std::string convert(unsigned int value);
+    };
+    template<>
+    struct StringMaker<unsigned long> {
+        static std::string convert(unsigned long value);
+    };
+    template<>
+    struct StringMaker<unsigned long long> {
+        static std::string convert(unsigned long long value);
+    };
 
-template<>
-struct StringMaker<bool> {
-  static std::string convert(bool b);
-};
+    template<>
+    struct StringMaker<bool> {
+        static std::string convert(bool b);
+    };
 
-template<>
-struct StringMaker<char> {
-  static std::string convert(char c);
-};
-template<>
-struct StringMaker<signed char> {
-  static std::string convert(signed char c);
-};
-template<>
-struct StringMaker<unsigned char> {
-  static std::string convert(unsigned char c);
-};
+    template<>
+    struct StringMaker<char> {
+        static std::string convert(char c);
+    };
+    template<>
+    struct StringMaker<signed char> {
+        static std::string convert(signed char c);
+    };
+    template<>
+    struct StringMaker<unsigned char> {
+        static std::string convert(unsigned char c);
+    };
 
-template<>
-struct StringMaker<std::nullptr_t> {
-  static std::string convert(std::nullptr_t);
-};
+    template<>
+    struct StringMaker<std::nullptr_t> {
+        static std::string convert(std::nullptr_t);
+    };
 
-template<>
-struct StringMaker<float> {
-  static std::string convert(float value);
-  static int precision;
-};
+    template<>
+    struct StringMaker<float> {
+        static std::string convert(float value);
+        static int precision;
+    };
 
-template<>
-struct StringMaker<double> {
-  static std::string convert(double value);
-  static int precision;
-};
+    template<>
+    struct StringMaker<double> {
+        static std::string convert(double value);
+        static int precision;
+    };
 
-template <typename T>
-struct StringMaker<T*> {
-  template <typename U>
-  static std::string convert(U* p) {
-    if (p) {
-      return ::Catch::Detail::rawMemoryToString(p);
-    } else {
-      return "nullptr";
-    }
-  }
-};
+    template <typename T>
+    struct StringMaker<T*> {
+        template <typename U>
+        static std::string convert(U* p) {
+            if (p) {
+                return ::Catch::Detail::rawMemoryToString(p);
+            } else {
+                return "nullptr";
+            }
+        }
+    };
 
-template <typename R, typename C>
-struct StringMaker<R C::*> {
-  static std::string convert(R C::* p) {
-    if (p) {
-      return ::Catch::Detail::rawMemoryToString(p);
-    } else {
-      return "nullptr";
-    }
-  }
-};
+    template <typename R, typename C>
+    struct StringMaker<R C::*> {
+        static std::string convert(R C::* p) {
+            if (p) {
+                return ::Catch::Detail::rawMemoryToString(p);
+            } else {
+                return "nullptr";
+            }
+        }
+    };
 
 #if defined(_MANAGED)
-template <typename T>
+    template <typename T>
     struct StringMaker<T^> {
         static std::string convert( T^ ref ) {
             return ::Catch::Detail::clrReferenceToString(ref);
@@ -1819,23 +1824,23 @@ template <typename T>
     };
 #endif
 
-namespace Detail {
-template<typename InputIterator, typename Sentinel = InputIterator>
-std::string rangeToString(InputIterator first, Sentinel last) {
-  ReusableStringStream rss;
-  rss << "{ ";
-  if (first != last) {
-    rss << ::Catch::Detail::stringify(*first);
-    for (++first; first != last; ++first)
-      rss << ", " << ::Catch::Detail::stringify(*first);
-  }
-  rss << " }";
-  return rss.str();
-}
-}
+    namespace Detail {
+        template<typename InputIterator, typename Sentinel = InputIterator>
+        std::string rangeToString(InputIterator first, Sentinel last) {
+            ReusableStringStream rss;
+            rss << "{ ";
+            if (first != last) {
+                rss << ::Catch::Detail::stringify(*first);
+                for (++first; first != last; ++first)
+                    rss << ", " << ::Catch::Detail::stringify(*first);
+            }
+            rss << " }";
+            return rss.str();
+        }
+    }
 
 #ifdef __OBJC__
-template<>
+    template<>
     struct StringMaker<NSString*> {
         static std::string convert(NSString * nsstring) {
             if (!nsstring)
@@ -1979,71 +1984,71 @@ namespace Catch {
 #endif // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
 
 namespace Catch {
-// Import begin/ end from std here
-using std::begin;
-using std::end;
-
-namespace detail {
-template <typename...>
-struct void_type {
-  using type = void;
-};
+    // Import begin/ end from std here
+    using std::begin;
+    using std::end;
+
+    namespace detail {
+        template <typename...>
+        struct void_type {
+            using type = void;
+        };
 
-template <typename T, typename = void>
-struct is_range_impl : std::false_type {
-};
+        template <typename T, typename = void>
+        struct is_range_impl : std::false_type {
+        };
 
-template <typename T>
-struct is_range_impl<T, typename void_type<decltype(begin(std::declval<T>()))>::type> : std::true_type {
-};
-} // namespace detail
+        template <typename T>
+        struct is_range_impl<T, typename void_type<decltype(begin(std::declval<T>()))>::type> : std::true_type {
+        };
+    } // namespace detail
 
-template <typename T>
-struct is_range : detail::is_range_impl<T> {
-};
+    template <typename T>
+    struct is_range : detail::is_range_impl<T> {
+    };
 
 #if defined(_MANAGED) // Managed types are never ranges
-template <typename T>
+    template <typename T>
     struct is_range<T^> {
         static const bool value = false;
     };
 #endif
 
-template<typename Range>
-std::string rangeToString( Range const& range ) {
-  return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
-}
+    template<typename Range>
+    std::string rangeToString( Range const& range ) {
+        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
+    }
 
-// Handle vector<bool> specially
-template<typename Allocator>
-std::string rangeToString( std::vector<bool, Allocator> const& v ) {
-  ReusableStringStream rss;
-  rss << "{ ";
-  bool first = true;
-  for( bool b : v ) {
-    if( first )
-      first = false;
-    else
-      rss << ", ";
-    rss << ::Catch::Detail::stringify( b );
-  }
-  rss << " }";
-  return rss.str();
-}
+    // Handle vector<bool> specially
+    template<typename Allocator>
+    std::string rangeToString( std::vector<bool, Allocator> const& v ) {
+        ReusableStringStream rss;
+        rss << "{ ";
+        bool first = true;
+        for( bool b : v ) {
+            if( first )
+                first = false;
+            else
+                rss << ", ";
+            rss << ::Catch::Detail::stringify( b );
+        }
+        rss << " }";
+        return rss.str();
+    }
 
-template<typename R>
-struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {
-  static std::string convert( R const& range ) {
-    return rangeToString( range );
-  }
-};
+    template<typename R>
+    struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {
+        static std::string convert( R const& range ) {
+            return rangeToString( range );
+        }
+    };
 
-template <typename T, int SZ>
-struct StringMaker<T[SZ]> {
-  static std::string convert(T const(&arr)[SZ]) {
-    return rangeToString(arr);
-  }
-};
+    template <typename T, int SZ>
+    struct StringMaker<T[SZ]> {
+        static std::string convert(T const(&arr)[SZ]) {
+            return rangeToString(arr);
+        }
+    };
 
 } // namespace Catch
 
@@ -2194,228 +2199,228 @@ namespace Catch { \
 
 namespace Catch {
 
-struct ITransientExpression {
-  auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
-  auto getResult() const -> bool { return m_result; }
-  virtual void streamReconstructedExpression( std::ostream &os ) const = 0;
+    struct ITransientExpression {
+        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
+        auto getResult() const -> bool { return m_result; }
+        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;
 
-  ITransientExpression( bool isBinaryExpression, bool result )
-      :   m_isBinaryExpression( isBinaryExpression ),
-          m_result( result )
-  {}
+        ITransientExpression( bool isBinaryExpression, bool result )
+        :   m_isBinaryExpression( isBinaryExpression ),
+            m_result( result )
+        {}
 
-  // We don't actually need a virtual destructor, but many static analysers
-  // complain if it's not here :-(
-  virtual ~ITransientExpression();
+        // We don't actually need a virtual destructor, but many static analysers
+        // complain if it's not here :-(
+        virtual ~ITransientExpression();
 
-  bool m_isBinaryExpression;
-  bool m_result;
+        bool m_isBinaryExpression;
+        bool m_result;
 
-};
+    };
 
-void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
+    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
 
-template<typename LhsT, typename RhsT>
-class BinaryExpr  : public ITransientExpression {
-  LhsT m_lhs;
-  StringRef m_op;
-  RhsT m_rhs;
+    template<typename LhsT, typename RhsT>
+    class BinaryExpr  : public ITransientExpression {
+        LhsT m_lhs;
+        StringRef m_op;
+        RhsT m_rhs;
 
-  void streamReconstructedExpression( std::ostream &os ) const override {
-    formatReconstructedExpression
-        ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
-  }
+        void streamReconstructedExpression( std::ostream &os ) const override {
+            formatReconstructedExpression
+                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
+        }
 
- public:
-  BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
-      :   ITransientExpression{ true, comparisonResult },
-          m_lhs( lhs ),
-          m_op( op ),
-          m_rhs( rhs )
-  {}
-
-  template<typename T>
-  auto operator && ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+    public:
+        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
+        :   ITransientExpression{ true, comparisonResult },
+            m_lhs( lhs ),
+            m_op( op ),
+            m_rhs( rhs )
+        {}
 
-  template<typename T>
-  auto operator || ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename T>
+        auto operator && ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  template<typename T>
-  auto operator == ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename T>
+        auto operator || ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  template<typename T>
-  auto operator != ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename T>
+        auto operator == ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  template<typename T>
-  auto operator > ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename T>
+        auto operator != ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  template<typename T>
-  auto operator < ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename T>
+        auto operator > ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  template<typename T>
-  auto operator >= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename T>
+        auto operator < ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  template<typename T>
-  auto operator <= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<T>::value,
-                  "chained comparisons are not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
-};
+        template<typename T>
+        auto operator >= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-template<typename LhsT>
-class UnaryExpr : public ITransientExpression {
-  LhsT m_lhs;
+        template<typename T>
+        auto operator <= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+    };
 
-  void streamReconstructedExpression( std::ostream &os ) const override {
-    os << Catch::Detail::stringify( m_lhs );
-  }
+    template<typename LhsT>
+    class UnaryExpr : public ITransientExpression {
+        LhsT m_lhs;
 
- public:
-  explicit UnaryExpr( LhsT lhs )
-      :   ITransientExpression{ false, static_cast<bool>(lhs) },
-          m_lhs( lhs )
-  {}
-};
+        void streamReconstructedExpression( std::ostream &os ) const override {
+            os << Catch::Detail::stringify( m_lhs );
+        }
 
-// Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
-template<typename LhsT, typename RhsT>
-auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
-template<typename T>
-auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
-template<typename T>
-auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
-template<typename T>
-auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
-template<typename T>
-auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
+    public:
+        explicit UnaryExpr( LhsT lhs )
+        :   ITransientExpression{ false, static_cast<bool>(lhs) },
+            m_lhs( lhs )
+        {}
+    };
 
-template<typename LhsT, typename RhsT>
-auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
-template<typename T>
-auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
-template<typename T>
-auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
-template<typename T>
-auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
-template<typename T>
-auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
+    // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
+    template<typename LhsT, typename RhsT>
+    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
+    template<typename T>
+    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
+    template<typename T>
+    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
 
-template<typename LhsT>
-class ExprLhs {
-  LhsT m_lhs;
- public:
-  explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
+    template<typename LhsT, typename RhsT>
+    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
+    template<typename T>
+    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
+    template<typename T>
+    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
 
-  template<typename RhsT>
-  auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { compareEqual( m_lhs, rhs ), m_lhs, "==", rhs };
-  }
-  auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
-    return { m_lhs == rhs, m_lhs, "==", rhs };
-  }
+    template<typename LhsT>
+    class ExprLhs {
+        LhsT m_lhs;
+    public:
+        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
 
-  template<typename RhsT>
-  auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { compareNotEqual( m_lhs, rhs ), m_lhs, "!=", rhs };
-  }
-  auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
-    return { m_lhs != rhs, m_lhs, "!=", rhs };
-  }
+        template<typename RhsT>
+        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { compareEqual( m_lhs, rhs ), m_lhs, "==", rhs };
+        }
+        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
+            return { m_lhs == rhs, m_lhs, "==", rhs };
+        }
 
-  template<typename RhsT>
-  auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs > rhs), m_lhs, ">", rhs };
-  }
-  template<typename RhsT>
-  auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs < rhs), m_lhs, "<", rhs };
-  }
-  template<typename RhsT>
-  auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">=", rhs };
-  }
-  template<typename RhsT>
-  auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<=", rhs };
-  }
-  template <typename RhsT>
-  auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs | rhs), m_lhs, "|", rhs };
-  }
-  template <typename RhsT>
-  auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs & rhs), m_lhs, "&", rhs };
-  }
-  template <typename RhsT>
-  auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
-    return { static_cast<bool>(m_lhs ^ rhs), m_lhs, "^", rhs };
-  }
+        template<typename RhsT>
+        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { compareNotEqual( m_lhs, rhs ), m_lhs, "!=", rhs };
+        }
+        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
+            return { m_lhs != rhs, m_lhs, "!=", rhs };
+        }
 
-  template<typename RhsT>
-  auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<RhsT>::value,
-                  "operator&& is not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename RhsT>
+        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs > rhs), m_lhs, ">", rhs };
+        }
+        template<typename RhsT>
+        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs < rhs), m_lhs, "<", rhs };
+        }
+        template<typename RhsT>
+        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">=", rhs };
+        }
+        template<typename RhsT>
+        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<=", rhs };
+        }
+        template <typename RhsT>
+        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs | rhs), m_lhs, "|", rhs };
+        }
+        template <typename RhsT>
+        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs & rhs), m_lhs, "&", rhs };
+        }
+        template <typename RhsT>
+        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, "^", rhs };
+        }
 
-  template<typename RhsT>
-  auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
-    static_assert(always_false<RhsT>::value,
-                  "operator|| is not supported inside assertions, "
-                  "wrap the expression inside parentheses, or decompose it");
-  }
+        template<typename RhsT>
+        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<RhsT>::value,
+            "operator&& is not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
 
-  auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
-    return UnaryExpr<LhsT>{ m_lhs };
-  }
-};
+        template<typename RhsT>
+        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<RhsT>::value,
+            "operator|| is not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
+            return UnaryExpr<LhsT>{ m_lhs };
+        }
+    };
 
-void handleExpression( ITransientExpression const& expr );
+    void handleExpression( ITransientExpression const& expr );
 
-template<typename T>
-void handleExpression( ExprLhs<T> const& expr ) {
-  handleExpression( expr.makeUnaryExpr() );
-}
+    template<typename T>
+    void handleExpression( ExprLhs<T> const& expr ) {
+        handleExpression( expr.makeUnaryExpr() );
+    }
 
-struct Decomposer {
-  template<typename T>
-  auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
-    return ExprLhs<T const&>{ lhs };
-  }
+    struct Decomposer {
+        template<typename T>
+        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
+            return ExprLhs<T const&>{ lhs };
+        }
 
-  auto operator <=( bool value ) -> ExprLhs<bool> {
-    return ExprLhs<bool>{ value };
-  }
-};
+        auto operator <=( bool value ) -> ExprLhs<bool> {
+            return ExprLhs<bool>{ value };
+        }
+    };
 
 } // end namespace Catch
 
@@ -2431,155 +2436,155 @@ struct Decomposer {
 
 namespace Catch {
 
-class AssertionResult;
-struct AssertionInfo;
-struct SectionInfo;
-struct SectionEndInfo;
-struct MessageInfo;
-struct MessageBuilder;
-struct Counts;
-struct AssertionReaction;
-struct SourceLineInfo;
+    class AssertionResult;
+    struct AssertionInfo;
+    struct SectionInfo;
+    struct SectionEndInfo;
+    struct MessageInfo;
+    struct MessageBuilder;
+    struct Counts;
+    struct AssertionReaction;
+    struct SourceLineInfo;
 
-struct ITransientExpression;
-struct IGeneratorTracker;
+    struct ITransientExpression;
+    struct IGeneratorTracker;
 
 #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
-struct BenchmarkInfo;
+    struct BenchmarkInfo;
     template <typename Duration = std::chrono::duration<double, std::nano>>
     struct BenchmarkStats;
 #endif // CATCH_CONFIG_ENABLE_BENCHMARKING
 
-struct IResultCapture {
+    struct IResultCapture {
 
-  virtual ~IResultCapture();
+        virtual ~IResultCapture();
 
-  virtual bool sectionStarted(    SectionInfo const& sectionInfo,
-                                  Counts& assertions ) = 0;
-  virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
-  virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
+        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
+                                        Counts& assertions ) = 0;
+        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
+        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
 
-  virtual auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;
+        virtual auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;
 
 #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
-  virtual void benchmarkPreparing( std::string const& name ) = 0;
+        virtual void benchmarkPreparing( std::string const& name ) = 0;
         virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
         virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;
         virtual void benchmarkFailed( std::string const& error ) = 0;
 #endif // CATCH_CONFIG_ENABLE_BENCHMARKING
 
-  virtual void pushScopedMessage( MessageInfo const& message ) = 0;
-  virtual void popScopedMessage( MessageInfo const& message ) = 0;
-
-  virtual void emplaceUnscopedMessage( MessageBuilder const& builder ) = 0;
-
-  virtual void handleFatalErrorCondition( StringRef message ) = 0;
-
-  virtual void handleExpr
-      (   AssertionInfo const& info,
-          ITransientExpression const& expr,
-          AssertionReaction& reaction ) = 0;
-  virtual void handleMessage
-      (   AssertionInfo const& info,
-          ResultWas::OfType resultType,
-          StringRef const& message,
-          AssertionReaction& reaction ) = 0;
-  virtual void handleUnexpectedExceptionNotThrown
-      (   AssertionInfo const& info,
-          AssertionReaction& reaction ) = 0;
-  virtual void handleUnexpectedInflightException
-      (   AssertionInfo const& info,
-          std::string const& message,
-          AssertionReaction& reaction ) = 0;
-  virtual void handleIncomplete
-      (   AssertionInfo const& info ) = 0;
-  virtual void handleNonExpr
-      (   AssertionInfo const &info,
-          ResultWas::OfType resultType,
-          AssertionReaction &reaction ) = 0;
-
-  virtual bool lastAssertionPassed() = 0;
-  virtual void assertionPassed() = 0;
-
-  // Deprecated, do not use:
-  virtual std::string getCurrentTestName() const = 0;
-  virtual const AssertionResult* getLastResult() const = 0;
-  virtual void exceptionEarlyReported() = 0;
-};
+        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
+        virtual void popScopedMessage( MessageInfo const& message ) = 0;
+
+        virtual void emplaceUnscopedMessage( MessageBuilder const& builder ) = 0;
+
+        virtual void handleFatalErrorCondition( StringRef message ) = 0;
+
+        virtual void handleExpr
+                (   AssertionInfo const& info,
+                    ITransientExpression const& expr,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleMessage
+                (   AssertionInfo const& info,
+                    ResultWas::OfType resultType,
+                    StringRef const& message,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleUnexpectedExceptionNotThrown
+                (   AssertionInfo const& info,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleUnexpectedInflightException
+                (   AssertionInfo const& info,
+                    std::string const& message,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleIncomplete
+                (   AssertionInfo const& info ) = 0;
+        virtual void handleNonExpr
+                (   AssertionInfo const &info,
+                    ResultWas::OfType resultType,
+                    AssertionReaction &reaction ) = 0;
+
+        virtual bool lastAssertionPassed() = 0;
+        virtual void assertionPassed() = 0;
+
+        // Deprecated, do not use:
+        virtual std::string getCurrentTestName() const = 0;
+        virtual const AssertionResult* getLastResult() const = 0;
+        virtual void exceptionEarlyReported() = 0;
+    };
 
-IResultCapture& getResultCapture();
+    IResultCapture& getResultCapture();
 }
 
 // end catch_interfaces_capture.h
 namespace Catch {
 
-struct TestFailureException{};
-struct AssertionResultData;
-struct IResultCapture;
-class RunContext;
+    struct TestFailureException{};
+    struct AssertionResultData;
+    struct IResultCapture;
+    class RunContext;
 
-class LazyExpression {
-  friend class AssertionHandler;
-  friend struct AssertionStats;
-  friend class RunContext;
+    class LazyExpression {
+        friend class AssertionHandler;
+        friend struct AssertionStats;
+        friend class RunContext;
 
-  ITransientExpression const* m_transientExpression = nullptr;
-  bool m_isNegated;
- public:
-  LazyExpression( bool isNegated );
-  LazyExpression( LazyExpression const& other );
-  LazyExpression& operator = ( LazyExpression const& ) = delete;
+        ITransientExpression const* m_transientExpression = nullptr;
+        bool m_isNegated;
+    public:
+        LazyExpression( bool isNegated );
+        LazyExpression( LazyExpression const& other );
+        LazyExpression& operator = ( LazyExpression const& ) = delete;
 
-  explicit operator bool() const;
+        explicit operator bool() const;
 
-  friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
-};
+        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
+    };
 
-struct AssertionReaction {
-  bool shouldDebugBreak = false;
-  bool shouldThrow = false;
-};
+    struct AssertionReaction {
+        bool shouldDebugBreak = false;
+        bool shouldThrow = false;
+    };
 
-class AssertionHandler {
-  AssertionInfo m_assertionInfo;
-  AssertionReaction m_reaction;
-  bool m_completed = false;
-  IResultCapture& m_resultCapture;
-
- public:
-  AssertionHandler
-      (   StringRef const& macroName,
-          SourceLineInfo const& lineInfo,
-          StringRef capturedExpression,
-          ResultDisposition::Flags resultDisposition );
-  ~AssertionHandler() {
-    if ( !m_completed ) {
-      m_resultCapture.handleIncomplete( m_assertionInfo );
-    }
-  }
+    class AssertionHandler {
+        AssertionInfo m_assertionInfo;
+        AssertionReaction m_reaction;
+        bool m_completed = false;
+        IResultCapture& m_resultCapture;
 
-  template<typename T>
-  void handleExpr( ExprLhs<T> const& expr ) {
-    handleExpr( expr.makeUnaryExpr() );
-  }
-  void handleExpr( ITransientExpression const& expr );
+    public:
+        AssertionHandler
+            (   StringRef const& macroName,
+                SourceLineInfo const& lineInfo,
+                StringRef capturedExpression,
+                ResultDisposition::Flags resultDisposition );
+        ~AssertionHandler() {
+            if ( !m_completed ) {
+                m_resultCapture.handleIncomplete( m_assertionInfo );
+            }
+        }
 
-  void handleMessage(ResultWas::OfType resultType, StringRef const& message);
+        template<typename T>
+        void handleExpr( ExprLhs<T> const& expr ) {
+            handleExpr( expr.makeUnaryExpr() );
+        }
+        void handleExpr( ITransientExpression const& expr );
 
-  void handleExceptionThrownAsExpected();
-  void handleUnexpectedExceptionNotThrown();
-  void handleExceptionNotThrownAsExpected();
-  void handleThrowingCallSkipped();
-  void handleUnexpectedInflightException();
+        void handleMessage(ResultWas::OfType resultType, StringRef const& message);
 
-  void complete();
-  void setCompleted();
+        void handleExceptionThrownAsExpected();
+        void handleUnexpectedExceptionNotThrown();
+        void handleExceptionNotThrownAsExpected();
+        void handleThrowingCallSkipped();
+        void handleUnexpectedInflightException();
 
-  // query
-  auto allowThrows() const -> bool;
-};
+        void complete();
+        void setCompleted();
 
-void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString );
+        // query
+        auto allowThrows() const -> bool;
+    };
+
+    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString );
 
 } // namespace Catch
 
@@ -2591,80 +2596,80 @@ void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str
 
 namespace Catch {
 
-struct MessageInfo {
-  MessageInfo(    StringRef const& _macroName,
-                  SourceLineInfo const& _lineInfo,
-                  ResultWas::OfType _type );
-
-  StringRef macroName;
-  std::string message;
-  SourceLineInfo lineInfo;
-  ResultWas::OfType type;
-  unsigned int sequence;
-
-  bool operator == ( MessageInfo const& other ) const;
-  bool operator < ( MessageInfo const& other ) const;
- private:
-  static unsigned int globalCount;
-};
+    struct MessageInfo {
+        MessageInfo(    StringRef const& _macroName,
+                        SourceLineInfo const& _lineInfo,
+                        ResultWas::OfType _type );
+
+        StringRef macroName;
+        std::string message;
+        SourceLineInfo lineInfo;
+        ResultWas::OfType type;
+        unsigned int sequence;
 
-struct MessageStream {
+        bool operator == ( MessageInfo const& other ) const;
+        bool operator < ( MessageInfo const& other ) const;
+    private:
+        static unsigned int globalCount;
+    };
 
-  template<typename T>
-  MessageStream& operator << ( T const& value ) {
-    m_stream << value;
-    return *this;
-  }
+    struct MessageStream {
 
-  ReusableStringStream m_stream;
-};
+        template<typename T>
+        MessageStream& operator << ( T const& value ) {
+            m_stream << value;
+            return *this;
+        }
 
-struct MessageBuilder : MessageStream {
-  MessageBuilder( StringRef const& macroName,
-                  SourceLineInfo const& lineInfo,
-                  ResultWas::OfType type );
+        ReusableStringStream m_stream;
+    };
 
-  template<typename T>
-  MessageBuilder& operator << ( T const& value ) {
-    m_stream << value;
-    return *this;
-  }
+    struct MessageBuilder : MessageStream {
+        MessageBuilder( StringRef const& macroName,
+                        SourceLineInfo const& lineInfo,
+                        ResultWas::OfType type );
 
-  MessageInfo m_info;
-};
+        template<typename T>
+        MessageBuilder& operator << ( T const& value ) {
+            m_stream << value;
+            return *this;
+        }
+
+        MessageInfo m_info;
+    };
 
-class ScopedMessage {
- public:
-  explicit ScopedMessage( MessageBuilder const& builder );
-  ScopedMessage( ScopedMessage& duplicate ) = delete;
-  ScopedMessage( ScopedMessage&& old );
-  ~ScopedMessage();
+    class ScopedMessage {
+    public:
+        explicit ScopedMessage( MessageBuilder const& builder );
+        ScopedMessage( ScopedMessage& duplicate ) = delete;
+        ScopedMessage( ScopedMessage&& old );
+        ~ScopedMessage();
 
-  MessageInfo m_info;
-  bool m_moved;
-};
+        MessageInfo m_info;
+        bool m_moved;
+    };
 
-class Capturer {
-  std::vector<MessageInfo> m_messages;
-  IResultCapture& m_resultCapture = getResultCapture();
-  size_t m_captured = 0;
- public:
-  Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
-  ~Capturer();
+    class Capturer {
+        std::vector<MessageInfo> m_messages;
+        IResultCapture& m_resultCapture = getResultCapture();
+        size_t m_captured = 0;
+    public:
+        Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
+        ~Capturer();
 
-  void captureValue( size_t index, std::string const& value );
+        void captureValue( size_t index, std::string const& value );
 
-  template<typename T>
-  void captureValues( size_t index, T const& value ) {
-    captureValue( index, Catch::Detail::stringify( value ) );
-  }
+        template<typename T>
+        void captureValues( size_t index, T const& value ) {
+            captureValue( index, Catch::Detail::stringify( value ) );
+        }
 
-  template<typename T, typename... Ts>
-  void captureValues( size_t index, T const& value, Ts const&... values ) {
-    captureValue( index, Catch::Detail::stringify(value) );
-    captureValues( index+1, values... );
-  }
-};
+        template<typename T, typename... Ts>
+        void captureValues( size_t index, T const& value, Ts const&... values ) {
+            captureValue( index, Catch::Detail::stringify(value) );
+            captureValues( index+1, values... );
+        }
+    };
 
 } // end namespace Catch
 
@@ -2672,9 +2677,9 @@ class Capturer {
 #if !defined(CATCH_CONFIG_DISABLE)
 
 #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
-#define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
+  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
 #else
-#define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
+  #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
 #endif
 
 #if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
@@ -2821,30 +2826,30 @@ class Capturer {
 
 namespace Catch {
 
-struct Counts {
-  Counts operator - ( Counts const& other ) const;
-  Counts& operator += ( Counts const& other );
+    struct Counts {
+        Counts operator - ( Counts const& other ) const;
+        Counts& operator += ( Counts const& other );
 
-  std::size_t total() const;
-  bool allPassed() const;
-  bool allOk() const;
+        std::size_t total() const;
+        bool allPassed() const;
+        bool allOk() const;
 
-  std::size_t passed = 0;
-  std::size_t failed = 0;
-  std::size_t failedButOk = 0;
-};
+        std::size_t passed = 0;
+        std::size_t failed = 0;
+        std::size_t failedButOk = 0;
+    };
 
-struct Totals {
+    struct Totals {
 
-  Totals operator - ( Totals const& other ) const;
-  Totals& operator += ( Totals const& other );
+        Totals operator - ( Totals const& other ) const;
+        Totals& operator += ( Totals const& other );
 
-  Totals delta( Totals const& prevTotals ) const;
+        Totals delta( Totals const& prevTotals ) const;
 
-  int error = 0;
-  Counts assertions;
-  Counts testCases;
-};
+        int error = 0;
+        Counts assertions;
+        Counts testCases;
+    };
 }
 
 // end catch_totals.h
@@ -2852,27 +2857,27 @@ struct Totals {
 
 namespace Catch {
 
-struct SectionInfo {
-  SectionInfo
-      (   SourceLineInfo const& _lineInfo,
-          std::string const& _name );
+    struct SectionInfo {
+        SectionInfo
+            (   SourceLineInfo const& _lineInfo,
+                std::string const& _name );
 
-  // Deprecated
-  SectionInfo
-      (   SourceLineInfo const& _lineInfo,
-          std::string const& _name,
-          std::string const& ) : SectionInfo( _lineInfo, _name ) {}
+        // Deprecated
+        SectionInfo
+            (   SourceLineInfo const& _lineInfo,
+                std::string const& _name,
+                std::string const& ) : SectionInfo( _lineInfo, _name ) {}
 
-  std::string name;
-  std::string description; // !Deprecated: this will always be empty
-  SourceLineInfo lineInfo;
-};
+        std::string name;
+        std::string description; // !Deprecated: this will always be empty
+        SourceLineInfo lineInfo;
+    };
 
-struct SectionEndInfo {
-  SectionInfo sectionInfo;
-  Counts prevAssertions;
-  double durationInSeconds;
-};
+    struct SectionEndInfo {
+        SectionInfo sectionInfo;
+        Counts prevAssertions;
+        double durationInSeconds;
+    };
 
 } // end namespace Catch
 
@@ -2883,18 +2888,18 @@ struct SectionEndInfo {
 
 namespace Catch {
 
-auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
-auto getEstimatedClockResolution() -> uint64_t;
-
-class Timer {
-  uint64_t m_nanoseconds = 0;
- public:
-  void start();
-  auto getElapsedNanoseconds() const -> uint64_t;
-  auto getElapsedMicroseconds() const -> uint64_t;
-  auto getElapsedMilliseconds() const -> unsigned int;
-  auto getElapsedSeconds() const -> double;
-};
+    auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
+    auto getEstimatedClockResolution() -> uint64_t;
+
+    class Timer {
+        uint64_t m_nanoseconds = 0;
+    public:
+        void start();
+        auto getElapsedNanoseconds() const -> uint64_t;
+        auto getElapsedMicroseconds() const -> uint64_t;
+        auto getElapsedMilliseconds() const -> unsigned int;
+        auto getElapsedSeconds() const -> double;
+    };
 
 } // namespace Catch
 
@@ -2903,22 +2908,22 @@ class Timer {
 
 namespace Catch {
 
-class Section : NonCopyable {
- public:
-  Section( SectionInfo const& info );
-  ~Section();
+    class Section : NonCopyable {
+    public:
+        Section( SectionInfo const& info );
+        ~Section();
 
-  // This indicates whether the section should be executed or not
-  explicit operator bool() const;
+        // This indicates whether the section should be executed or not
+        explicit operator bool() const;
 
- private:
-  SectionInfo m_info;
+    private:
+        SectionInfo m_info;
 
-  std::string m_name;
-  Counts m_assertions;
-  bool m_sectionIncluded;
-  Timer m_timer;
-};
+        std::string m_name;
+        Counts m_assertions;
+        bool m_sectionIncluded;
+        Timer m_timer;
+    };
 
 } // end namespace Catch
 
@@ -2944,51 +2949,51 @@ class Section : NonCopyable {
 
 namespace Catch {
 
-class TestCase;
-struct ITestCaseRegistry;
-struct IExceptionTranslatorRegistry;
-struct IExceptionTranslator;
-struct IReporterRegistry;
-struct IReporterFactory;
-struct ITagAliasRegistry;
-struct IMutableEnumValuesRegistry;
+    class TestCase;
+    struct ITestCaseRegistry;
+    struct IExceptionTranslatorRegistry;
+    struct IExceptionTranslator;
+    struct IReporterRegistry;
+    struct IReporterFactory;
+    struct ITagAliasRegistry;
+    struct IMutableEnumValuesRegistry;
 
-class StartupExceptionRegistry;
+    class StartupExceptionRegistry;
 
-using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
+    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
 
-struct IRegistryHub {
-  virtual ~IRegistryHub();
+    struct IRegistryHub {
+        virtual ~IRegistryHub();
 
-  virtual IReporterRegistry const& getReporterRegistry() const = 0;
-  virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
-  virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
-  virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;
+        virtual IReporterRegistry const& getReporterRegistry() const = 0;
+        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
+        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
+        virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;
 
-  virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
-};
+        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
+    };
 
-struct IMutableRegistryHub {
-  virtual ~IMutableRegistryHub();
-  virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;
-  virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;
-  virtual void registerTest( TestCase const& testInfo ) = 0;
-  virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
-  virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
-  virtual void registerStartupException() noexcept = 0;
-  virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;
-};
+    struct IMutableRegistryHub {
+        virtual ~IMutableRegistryHub();
+        virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;
+        virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;
+        virtual void registerTest( TestCase const& testInfo ) = 0;
+        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
+        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
+        virtual void registerStartupException() noexcept = 0;
+        virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;
+    };
 
-IRegistryHub const& getRegistryHub();
-IMutableRegistryHub& getMutableRegistryHub();
-void cleanUp();
-std::string translateActiveException();
+    IRegistryHub const& getRegistryHub();
+    IMutableRegistryHub& getMutableRegistryHub();
+    void cleanUp();
+    std::string translateActiveException();
 
 }
 
 // end catch_interfaces_registry_hub.h
 #if defined(CATCH_CONFIG_DISABLE)
-#define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
+    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
         static std::string translatorName( signature )
 #endif
 
@@ -2997,58 +3002,58 @@ std::string translateActiveException();
 #include <vector>
 
 namespace Catch {
-using exceptionTranslateFunction = std::string(*)();
+    using exceptionTranslateFunction = std::string(*)();
 
-struct IExceptionTranslator;
-using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;
+    struct IExceptionTranslator;
+    using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;
 
-struct IExceptionTranslator {
-  virtual ~IExceptionTranslator();
-  virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
-};
+    struct IExceptionTranslator {
+        virtual ~IExceptionTranslator();
+        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
+    };
 
-struct IExceptionTranslatorRegistry {
-  virtual ~IExceptionTranslatorRegistry();
+    struct IExceptionTranslatorRegistry {
+        virtual ~IExceptionTranslatorRegistry();
 
-  virtual std::string translateActiveException() const = 0;
-};
+        virtual std::string translateActiveException() const = 0;
+    };
 
-class ExceptionTranslatorRegistrar {
-  template<typename T>
-  class ExceptionTranslator : public IExceptionTranslator {
-   public:
+    class ExceptionTranslatorRegistrar {
+        template<typename T>
+        class ExceptionTranslator : public IExceptionTranslator {
+        public:
 
-    ExceptionTranslator( std::string(*translateFunction)( T& ) )
-        : m_translateFunction( translateFunction )
-    {}
+            ExceptionTranslator( std::string(*translateFunction)( T& ) )
+            : m_translateFunction( translateFunction )
+            {}
 
-    std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
+            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
-      return "";
+                return "";
 #else
-      try {
-        if( it == itEnd )
-          std::rethrow_exception(std::current_exception());
-        else
-          return (*it)->translate( it+1, itEnd );
-      }
-      catch( T& ex ) {
-        return m_translateFunction( ex );
-      }
+                try {
+                    if( it == itEnd )
+                        std::rethrow_exception(std::current_exception());
+                    else
+                        return (*it)->translate( it+1, itEnd );
+                }
+                catch( T& ex ) {
+                    return m_translateFunction( ex );
+                }
 #endif
-    }
+            }
 
-   protected:
-    std::string(*m_translateFunction)( T& );
-  };
+        protected:
+            std::string(*m_translateFunction)( T& );
+        };
 
- public:
-  template<typename T>
-  ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
-    getMutableRegistryHub().registerTranslator
-        ( new ExceptionTranslator<T>( translateFunction ) );
-  }
-};
+    public:
+        template<typename T>
+        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
+            getMutableRegistryHub().registerTranslator
+                ( new ExceptionTranslator<T>( translateFunction ) );
+        }
+    };
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -3070,115 +3075,115 @@ class ExceptionTranslatorRegistrar {
 namespace Catch {
 namespace Detail {
 
-class Approx {
- private:
-  bool equalityComparisonImpl(double other) const;
-  // Validates the new margin (margin >= 0)
-  // out-of-line to avoid including stdexcept in the header
-  void setMargin(double margin);
-  // Validates the new epsilon (0 < epsilon < 1)
-  // out-of-line to avoid including stdexcept in the header
-  void setEpsilon(double epsilon);
-
- public:
-  explicit Approx ( double value );
-
-  static Approx custom();
-
-  Approx operator-() const;
-
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  Approx operator()( T const& value ) {
-    Approx approx( static_cast<double>(value) );
-    approx.m_epsilon = m_epsilon;
-    approx.m_margin = m_margin;
-    approx.m_scale = m_scale;
-    return approx;
-  }
+    class Approx {
+    private:
+        bool equalityComparisonImpl(double other) const;
+        // Validates the new margin (margin >= 0)
+        // out-of-line to avoid including stdexcept in the header
+        void setMargin(double margin);
+        // Validates the new epsilon (0 < epsilon < 1)
+        // out-of-line to avoid including stdexcept in the header
+        void setEpsilon(double epsilon);
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  explicit Approx( T const& value ): Approx(static_cast<double>(value))
-  {}
+    public:
+        explicit Approx ( double value );
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator == ( const T& lhs, Approx const& rhs ) {
-    auto lhs_v = static_cast<double>(lhs);
-    return rhs.equalityComparisonImpl(lhs_v);
-  }
+        static Approx custom();
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator == ( Approx const& lhs, const T& rhs ) {
-    return operator==( rhs, lhs );
-  }
+        Approx operator-() const;
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator != ( T const& lhs, Approx const& rhs ) {
-    return !operator==( lhs, rhs );
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx operator()( T const& value ) const {
+            Approx approx( static_cast<double>(value) );
+            approx.m_epsilon = m_epsilon;
+            approx.m_margin = m_margin;
+            approx.m_scale = m_scale;
+            return approx;
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator != ( Approx const& lhs, T const& rhs ) {
-    return !operator==( rhs, lhs );
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        explicit Approx( T const& value ): Approx(static_cast<double>(value))
+        {}
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator <= ( T const& lhs, Approx const& rhs ) {
-    return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator == ( const T& lhs, Approx const& rhs ) {
+            auto lhs_v = static_cast<double>(lhs);
+            return rhs.equalityComparisonImpl(lhs_v);
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator <= ( Approx const& lhs, T const& rhs ) {
-    return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator == ( Approx const& lhs, const T& rhs ) {
+            return operator==( rhs, lhs );
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator >= ( T const& lhs, Approx const& rhs ) {
-    return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator != ( T const& lhs, Approx const& rhs ) {
+            return !operator==( lhs, rhs );
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  friend bool operator >= ( Approx const& lhs, T const& rhs ) {
-    return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator != ( Approx const& lhs, T const& rhs ) {
+            return !operator==( rhs, lhs );
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  Approx& epsilon( T const& newEpsilon ) {
-    double epsilonAsDouble = static_cast<double>(newEpsilon);
-    setEpsilon(epsilonAsDouble);
-    return *this;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator <= ( T const& lhs, Approx const& rhs ) {
+            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  Approx& margin( T const& newMargin ) {
-    double marginAsDouble = static_cast<double>(newMargin);
-    setMargin(marginAsDouble);
-    return *this;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator <= ( Approx const& lhs, T const& rhs ) {
+            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
+        }
 
-  template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  Approx& scale( T const& newScale ) {
-    m_scale = static_cast<double>(newScale);
-    return *this;
-  }
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator >= ( T const& lhs, Approx const& rhs ) {
+            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
+        }
 
-  std::string toString() const;
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator >= ( Approx const& lhs, T const& rhs ) {
+            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
+        }
 
- private:
-  double m_epsilon;
-  double m_margin;
-  double m_scale;
-  double m_value;
-};
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx& epsilon( T const& newEpsilon ) {
+            double epsilonAsDouble = static_cast<double>(newEpsilon);
+            setEpsilon(epsilonAsDouble);
+            return *this;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx& margin( T const& newMargin ) {
+            double marginAsDouble = static_cast<double>(newMargin);
+            setMargin(marginAsDouble);
+            return *this;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx& scale( T const& newScale ) {
+            m_scale = static_cast<double>(newScale);
+            return *this;
+        }
+
+        std::string toString() const;
+
+    private:
+        double m_epsilon;
+        double m_margin;
+        double m_scale;
+        double m_value;
+    };
 } // end namespace Detail
 
 namespace literals {
-Detail::Approx operator "" _a(long double val);
-Detail::Approx operator "" _a(unsigned long long val);
+    Detail::Approx operator "" _a(long double val);
+    Detail::Approx operator "" _a(unsigned long long val);
 } // end namespace literals
 
 template<>
 struct StringMaker<Catch::Detail::Approx> {
-  static std::string convert(Catch::Detail::Approx const& value);
+    static std::string convert(Catch::Detail::Approx const& value);
 };
 
 } // end namespace Catch
@@ -3192,30 +3197,30 @@ struct StringMaker<Catch::Detail::Approx> {
 
 namespace Catch {
 
-bool startsWith( std::string const& s, std::string const& prefix );
-bool startsWith( std::string const& s, char prefix );
-bool endsWith( std::string const& s, std::string const& suffix );
-bool endsWith( std::string const& s, char suffix );
-bool contains( std::string const& s, std::string const& infix );
-void toLowerInPlace( std::string& s );
-std::string toLower( std::string const& s );
-//! Returns a new string without whitespace at the start/end
-std::string trim( std::string const& str );
-//! Returns a substring of the original ref without whitespace. Beware lifetimes!
-StringRef trim(StringRef ref);
-
-// !!! Be aware, returns refs into original string - make sure original string outlives them
-std::vector<StringRef> splitStringRef( StringRef str, char delimiter );
-bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
-
-struct pluralise {
-  pluralise( std::size_t count, std::string const& label );
-
-  friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
-
-  std::size_t m_count;
-  std::string m_label;
-};
+    bool startsWith( std::string const& s, std::string const& prefix );
+    bool startsWith( std::string const& s, char prefix );
+    bool endsWith( std::string const& s, std::string const& suffix );
+    bool endsWith( std::string const& s, char suffix );
+    bool contains( std::string const& s, std::string const& infix );
+    void toLowerInPlace( std::string& s );
+    std::string toLower( std::string const& s );
+    //! Returns a new string without whitespace at the start/end
+    std::string trim( std::string const& str );
+    //! Returns a substring of the original ref without whitespace. Beware lifetimes!
+    StringRef trim(StringRef ref);
+
+    // !!! Be aware, returns refs into original string - make sure original string outlives them
+    std::vector<StringRef> splitStringRef( StringRef str, char delimiter );
+    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
+
+    struct pluralise {
+        pluralise( std::size_t count, std::string const& label );
+
+        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
+
+        std::size_t m_count;
+        std::string m_label;
+    };
 }
 
 // end catch_string_manip.h
@@ -3229,37 +3234,37 @@ struct pluralise {
 
 namespace Catch {
 namespace Matchers {
-namespace Impl {
-
-template<typename ArgT> struct MatchAllOf;
-template<typename ArgT> struct MatchAnyOf;
-template<typename ArgT> struct MatchNotOf;
-
-class MatcherUntypedBase {
- public:
-  MatcherUntypedBase() = default;
-  MatcherUntypedBase ( MatcherUntypedBase const& ) = default;
-  MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;
-  std::string toString() const;
-
- protected:
-  virtual ~MatcherUntypedBase();
-  virtual std::string describe() const = 0;
-  mutable std::string m_cachedToString;
-};
+    namespace Impl {
+
+        template<typename ArgT> struct MatchAllOf;
+        template<typename ArgT> struct MatchAnyOf;
+        template<typename ArgT> struct MatchNotOf;
+
+        class MatcherUntypedBase {
+        public:
+            MatcherUntypedBase() = default;
+            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;
+            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;
+            std::string toString() const;
+
+        protected:
+            virtual ~MatcherUntypedBase();
+            virtual std::string describe() const = 0;
+            mutable std::string m_cachedToString;
+        };
 
 #ifdef __clang__
 #    pragma clang diagnostic push
 #    pragma clang diagnostic ignored "-Wnon-virtual-dtor"
 #endif
 
-template<typename ObjectT>
-struct MatcherMethod {
-  virtual bool match( ObjectT const& arg ) const = 0;
-};
+        template<typename ObjectT>
+        struct MatcherMethod {
+            virtual bool match( ObjectT const& arg ) const = 0;
+        };
 
 #if defined(__OBJC__)
-// Hack to fix Catch GH issue #1661. Could use id for generic Object support.
+        // Hack to fix Catch GH issue #1661. Could use id for generic Object support.
         // use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation
         template<>
         struct MatcherMethod<NSString*> {
@@ -3271,111 +3276,111 @@ struct MatcherMethod {
 #    pragma clang diagnostic pop
 #endif
 
-template<typename T>
-struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {
+        template<typename T>
+        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {
 
-  MatchAllOf<T> operator && ( MatcherBase const& other ) const;
-  MatchAnyOf<T> operator || ( MatcherBase const& other ) const;
-  MatchNotOf<T> operator ! () const;
-};
+            MatchAllOf<T> operator && ( MatcherBase const& other ) const;
+            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;
+            MatchNotOf<T> operator ! () const;
+        };
 
-template<typename ArgT>
-struct MatchAllOf : MatcherBase<ArgT> {
-  bool match( ArgT const& arg ) const override {
-    for( auto matcher : m_matchers ) {
-      if (!matcher->match(arg))
-        return false;
-    }
-    return true;
-  }
-  std::string describe() const override {
-    std::string description;
-    description.reserve( 4 + m_matchers.size()*32 );
-    description += "( ";
-    bool first = true;
-    for( auto matcher : m_matchers ) {
-      if( first )
-        first = false;
-      else
-        description += " and ";
-      description += matcher->toString();
-    }
-    description += " )";
-    return description;
-  }
+        template<typename ArgT>
+        struct MatchAllOf : MatcherBase<ArgT> {
+            bool match( ArgT const& arg ) const override {
+                for( auto matcher : m_matchers ) {
+                    if (!matcher->match(arg))
+                        return false;
+                }
+                return true;
+            }
+            std::string describe() const override {
+                std::string description;
+                description.reserve( 4 + m_matchers.size()*32 );
+                description += "( ";
+                bool first = true;
+                for( auto matcher : m_matchers ) {
+                    if( first )
+                        first = false;
+                    else
+                        description += " and ";
+                    description += matcher->toString();
+                }
+                description += " )";
+                return description;
+            }
 
-  MatchAllOf<ArgT> operator && ( MatcherBase<ArgT> const& other ) {
-    auto copy(*this);
-    copy.m_matchers.push_back( &other );
-    return copy;
-  }
+            MatchAllOf<ArgT> operator && ( MatcherBase<ArgT> const& other ) {
+                auto copy(*this);
+                copy.m_matchers.push_back( &other );
+                return copy;
+            }
 
-  std::vector<MatcherBase<ArgT> const*> m_matchers;
-};
-template<typename ArgT>
-struct MatchAnyOf : MatcherBase<ArgT> {
+            std::vector<MatcherBase<ArgT> const*> m_matchers;
+        };
+        template<typename ArgT>
+        struct MatchAnyOf : MatcherBase<ArgT> {
 
-  bool match( ArgT const& arg ) const override {
-    for( auto matcher : m_matchers ) {
-      if (matcher->match(arg))
-        return true;
-    }
-    return false;
-  }
-  std::string describe() const override {
-    std::string description;
-    description.reserve( 4 + m_matchers.size()*32 );
-    description += "( ";
-    bool first = true;
-    for( auto matcher : m_matchers ) {
-      if( first )
-        first = false;
-      else
-        description += " or ";
-      description += matcher->toString();
-    }
-    description += " )";
-    return description;
-  }
+            bool match( ArgT const& arg ) const override {
+                for( auto matcher : m_matchers ) {
+                    if (matcher->match(arg))
+                        return true;
+                }
+                return false;
+            }
+            std::string describe() const override {
+                std::string description;
+                description.reserve( 4 + m_matchers.size()*32 );
+                description += "( ";
+                bool first = true;
+                for( auto matcher : m_matchers ) {
+                    if( first )
+                        first = false;
+                    else
+                        description += " or ";
+                    description += matcher->toString();
+                }
+                description += " )";
+                return description;
+            }
 
-  MatchAnyOf<ArgT> operator || ( MatcherBase<ArgT> const& other ) {
-    auto copy(*this);
-    copy.m_matchers.push_back( &other );
-    return copy;
-  }
+            MatchAnyOf<ArgT> operator || ( MatcherBase<ArgT> const& other ) {
+                auto copy(*this);
+                copy.m_matchers.push_back( &other );
+                return copy;
+            }
 
-  std::vector<MatcherBase<ArgT> const*> m_matchers;
-};
+            std::vector<MatcherBase<ArgT> const*> m_matchers;
+        };
 
-template<typename ArgT>
-struct MatchNotOf : MatcherBase<ArgT> {
+        template<typename ArgT>
+        struct MatchNotOf : MatcherBase<ArgT> {
 
-  MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
+            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
 
-  bool match( ArgT const& arg ) const override {
-    return !m_underlyingMatcher.match( arg );
-  }
+            bool match( ArgT const& arg ) const override {
+                return !m_underlyingMatcher.match( arg );
+            }
 
-  std::string describe() const override {
-    return "not " + m_underlyingMatcher.toString();
-  }
-  MatcherBase<ArgT> const& m_underlyingMatcher;
-};
+            std::string describe() const override {
+                return "not " + m_underlyingMatcher.toString();
+            }
+            MatcherBase<ArgT> const& m_underlyingMatcher;
+        };
 
-template<typename T>
-MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {
-  return MatchAllOf<T>() && *this && other;
-}
-template<typename T>
-MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {
-  return MatchAnyOf<T>() || *this || other;
-}
-template<typename T>
-MatchNotOf<T> MatcherBase<T>::operator ! () const {
-  return MatchNotOf<T>( *this );
-}
+        template<typename T>
+        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {
+            return MatchAllOf<T>() && *this && other;
+        }
+        template<typename T>
+        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {
+            return MatchAnyOf<T>() || *this || other;
+        }
+        template<typename T>
+        MatchNotOf<T> MatcherBase<T>::operator ! () const {
+            return MatchNotOf<T>( *this );
+        }
 
-} // namespace Impl
+    } // namespace Impl
 
 } // namespace Matchers
 
@@ -3392,16 +3397,16 @@ namespace Matchers {
 namespace Exception {
 
 class ExceptionMessageMatcher : public MatcherBase<std::exception> {
-  std::string m_message;
- public:
+    std::string m_message;
+public:
 
-  ExceptionMessageMatcher(std::string const& message):
-      m_message(message)
-  {}
+    ExceptionMessageMatcher(std::string const& message):
+        m_message(message)
+    {}
 
-  bool match(std::exception const& ex) const override;
+    bool match(std::exception const& ex) const override;
 
-  std::string describe() const override;
+    std::string describe() const override;
 };
 
 } // namespace Exception
@@ -3417,57 +3422,57 @@ Exception::ExceptionMessageMatcher Message(std::string const& message);
 namespace Catch {
 namespace Matchers {
 
-namespace Floating {
+    namespace Floating {
 
-enum class FloatingPointKind : uint8_t;
+        enum class FloatingPointKind : uint8_t;
 
-struct WithinAbsMatcher : MatcherBase<double> {
-  WithinAbsMatcher(double target, double margin);
-  bool match(double const& matchee) const override;
-  std::string describe() const override;
- private:
-  double m_target;
-  double m_margin;
-};
+        struct WithinAbsMatcher : MatcherBase<double> {
+            WithinAbsMatcher(double target, double margin);
+            bool match(double const& matchee) const override;
+            std::string describe() const override;
+        private:
+            double m_target;
+            double m_margin;
+        };
 
-struct WithinUlpsMatcher : MatcherBase<double> {
-  WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType);
-  bool match(double const& matchee) const override;
-  std::string describe() const override;
- private:
-  double m_target;
-  uint64_t m_ulps;
-  FloatingPointKind m_type;
-};
+        struct WithinUlpsMatcher : MatcherBase<double> {
+            WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType);
+            bool match(double const& matchee) const override;
+            std::string describe() const override;
+        private:
+            double m_target;
+            uint64_t m_ulps;
+            FloatingPointKind m_type;
+        };
 
-// Given IEEE-754 format for floats and doubles, we can assume
-// that float -> double promotion is lossless. Given this, we can
-// assume that if we do the standard relative comparison of
-// |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get
-// the same result if we do this for floats, as if we do this for
-// doubles that were promoted from floats.
-struct WithinRelMatcher : MatcherBase<double> {
-  WithinRelMatcher(double target, double epsilon);
-  bool match(double const& matchee) const override;
-  std::string describe() const override;
- private:
-  double m_target;
-  double m_epsilon;
-};
+        // Given IEEE-754 format for floats and doubles, we can assume
+        // that float -> double promotion is lossless. Given this, we can
+        // assume that if we do the standard relative comparison of
+        // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get
+        // the same result if we do this for floats, as if we do this for
+        // doubles that were promoted from floats.
+        struct WithinRelMatcher : MatcherBase<double> {
+            WithinRelMatcher(double target, double epsilon);
+            bool match(double const& matchee) const override;
+            std::string describe() const override;
+        private:
+            double m_target;
+            double m_epsilon;
+        };
 
-} // namespace Floating
+    } // namespace Floating
 
-// The following functions create the actual matcher objects.
-// This allows the types to be inferred
-Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
-Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
-Floating::WithinAbsMatcher WithinAbs(double target, double margin);
-Floating::WithinRelMatcher WithinRel(double target, double eps);
-// defaults epsilon to 100*numeric_limits<double>::epsilon()
-Floating::WithinRelMatcher WithinRel(double target);
-Floating::WithinRelMatcher WithinRel(float target, float eps);
-// defaults epsilon to 100*numeric_limits<float>::epsilon()
-Floating::WithinRelMatcher WithinRel(float target);
+    // The following functions create the actual matcher objects.
+    // This allows the types to be inferred
+    Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
+    Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
+    Floating::WithinAbsMatcher WithinAbs(double target, double margin);
+    Floating::WithinRelMatcher WithinRel(double target, double eps);
+    // defaults epsilon to 100*numeric_limits<double>::epsilon()
+    Floating::WithinRelMatcher WithinRel(double target);
+    Floating::WithinRelMatcher WithinRel(float target, float eps);
+    // defaults epsilon to 100*numeric_limits<float>::epsilon()
+    Floating::WithinRelMatcher WithinRel(float target);
 
 } // namespace Matchers
 } // namespace Catch
@@ -3483,39 +3488,39 @@ namespace Matchers {
 namespace Generic {
 
 namespace Detail {
-std::string finalizeDescription(const std::string& desc);
+    std::string finalizeDescription(const std::string& desc);
 }
 
 template <typename T>
 class PredicateMatcher : public MatcherBase<T> {
-  std::function<bool(T const&)> m_predicate;
-  std::string m_description;
- public:
+    std::function<bool(T const&)> m_predicate;
+    std::string m_description;
+public:
 
-  PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)
-      :m_predicate(std::move(elem)),
-       m_description(Detail::finalizeDescription(descr))
-  {}
+    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)
+        :m_predicate(std::move(elem)),
+        m_description(Detail::finalizeDescription(descr))
+    {}
 
-  bool match( T const& item ) const override {
-    return m_predicate(item);
-  }
+    bool match( T const& item ) const override {
+        return m_predicate(item);
+    }
 
-  std::string describe() const override {
-    return m_description;
-  }
+    std::string describe() const override {
+        return m_description;
+    }
 };
 
 } // namespace Generic
 
-// The following functions create the actual matcher objects.
-// The user has to explicitly specify type to the function, because
-// inferring std::function<bool(T const&)> is hard (but possible) and
-// requires a lot of TMP.
-template<typename T>
-Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = "") {
-  return Generic::PredicateMatcher<T>(predicate, description);
-}
+    // The following functions create the actual matcher objects.
+    // The user has to explicitly specify type to the function, because
+    // inferring std::function<bool(T const&)> is hard (but possible) and
+    // requires a lot of TMP.
+    template<typename T>
+    Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = "") {
+        return Generic::PredicateMatcher<T>(predicate, description);
+    }
 
 } // namespace Matchers
 } // namespace Catch
@@ -3528,63 +3533,63 @@ Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& pred
 namespace Catch {
 namespace Matchers {
 
-namespace StdString {
+    namespace StdString {
 
-struct CasedString
-{
-  CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
-  std::string adjustString( std::string const& str ) const;
-  std::string caseSensitivitySuffix() const;
+        struct CasedString
+        {
+            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
+            std::string adjustString( std::string const& str ) const;
+            std::string caseSensitivitySuffix() const;
 
-  CaseSensitive::Choice m_caseSensitivity;
-  std::string m_str;
-};
+            CaseSensitive::Choice m_caseSensitivity;
+            std::string m_str;
+        };
 
-struct StringMatcherBase : MatcherBase<std::string> {
-  StringMatcherBase( std::string const& operation, CasedString const& comparator );
-  std::string describe() const override;
+        struct StringMatcherBase : MatcherBase<std::string> {
+            StringMatcherBase( std::string const& operation, CasedString const& comparator );
+            std::string describe() const override;
 
-  CasedString m_comparator;
-  std::string m_operation;
-};
+            CasedString m_comparator;
+            std::string m_operation;
+        };
 
-struct EqualsMatcher : StringMatcherBase {
-  EqualsMatcher( CasedString const& comparator );
-  bool match( std::string const& source ) const override;
-};
-struct ContainsMatcher : StringMatcherBase {
-  ContainsMatcher( CasedString const& comparator );
-  bool match( std::string const& source ) const override;
-};
-struct StartsWithMatcher : StringMatcherBase {
-  StartsWithMatcher( CasedString const& comparator );
-  bool match( std::string const& source ) const override;
-};
-struct EndsWithMatcher : StringMatcherBase {
-  EndsWithMatcher( CasedString const& comparator );
-  bool match( std::string const& source ) const override;
-};
+        struct EqualsMatcher : StringMatcherBase {
+            EqualsMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+        struct ContainsMatcher : StringMatcherBase {
+            ContainsMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+        struct StartsWithMatcher : StringMatcherBase {
+            StartsWithMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+        struct EndsWithMatcher : StringMatcherBase {
+            EndsWithMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
 
-struct RegexMatcher : MatcherBase<std::string> {
-  RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
-  bool match( std::string const& matchee ) const override;
-  std::string describe() const override;
+        struct RegexMatcher : MatcherBase<std::string> {
+            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
+            bool match( std::string const& matchee ) const override;
+            std::string describe() const override;
 
- private:
-  std::string m_regex;
-  CaseSensitive::Choice m_caseSensitivity;
-};
+        private:
+            std::string m_regex;
+            CaseSensitive::Choice m_caseSensitivity;
+        };
 
-} // namespace StdString
+    } // namespace StdString
 
-// The following functions create the actual matcher objects.
-// This allows the types to be inferred
+    // The following functions create the actual matcher objects.
+    // This allows the types to be inferred
 
-StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
-StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
-StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
-StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
-StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
 
 } // namespace Matchers
 } // namespace Catch
@@ -3597,163 +3602,163 @@ StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice
 namespace Catch {
 namespace Matchers {
 
-namespace Vector {
-template<typename T, typename Alloc>
-struct ContainsElementMatcher : MatcherBase<std::vector<T, Alloc>> {
+    namespace Vector {
+        template<typename T, typename Alloc>
+        struct ContainsElementMatcher : MatcherBase<std::vector<T, Alloc>> {
 
-  ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
+            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
 
-  bool match(std::vector<T, Alloc> const &v) const override {
-    for (auto const& el : v) {
-      if (el == m_comparator) {
-        return true;
-      }
-    }
-    return false;
-  }
+            bool match(std::vector<T, Alloc> const &v) const override {
+                for (auto const& el : v) {
+                    if (el == m_comparator) {
+                        return true;
+                    }
+                }
+                return false;
+            }
 
-  std::string describe() const override {
-    return "Contains: " + ::Catch::Detail::stringify( m_comparator );
-  }
+            std::string describe() const override {
+                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
+            }
 
-  T const& m_comparator;
-};
+            T const& m_comparator;
+        };
 
-template<typename T, typename AllocComp, typename AllocMatch>
-struct ContainsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct ContainsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
 
-  ContainsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
+            ContainsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
 
-  bool match(std::vector<T, AllocMatch> const &v) const override {
-    // !TBD: see note in EqualsMatcher
-    if (m_comparator.size() > v.size())
-      return false;
-    for (auto const& comparator : m_comparator) {
-      auto present = false;
-      for (const auto& el : v) {
-        if (el == comparator) {
-          present = true;
-          break;
-        }
-      }
-      if (!present) {
-        return false;
-      }
-    }
-    return true;
-  }
-  std::string describe() const override {
-    return "Contains: " + ::Catch::Detail::stringify( m_comparator );
-  }
+            bool match(std::vector<T, AllocMatch> const &v) const override {
+                // !TBD: see note in EqualsMatcher
+                if (m_comparator.size() > v.size())
+                    return false;
+                for (auto const& comparator : m_comparator) {
+                    auto present = false;
+                    for (const auto& el : v) {
+                        if (el == comparator) {
+                            present = true;
+                            break;
+                        }
+                    }
+                    if (!present) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+            std::string describe() const override {
+                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
+            }
 
-  std::vector<T, AllocComp> const& m_comparator;
-};
+            std::vector<T, AllocComp> const& m_comparator;
+        };
 
-template<typename T, typename AllocComp, typename AllocMatch>
-struct EqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct EqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
 
-  EqualsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
+            EqualsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
 
-  bool match(std::vector<T, AllocMatch> const &v) const override {
-    // !TBD: This currently works if all elements can be compared using !=
-    // - a more general approach would be via a compare template that defaults
-    // to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc
-    // - then just call that directly
-    if (m_comparator.size() != v.size())
-      return false;
-    for (std::size_t i = 0; i < v.size(); ++i)
-      if (m_comparator[i] != v[i])
-        return false;
-    return true;
-  }
-  std::string describe() const override {
-    return "Equals: " + ::Catch::Detail::stringify( m_comparator );
-  }
-  std::vector<T, AllocComp> const& m_comparator;
-};
+            bool match(std::vector<T, AllocMatch> const &v) const override {
+                // !TBD: This currently works if all elements can be compared using !=
+                // - a more general approach would be via a compare template that defaults
+                // to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc
+                // - then just call that directly
+                if (m_comparator.size() != v.size())
+                    return false;
+                for (std::size_t i = 0; i < v.size(); ++i)
+                    if (m_comparator[i] != v[i])
+                        return false;
+                return true;
+            }
+            std::string describe() const override {
+                return "Equals: " + ::Catch::Detail::stringify( m_comparator );
+            }
+            std::vector<T, AllocComp> const& m_comparator;
+        };
 
-template<typename T, typename AllocComp, typename AllocMatch>
-struct ApproxMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct ApproxMatcher : MatcherBase<std::vector<T, AllocMatch>> {
 
-  ApproxMatcher(std::vector<T, AllocComp> const& comparator) : m_comparator( comparator ) {}
+            ApproxMatcher(std::vector<T, AllocComp> const& comparator) : m_comparator( comparator ) {}
 
-  bool match(std::vector<T, AllocMatch> const &v) const override {
-    if (m_comparator.size() != v.size())
-      return false;
-    for (std::size_t i = 0; i < v.size(); ++i)
-      if (m_comparator[i] != approx(v[i]))
-        return false;
-    return true;
-  }
-  std::string describe() const override {
-    return "is approx: " + ::Catch::Detail::stringify( m_comparator );
-  }
-  template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  ApproxMatcher& epsilon( T const& newEpsilon ) {
-    approx.epsilon(newEpsilon);
-    return *this;
-  }
-  template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  ApproxMatcher& margin( T const& newMargin ) {
-    approx.margin(newMargin);
-    return *this;
-  }
-  template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
-  ApproxMatcher& scale( T const& newScale ) {
-    approx.scale(newScale);
-    return *this;
-  }
+            bool match(std::vector<T, AllocMatch> const &v) const override {
+                if (m_comparator.size() != v.size())
+                    return false;
+                for (std::size_t i = 0; i < v.size(); ++i)
+                    if (m_comparator[i] != approx(v[i]))
+                        return false;
+                return true;
+            }
+            std::string describe() const override {
+                return "is approx: " + ::Catch::Detail::stringify( m_comparator );
+            }
+            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+            ApproxMatcher& epsilon( T const& newEpsilon ) {
+                approx.epsilon(newEpsilon);
+                return *this;
+            }
+            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+            ApproxMatcher& margin( T const& newMargin ) {
+                approx.margin(newMargin);
+                return *this;
+            }
+            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+            ApproxMatcher& scale( T const& newScale ) {
+                approx.scale(newScale);
+                return *this;
+            }
 
-  std::vector<T, AllocComp> const& m_comparator;
-  mutable Catch::Detail::Approx approx = Catch::Detail::Approx::custom();
-};
+            std::vector<T, AllocComp> const& m_comparator;
+            mutable Catch::Detail::Approx approx = Catch::Detail::Approx::custom();
+        };
 
-template<typename T, typename AllocComp, typename AllocMatch>
-struct UnorderedEqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
-  UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target) : m_target(target) {}
-  bool match(std::vector<T, AllocMatch> const& vec) const override {
-    if (m_target.size() != vec.size()) {
-      return false;
-    }
-    return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
-  }
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+            UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target) : m_target(target) {}
+            bool match(std::vector<T, AllocMatch> const& vec) const override {
+                if (m_target.size() != vec.size()) {
+                    return false;
+                }
+                return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
+            }
 
-  std::string describe() const override {
-    return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
-  }
- private:
-  std::vector<T, AllocComp> const& m_target;
-};
+            std::string describe() const override {
+                return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
+            }
+        private:
+            std::vector<T, AllocComp> const& m_target;
+        };
 
-} // namespace Vector
+    } // namespace Vector
 
-// The following functions create the actual matcher objects.
-// This allows the types to be inferred
+    // The following functions create the actual matcher objects.
+    // This allows the types to be inferred
 
-template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
-Vector::ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) {
-  return Vector::ContainsMatcher<T, AllocComp, AllocMatch>( comparator );
-}
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) {
+        return Vector::ContainsMatcher<T, AllocComp, AllocMatch>( comparator );
+    }
 
-template<typename T, typename Alloc = std::allocator<T>>
-Vector::ContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) {
-  return Vector::ContainsElementMatcher<T, Alloc>( comparator );
-}
+    template<typename T, typename Alloc = std::allocator<T>>
+    Vector::ContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) {
+        return Vector::ContainsElementMatcher<T, Alloc>( comparator );
+    }
 
-template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
-Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) {
-  return Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );
-}
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) {
+        return Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );
+    }
 
-template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
-Vector::ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) {
-  return Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );
-}
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) {
+        return Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );
+    }
 
-template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
-Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) {
-  return Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );
-}
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) {
+        return Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );
+    }
 
 } // namespace Matchers
 } // namespace Catch
@@ -3761,39 +3766,39 @@ Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::ve
 // end catch_matchers_vector.h
 namespace Catch {
 
-template<typename ArgT, typename MatcherT>
-class MatchExpr : public ITransientExpression {
-  ArgT const& m_arg;
-  MatcherT m_matcher;
-  StringRef m_matcherString;
- public:
-  MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString )
-      :   ITransientExpression{ true, matcher.match( arg ) },
-          m_arg( arg ),
-          m_matcher( matcher ),
-          m_matcherString( matcherString )
-  {}
-
-  void streamReconstructedExpression( std::ostream &os ) const override {
-    auto matcherAsString = m_matcher.toString();
-    os << Catch::Detail::stringify( m_arg ) << ' ';
-    if( matcherAsString == Detail::unprintableString )
-      os << m_matcherString;
-    else
-      os << matcherAsString;
-  }
-};
+    template<typename ArgT, typename MatcherT>
+    class MatchExpr : public ITransientExpression {
+        ArgT const& m_arg;
+        MatcherT m_matcher;
+        StringRef m_matcherString;
+    public:
+        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString )
+        :   ITransientExpression{ true, matcher.match( arg ) },
+            m_arg( arg ),
+            m_matcher( matcher ),
+            m_matcherString( matcherString )
+        {}
 
-using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
+        void streamReconstructedExpression( std::ostream &os ) const override {
+            auto matcherAsString = m_matcher.toString();
+            os << Catch::Detail::stringify( m_arg ) << ' ';
+            if( matcherAsString == Detail::unprintableString )
+                os << m_matcherString;
+            else
+                os << matcherAsString;
+        }
+    };
 
-void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  );
+    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
 
-template<typename ArgT, typename MatcherT>
-auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString  ) -> MatchExpr<ArgT, MatcherT> {
-  return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );
-}
+    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  );
 
-} // namespace Catch
+    template<typename ArgT, typename MatcherT>
+    auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString  ) -> MatchExpr<ArgT, MatcherT> {
+        return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );
+    }
+
+} // namespace Catch
 
 ///////////////////////////////////////////////////////////////////////////////
 #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
@@ -3836,27 +3841,27 @@ auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& m
 
 namespace Catch {
 
-namespace Generators {
-class GeneratorUntypedBase {
- public:
-  GeneratorUntypedBase() = default;
-  virtual ~GeneratorUntypedBase();
-  // Attempts to move the generator to the next element
-  //
-  // Returns true iff the move succeeded (and a valid element
-  // can be retrieved).
-  virtual bool next() = 0;
-};
-using GeneratorBasePtr = std::unique_ptr<GeneratorUntypedBase>;
+    namespace Generators {
+        class GeneratorUntypedBase {
+        public:
+            GeneratorUntypedBase() = default;
+            virtual ~GeneratorUntypedBase();
+            // Attempts to move the generator to the next element
+             //
+             // Returns true iff the move succeeded (and a valid element
+             // can be retrieved).
+            virtual bool next() = 0;
+        };
+        using GeneratorBasePtr = std::unique_ptr<GeneratorUntypedBase>;
 
-} // namespace Generators
+    } // namespace Generators
 
-struct IGeneratorTracker {
-  virtual ~IGeneratorTracker();
-  virtual auto hasGenerator() const -> bool = 0;
-  virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
-  virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
-};
+    struct IGeneratorTracker {
+        virtual ~IGeneratorTracker();
+        virtual auto hasGenerator() const -> bool = 0;
+        virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
+        virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
+    };
 
 } // namespace Catch
 
@@ -3867,22 +3872,22 @@ struct IGeneratorTracker {
 
 namespace Catch {
 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
-template <typename Ex>
-[[noreturn]]
-void throw_exception(Ex const& e) {
-  throw e;
-}
+    template <typename Ex>
+    [[noreturn]]
+    void throw_exception(Ex const& e) {
+        throw e;
+    }
 #else // ^^ Exceptions are enabled //  Exceptions are disabled vv
-[[noreturn]]
+    [[noreturn]]
     void throw_exception(std::exception const& e);
 #endif
 
-[[noreturn]]
-void throw_logic_error(std::string const& msg);
-[[noreturn]]
-void throw_domain_error(std::string const& msg);
-[[noreturn]]
-void throw_runtime_error(std::string const& msg);
+    [[noreturn]]
+    void throw_logic_error(std::string const& msg);
+    [[noreturn]]
+    void throw_domain_error(std::string const& msg);
+    [[noreturn]]
+    void throw_runtime_error(std::string const& msg);
 
 } // namespace Catch;
 
@@ -3912,182 +3917,182 @@ void throw_runtime_error(std::string const& msg);
 namespace Catch {
 
 class GeneratorException : public std::exception {
-  const char* const m_msg = "";
+    const char* const m_msg = "";
 
- public:
-  GeneratorException(const char* msg):
-      m_msg(msg)
-  {}
+public:
+    GeneratorException(const char* msg):
+        m_msg(msg)
+    {}
 
-  const char* what() const noexcept override final;
+    const char* what() const noexcept override final;
 };
 
 namespace Generators {
 
-// !TBD move this into its own location?
-namespace pf{
-template<typename T, typename... Args>
-std::unique_ptr<T> make_unique( Args&&... args ) {
-  return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
-}
-}
+    // !TBD move this into its own location?
+    namespace pf{
+        template<typename T, typename... Args>
+        std::unique_ptr<T> make_unique( Args&&... args ) {
+            return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
+        }
+    }
 
-template<typename T>
-struct IGenerator : GeneratorUntypedBase {
-  virtual ~IGenerator() = default;
-
-  // Returns the current element of the generator
-  //
-  // \Precondition The generator is either freshly constructed,
-  // or the last call to `next()` returned true
-  virtual T const& get() const = 0;
-  using type = T;
-};
+    template<typename T>
+    struct IGenerator : GeneratorUntypedBase {
+        virtual ~IGenerator() = default;
+
+        // Returns the current element of the generator
+        //
+        // \Precondition The generator is either freshly constructed,
+        // or the last call to `next()` returned true
+        virtual T const& get() const = 0;
+        using type = T;
+    };
 
-template<typename T>
-class SingleValueGenerator final : public IGenerator<T> {
-  T m_value;
- public:
-  SingleValueGenerator(T&& value) : m_value(std::move(value)) {}
+    template<typename T>
+    class SingleValueGenerator final : public IGenerator<T> {
+        T m_value;
+    public:
+        SingleValueGenerator(T&& value) : m_value(std::move(value)) {}
 
-  T const& get() const override {
-    return m_value;
-  }
-  bool next() override {
-    return false;
-  }
-};
+        T const& get() const override {
+            return m_value;
+        }
+        bool next() override {
+            return false;
+        }
+    };
 
-template<typename T>
-class FixedValuesGenerator final : public IGenerator<T> {
-  static_assert(!std::is_same<T, bool>::value,
-                "FixedValuesGenerator does not support bools because of std::vector<bool>"
-                "specialization, use SingleValue Generator instead.");
-  std::vector<T> m_values;
-  size_t m_idx = 0;
- public:
-  FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
-
-  T const& get() const override {
-    return m_values[m_idx];
-  }
-  bool next() override {
-    ++m_idx;
-    return m_idx < m_values.size();
-  }
-};
+    template<typename T>
+    class FixedValuesGenerator final : public IGenerator<T> {
+        static_assert(!std::is_same<T, bool>::value,
+            "FixedValuesGenerator does not support bools because of std::vector<bool>"
+            "specialization, use SingleValue Generator instead.");
+        std::vector<T> m_values;
+        size_t m_idx = 0;
+    public:
+        FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
 
-template <typename T>
-class GeneratorWrapper final {
-  std::unique_ptr<IGenerator<T>> m_generator;
- public:
-  GeneratorWrapper(std::unique_ptr<IGenerator<T>> generator):
-      m_generator(std::move(generator))
-  {}
-  T const& get() const {
-    return m_generator->get();
-  }
-  bool next() {
-    return m_generator->next();
-  }
-};
+        T const& get() const override {
+            return m_values[m_idx];
+        }
+        bool next() override {
+            ++m_idx;
+            return m_idx < m_values.size();
+        }
+    };
 
-template <typename T>
-GeneratorWrapper<T> value(T&& value) {
-  return GeneratorWrapper<T>(pf::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));
-}
-template <typename T>
-GeneratorWrapper<T> values(std::initializer_list<T> values) {
-  return GeneratorWrapper<T>(pf::make_unique<FixedValuesGenerator<T>>(values));
-}
+    template <typename T>
+    class GeneratorWrapper final {
+        std::unique_ptr<IGenerator<T>> m_generator;
+    public:
+        GeneratorWrapper(std::unique_ptr<IGenerator<T>> generator):
+            m_generator(std::move(generator))
+        {}
+        T const& get() const {
+            return m_generator->get();
+        }
+        bool next() {
+            return m_generator->next();
+        }
+    };
 
-template<typename T>
-class Generators : public IGenerator<T> {
-  std::vector<GeneratorWrapper<T>> m_generators;
-  size_t m_current = 0;
+    template <typename T>
+    GeneratorWrapper<T> value(T&& value) {
+        return GeneratorWrapper<T>(pf::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));
+    }
+    template <typename T>
+    GeneratorWrapper<T> values(std::initializer_list<T> values) {
+        return GeneratorWrapper<T>(pf::make_unique<FixedValuesGenerator<T>>(values));
+    }
 
-  void populate(GeneratorWrapper<T>&& generator) {
-    m_generators.emplace_back(std::move(generator));
-  }
-  void populate(T&& val) {
-    m_generators.emplace_back(value(std::forward<T>(val)));
-  }
-  template<typename U>
-  void populate(U&& val) {
-    populate(T(std::forward<U>(val)));
-  }
-  template<typename U, typename... Gs>
-  void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {
-    populate(std::forward<U>(valueOrGenerator));
-    populate(std::forward<Gs>(moreGenerators)...);
-  }
+    template<typename T>
+    class Generators : public IGenerator<T> {
+        std::vector<GeneratorWrapper<T>> m_generators;
+        size_t m_current = 0;
 
- public:
-  template <typename... Gs>
-  Generators(Gs &&... moreGenerators) {
-    m_generators.reserve(sizeof...(Gs));
-    populate(std::forward<Gs>(moreGenerators)...);
-  }
+        void populate(GeneratorWrapper<T>&& generator) {
+            m_generators.emplace_back(std::move(generator));
+        }
+        void populate(T&& val) {
+            m_generators.emplace_back(value(std::forward<T>(val)));
+        }
+        template<typename U>
+        void populate(U&& val) {
+            populate(T(std::forward<U>(val)));
+        }
+        template<typename U, typename... Gs>
+        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {
+            populate(std::forward<U>(valueOrGenerator));
+            populate(std::forward<Gs>(moreGenerators)...);
+        }
 
-  T const& get() const override {
-    return m_generators[m_current].get();
-  }
+    public:
+        template <typename... Gs>
+        Generators(Gs &&... moreGenerators) {
+            m_generators.reserve(sizeof...(Gs));
+            populate(std::forward<Gs>(moreGenerators)...);
+        }
 
-  bool next() override {
-    if (m_current >= m_generators.size()) {
-      return false;
-    }
-    const bool current_status = m_generators[m_current].next();
-    if (!current_status) {
-      ++m_current;
-    }
-    return m_current < m_generators.size();
-  }
-};
+        T const& get() const override {
+            return m_generators[m_current].get();
+        }
 
-template<typename... Ts>
-GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<typename std::decay<Ts>::type...>> tuples ) {
-  return values<std::tuple<Ts...>>( tuples );
-}
+        bool next() override {
+            if (m_current >= m_generators.size()) {
+                return false;
+            }
+            const bool current_status = m_generators[m_current].next();
+            if (!current_status) {
+                ++m_current;
+            }
+            return m_current < m_generators.size();
+        }
+    };
 
-// Tag type to signal that a generator sequence should convert arguments to a specific type
-template <typename T>
-struct as {};
+    template<typename... Ts>
+    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<typename std::decay<Ts>::type...>> tuples ) {
+        return values<std::tuple<Ts...>>( tuples );
+    }
 
-template<typename T, typename... Gs>
-auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {
-  return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);
-}
-template<typename T>
-auto makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> {
-  return Generators<T>(std::move(generator));
-}
-template<typename T, typename... Gs>
-auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {
-  return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );
-}
-template<typename T, typename U, typename... Gs>
-auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {
-  return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );
-}
+    // Tag type to signal that a generator sequence should convert arguments to a specific type
+    template <typename T>
+    struct as {};
 
-auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker&;
+    template<typename T, typename... Gs>
+    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {
+        return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);
+    }
+    template<typename T>
+    auto makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> {
+        return Generators<T>(std::move(generator));
+    }
+    template<typename T, typename... Gs>
+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {
+        return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );
+    }
+    template<typename T, typename U, typename... Gs>
+    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {
+        return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );
+    }
 
-template<typename L>
-// Note: The type after -> is weird, because VS2015 cannot parse
-//       the expression used in the typedef inside, when it is in
-//       return type. Yeah.
-auto generate( StringRef generatorName, SourceLineInfo const& lineInfo, L const& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>().get()) {
-  using UnderlyingType = typename decltype(generatorExpression())::type;
+    auto acquireGeneratorTracker( StringRef generatorName, SourceLineInfo const& lineInfo ) -> IGeneratorTracker&;
 
-  IGeneratorTracker& tracker = acquireGeneratorTracker( generatorName, lineInfo );
-  if (!tracker.hasGenerator()) {
-    tracker.setGenerator(pf::make_unique<Generators<UnderlyingType>>(generatorExpression()));
-  }
+    template<typename L>
+    // Note: The type after -> is weird, because VS2015 cannot parse
+    //       the expression used in the typedef inside, when it is in
+    //       return type. Yeah.
+    auto generate( StringRef generatorName, SourceLineInfo const& lineInfo, L const& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>().get()) {
+        using UnderlyingType = typename decltype(generatorExpression())::type;
 
-  auto const& generator = static_cast<IGenerator<UnderlyingType> const&>( *tracker.getGenerator() );
-  return generator.get();
-}
+        IGeneratorTracker& tracker = acquireGeneratorTracker( generatorName, lineInfo );
+        if (!tracker.hasGenerator()) {
+            tracker.setGenerator(pf::make_unique<Generators<UnderlyingType>>(generatorExpression()));
+        }
+
+        auto const& generator = static_cast<IGenerator<UnderlyingType> const&>( *tracker.getGenerator() );
+        return generator.get();
+    }
 
 } // namespace Generators
 } // namespace Catch
@@ -4111,220 +4116,225 @@ auto generate( StringRef generatorName, SourceLineInfo const& lineInfo, L const&
 namespace Catch {
 namespace Generators {
 
-template <typename T>
-class TakeGenerator : public IGenerator<T> {
-  GeneratorWrapper<T> m_generator;
-  size_t m_returned = 0;
-  size_t m_target;
- public:
-  TakeGenerator(size_t target, GeneratorWrapper<T>&& generator):
-      m_generator(std::move(generator)),
-      m_target(target)
-  {
-    assert(target != 0 && "Empty generators are not allowed");
-  }
-  T const& get() const override {
-    return m_generator.get();
-  }
-  bool next() override {
-    ++m_returned;
-    if (m_returned >= m_target) {
-      return false;
-    }
-
-    const auto success = m_generator.next();
-    // If the underlying generator does not contain enough values
-    // then we cut short as well
-    if (!success) {
-      m_returned = m_target;
-    }
-    return success;
-  }
-};
+    template <typename T>
+    class TakeGenerator : public IGenerator<T> {
+        GeneratorWrapper<T> m_generator;
+        size_t m_returned = 0;
+        size_t m_target;
+    public:
+        TakeGenerator(size_t target, GeneratorWrapper<T>&& generator):
+            m_generator(std::move(generator)),
+            m_target(target)
+        {
+            assert(target != 0 && "Empty generators are not allowed");
+        }
+        T const& get() const override {
+            return m_generator.get();
+        }
+        bool next() override {
+            ++m_returned;
+            if (m_returned >= m_target) {
+                return false;
+            }
 
-template <typename T>
-GeneratorWrapper<T> take(size_t target, GeneratorWrapper<T>&& generator) {
-  return GeneratorWrapper<T>(pf::make_unique<TakeGenerator<T>>(target, std::move(generator)));
-}
+            const auto success = m_generator.next();
+            // If the underlying generator does not contain enough values
+            // then we cut short as well
+            if (!success) {
+                m_returned = m_target;
+            }
+            return success;
+        }
+    };
 
-template <typename T, typename Predicate>
-class FilterGenerator : public IGenerator<T> {
-  GeneratorWrapper<T> m_generator;
-  Predicate m_predicate;
- public:
-  template <typename P = Predicate>
-  FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):
-      m_generator(std::move(generator)),
-      m_predicate(std::forward<P>(pred))
-  {
-    if (!m_predicate(m_generator.get())) {
-      // It might happen that there are no values that pass the
-      // filter. In that case we throw an exception.
-      auto has_initial_value = next();
-      if (!has_initial_value) {
-        Catch::throw_exception(GeneratorException("No valid value found in filtered generator"));
-      }
+    template <typename T>
+    GeneratorWrapper<T> take(size_t target, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<T>(pf::make_unique<TakeGenerator<T>>(target, std::move(generator)));
     }
-  }
 
-  T const& get() const override {
-    return m_generator.get();
-  }
+    template <typename T, typename Predicate>
+    class FilterGenerator : public IGenerator<T> {
+        GeneratorWrapper<T> m_generator;
+        Predicate m_predicate;
+    public:
+        template <typename P = Predicate>
+        FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):
+            m_generator(std::move(generator)),
+            m_predicate(std::forward<P>(pred))
+        {
+            if (!m_predicate(m_generator.get())) {
+                // It might happen that there are no values that pass the
+                // filter. In that case we throw an exception.
+                auto has_initial_value = nextImpl();
+                if (!has_initial_value) {
+                    Catch::throw_exception(GeneratorException("No valid value found in filtered generator"));
+                }
+            }
+        }
 
-  bool next() override {
-    bool success = m_generator.next();
-    if (!success) {
-      return false;
-    }
-    while (!m_predicate(m_generator.get()) && (success = m_generator.next()));
-    return success;
-  }
-};
+        T const& get() const override {
+            return m_generator.get();
+        }
 
-template <typename T, typename Predicate>
-GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) {
-  return GeneratorWrapper<T>(std::unique_ptr<IGenerator<T>>(pf::make_unique<FilterGenerator<T, Predicate>>(std::forward<Predicate>(pred), std::move(generator))));
-}
+        bool next() override {
+            return nextImpl();
+        }
 
-template <typename T>
-class RepeatGenerator : public IGenerator<T> {
-  static_assert(!std::is_same<T, bool>::value,
-                "RepeatGenerator currently does not support bools"
-                "because of std::vector<bool> specialization");
-  GeneratorWrapper<T> m_generator;
-  mutable std::vector<T> m_returned;
-  size_t m_target_repeats;
-  size_t m_current_repeat = 0;
-  size_t m_repeat_index = 0;
- public:
-  RepeatGenerator(size_t repeats, GeneratorWrapper<T>&& generator):
-      m_generator(std::move(generator)),
-      m_target_repeats(repeats)
-  {
-    assert(m_target_repeats > 0 && "Repeat generator must repeat at least once");
-  }
+    private:
+        bool nextImpl() {
+            bool success = m_generator.next();
+            if (!success) {
+                return false;
+            }
+            while (!m_predicate(m_generator.get()) && (success = m_generator.next()) == true);
+            return success;
+        }
+    };
 
-  T const& get() const override {
-    if (m_current_repeat == 0) {
-      m_returned.push_back(m_generator.get());
-      return m_returned.back();
+    template <typename T, typename Predicate>
+    GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<T>(std::unique_ptr<IGenerator<T>>(pf::make_unique<FilterGenerator<T, Predicate>>(std::forward<Predicate>(pred), std::move(generator))));
     }
-    return m_returned[m_repeat_index];
-  }
 
-  bool next() override {
-    // There are 2 basic cases:
-    // 1) We are still reading the generator
-    // 2) We are reading our own cache
-
-    // In the first case, we need to poke the underlying generator.
-    // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache
-    if (m_current_repeat == 0) {
-      const auto success = m_generator.next();
-      if (!success) {
-        ++m_current_repeat;
-      }
-      return m_current_repeat < m_target_repeats;
-    }
+    template <typename T>
+    class RepeatGenerator : public IGenerator<T> {
+        static_assert(!std::is_same<T, bool>::value,
+            "RepeatGenerator currently does not support bools"
+            "because of std::vector<bool> specialization");
+        GeneratorWrapper<T> m_generator;
+        mutable std::vector<T> m_returned;
+        size_t m_target_repeats;
+        size_t m_current_repeat = 0;
+        size_t m_repeat_index = 0;
+    public:
+        RepeatGenerator(size_t repeats, GeneratorWrapper<T>&& generator):
+            m_generator(std::move(generator)),
+            m_target_repeats(repeats)
+        {
+            assert(m_target_repeats > 0 && "Repeat generator must repeat at least once");
+        }
 
-    // In the second case, we need to move indices forward and check that we haven't run up against the end
-    ++m_repeat_index;
-    if (m_repeat_index == m_returned.size()) {
-      m_repeat_index = 0;
-      ++m_current_repeat;
-    }
-    return m_current_repeat < m_target_repeats;
-  }
-};
+        T const& get() const override {
+            if (m_current_repeat == 0) {
+                m_returned.push_back(m_generator.get());
+                return m_returned.back();
+            }
+            return m_returned[m_repeat_index];
+        }
 
-template <typename T>
-GeneratorWrapper<T> repeat(size_t repeats, GeneratorWrapper<T>&& generator) {
-  return GeneratorWrapper<T>(pf::make_unique<RepeatGenerator<T>>(repeats, std::move(generator)));
-}
+        bool next() override {
+            // There are 2 basic cases:
+            // 1) We are still reading the generator
+            // 2) We are reading our own cache
 
-template <typename T, typename U, typename Func>
-class MapGenerator : public IGenerator<T> {
-  // TBD: provide static assert for mapping function, for friendly error message
-  GeneratorWrapper<U> m_generator;
-  Func m_function;
-  // To avoid returning dangling reference, we have to save the values
-  T m_cache;
- public:
-  template <typename F2 = Func>
-  MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :
-      m_generator(std::move(generator)),
-      m_function(std::forward<F2>(function)),
-      m_cache(m_function(m_generator.get()))
-  {}
-
-  T const& get() const override {
-    return m_cache;
-  }
-  bool next() override {
-    const auto success = m_generator.next();
-    if (success) {
-      m_cache = m_function(m_generator.get());
+            // In the first case, we need to poke the underlying generator.
+            // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache
+            if (m_current_repeat == 0) {
+                const auto success = m_generator.next();
+                if (!success) {
+                    ++m_current_repeat;
+                }
+                return m_current_repeat < m_target_repeats;
+            }
+
+            // In the second case, we need to move indices forward and check that we haven't run up against the end
+            ++m_repeat_index;
+            if (m_repeat_index == m_returned.size()) {
+                m_repeat_index = 0;
+                ++m_current_repeat;
+            }
+            return m_current_repeat < m_target_repeats;
+        }
+    };
+
+    template <typename T>
+    GeneratorWrapper<T> repeat(size_t repeats, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<T>(pf::make_unique<RepeatGenerator<T>>(repeats, std::move(generator)));
     }
-    return success;
-  }
-};
 
-template <typename Func, typename U, typename T = FunctionReturnType<Func, U>>
-GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
-  return GeneratorWrapper<T>(
-      pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
-  );
-}
+    template <typename T, typename U, typename Func>
+    class MapGenerator : public IGenerator<T> {
+        // TBD: provide static assert for mapping function, for friendly error message
+        GeneratorWrapper<U> m_generator;
+        Func m_function;
+        // To avoid returning dangling reference, we have to save the values
+        T m_cache;
+    public:
+        template <typename F2 = Func>
+        MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :
+            m_generator(std::move(generator)),
+            m_function(std::forward<F2>(function)),
+            m_cache(m_function(m_generator.get()))
+        {}
 
-template <typename T, typename U, typename Func>
-GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
-  return GeneratorWrapper<T>(
-      pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
-  );
-}
+        T const& get() const override {
+            return m_cache;
+        }
+        bool next() override {
+            const auto success = m_generator.next();
+            if (success) {
+                m_cache = m_function(m_generator.get());
+            }
+            return success;
+        }
+    };
 
-template <typename T>
-class ChunkGenerator final : public IGenerator<std::vector<T>> {
-  std::vector<T> m_chunk;
-  size_t m_chunk_size;
-  GeneratorWrapper<T> m_generator;
-  bool m_used_up = false;
- public:
-  ChunkGenerator(size_t size, GeneratorWrapper<T> generator) :
-      m_chunk_size(size), m_generator(std::move(generator))
-  {
-    m_chunk.reserve(m_chunk_size);
-    if (m_chunk_size != 0) {
-      m_chunk.push_back(m_generator.get());
-      for (size_t i = 1; i < m_chunk_size; ++i) {
-        if (!m_generator.next()) {
-          Catch::throw_exception(GeneratorException("Not enough values to initialize the first chunk"));
-        }
-        m_chunk.push_back(m_generator.get());
-      }
+    template <typename Func, typename U, typename T = FunctionReturnType<Func, U>>
+    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
+        return GeneratorWrapper<T>(
+            pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
+        );
     }
-  }
-  std::vector<T> const& get() const override {
-    return m_chunk;
-  }
-  bool next() override {
-    m_chunk.clear();
-    for (size_t idx = 0; idx < m_chunk_size; ++idx) {
-      if (!m_generator.next()) {
-        return false;
-      }
-      m_chunk.push_back(m_generator.get());
+
+    template <typename T, typename U, typename Func>
+    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
+        return GeneratorWrapper<T>(
+            pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
+        );
     }
-    return true;
-  }
-};
 
-template <typename T>
-GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& generator) {
-  return GeneratorWrapper<std::vector<T>>(
-      pf::make_unique<ChunkGenerator<T>>(size, std::move(generator))
-  );
-}
+    template <typename T>
+    class ChunkGenerator final : public IGenerator<std::vector<T>> {
+        std::vector<T> m_chunk;
+        size_t m_chunk_size;
+        GeneratorWrapper<T> m_generator;
+        bool m_used_up = false;
+    public:
+        ChunkGenerator(size_t size, GeneratorWrapper<T> generator) :
+            m_chunk_size(size), m_generator(std::move(generator))
+        {
+            m_chunk.reserve(m_chunk_size);
+            if (m_chunk_size != 0) {
+                m_chunk.push_back(m_generator.get());
+                for (size_t i = 1; i < m_chunk_size; ++i) {
+                    if (!m_generator.next()) {
+                        Catch::throw_exception(GeneratorException("Not enough values to initialize the first chunk"));
+                    }
+                    m_chunk.push_back(m_generator.get());
+                }
+            }
+        }
+        std::vector<T> const& get() const override {
+            return m_chunk;
+        }
+        bool next() override {
+            m_chunk.clear();
+            for (size_t idx = 0; idx < m_chunk_size; ++idx) {
+                if (!m_generator.next()) {
+                    return false;
+                }
+                m_chunk.push_back(m_generator.get());
+            }
+            return true;
+        }
+    };
+
+    template <typename T>
+    GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<std::vector<T>>(
+            pf::make_unique<ChunkGenerator<T>>(size, std::move(generator))
+        );
+    }
 
 } // namespace Generators
 } // namespace Catch
@@ -4338,53 +4348,53 @@ GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& genera
 
 namespace Catch {
 
-struct IResultCapture;
-struct IRunner;
-struct IConfig;
-struct IMutableContext;
+    struct IResultCapture;
+    struct IRunner;
+    struct IConfig;
+    struct IMutableContext;
 
-using IConfigPtr = std::shared_ptr<IConfig const>;
+    using IConfigPtr = std::shared_ptr<IConfig const>;
 
-struct IContext
-{
-  virtual ~IContext();
+    struct IContext
+    {
+        virtual ~IContext();
 
-  virtual IResultCapture* getResultCapture() = 0;
-  virtual IRunner* getRunner() = 0;
-  virtual IConfigPtr const& getConfig() const = 0;
-};
+        virtual IResultCapture* getResultCapture() = 0;
+        virtual IRunner* getRunner() = 0;
+        virtual IConfigPtr const& getConfig() const = 0;
+    };
 
-struct IMutableContext : IContext
-{
-  virtual ~IMutableContext();
-  virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
-  virtual void setRunner( IRunner* runner ) = 0;
-  virtual void setConfig( IConfigPtr const& config ) = 0;
-
- private:
-  static IMutableContext *currentContext;
-  friend IMutableContext& getCurrentMutableContext();
-  friend void cleanUpContext();
-  static void createContext();
-};
+    struct IMutableContext : IContext
+    {
+        virtual ~IMutableContext();
+        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
+        virtual void setRunner( IRunner* runner ) = 0;
+        virtual void setConfig( IConfigPtr const& config ) = 0;
 
-inline IMutableContext& getCurrentMutableContext()
-{
-  if( !IMutableContext::currentContext )
-    IMutableContext::createContext();
-  // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
-  return *IMutableContext::currentContext;
-}
+    private:
+        static IMutableContext *currentContext;
+        friend IMutableContext& getCurrentMutableContext();
+        friend void cleanUpContext();
+        static void createContext();
+    };
 
-inline IContext& getCurrentContext()
-{
-  return getCurrentMutableContext();
-}
+    inline IMutableContext& getCurrentMutableContext()
+    {
+        if( !IMutableContext::currentContext )
+            IMutableContext::createContext();
+        // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
+        return *IMutableContext::currentContext;
+    }
 
-void cleanUpContext();
+    inline IContext& getCurrentContext()
+    {
+        return getCurrentMutableContext();
+    }
 
-class SimplePcg32;
-SimplePcg32& rng();
+    void cleanUpContext();
+
+    class SimplePcg32;
+    SimplePcg32& rng();
 }
 
 // end catch_context.h
@@ -4394,63 +4404,63 @@ SimplePcg32& rng();
 
 namespace Catch {
 
-// An optional type
-template<typename T>
-class Option {
- public:
-  Option() : nullableValue( nullptr ) {}
-  Option( T const& _value )
-      : nullableValue( new( storage ) T( _value ) )
-  {}
-  Option( Option const& _other )
-      : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
-  {}
-
-  ~Option() {
-    reset();
-  }
+    // An optional type
+    template<typename T>
+    class Option {
+    public:
+        Option() : nullableValue( nullptr ) {}
+        Option( T const& _value )
+        : nullableValue( new( storage ) T( _value ) )
+        {}
+        Option( Option const& _other )
+        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
+        {}
 
-  Option& operator= ( Option const& _other ) {
-    if( &_other != this ) {
-      reset();
-      if( _other )
-        nullableValue = new( storage ) T( *_other );
-    }
-    return *this;
-  }
-  Option& operator = ( T const& _value ) {
-    reset();
-    nullableValue = new( storage ) T( _value );
-    return *this;
-  }
+        ~Option() {
+            reset();
+        }
 
-  void reset() {
-    if( nullableValue )
-      nullableValue->~T();
-    nullableValue = nullptr;
-  }
+        Option& operator= ( Option const& _other ) {
+            if( &_other != this ) {
+                reset();
+                if( _other )
+                    nullableValue = new( storage ) T( *_other );
+            }
+            return *this;
+        }
+        Option& operator = ( T const& _value ) {
+            reset();
+            nullableValue = new( storage ) T( _value );
+            return *this;
+        }
+
+        void reset() {
+            if( nullableValue )
+                nullableValue->~T();
+            nullableValue = nullptr;
+        }
 
-  T& operator*() { return *nullableValue; }
-  T const& operator*() const { return *nullableValue; }
-  T* operator->() { return nullableValue; }
-  const T* operator->() const { return nullableValue; }
+        T& operator*() { return *nullableValue; }
+        T const& operator*() const { return *nullableValue; }
+        T* operator->() { return nullableValue; }
+        const T* operator->() const { return nullableValue; }
 
-  T valueOr( T const& defaultValue ) const {
-    return nullableValue ? *nullableValue : defaultValue;
-  }
+        T valueOr( T const& defaultValue ) const {
+            return nullableValue ? *nullableValue : defaultValue;
+        }
 
-  bool some() const { return nullableValue != nullptr; }
-  bool none() const { return nullableValue == nullptr; }
+        bool some() const { return nullableValue != nullptr; }
+        bool none() const { return nullableValue == nullptr; }
 
-  bool operator !() const { return nullableValue == nullptr; }
-  explicit operator bool() const {
-    return some();
-  }
+        bool operator !() const { return nullableValue == nullptr; }
+        explicit operator bool() const {
+            return some();
+        }
 
- private:
-  T *nullableValue;
-  alignas(alignof(T)) char storage[sizeof(T)];
-};
+    private:
+        T *nullableValue;
+        alignas(alignof(T)) char storage[sizeof(T)];
+    };
 
 } // end namespace Catch
 
@@ -4463,74 +4473,74 @@ class Option {
 
 namespace Catch {
 
-enum class Verbosity {
-  Quiet = 0,
-  Normal,
-  High
-};
+    enum class Verbosity {
+        Quiet = 0,
+        Normal,
+        High
+    };
 
-struct WarnAbout { enum What {
-    Nothing = 0x00,
-    NoAssertions = 0x01,
-    NoTests = 0x02
-  }; };
-
-struct ShowDurations { enum OrNot {
-    DefaultForReporter,
-    Always,
-    Never
-  }; };
-struct RunTests { enum InWhatOrder {
-    InDeclarationOrder,
-    InLexicographicalOrder,
-    InRandomOrder
-  }; };
-struct UseColour { enum YesOrNo {
-    Auto,
-    Yes,
-    No
-  }; };
-struct WaitForKeypress { enum When {
-    Never,
-    BeforeStart = 1,
-    BeforeExit = 2,
-    BeforeStartAndExit = BeforeStart | BeforeExit
-  }; };
-
-class TestSpec;
-
-struct IConfig : NonCopyable {
-
-  virtual ~IConfig();
-
-  virtual bool allowThrows() const = 0;
-  virtual std::ostream& stream() const = 0;
-  virtual std::string name() const = 0;
-  virtual bool includeSuccessfulResults() const = 0;
-  virtual bool shouldDebugBreak() const = 0;
-  virtual bool warnAboutMissingAssertions() const = 0;
-  virtual bool warnAboutNoTests() const = 0;
-  virtual int abortAfter() const = 0;
-  virtual bool showInvisibles() const = 0;
-  virtual ShowDurations::OrNot showDurations() const = 0;
-  virtual double minDuration() const = 0;
-  virtual TestSpec const& testSpec() const = 0;
-  virtual bool hasTestFilters() const = 0;
-  virtual std::vector<std::string> const& getTestsOrTags() const = 0;
-  virtual RunTests::InWhatOrder runOrder() const = 0;
-  virtual unsigned int rngSeed() const = 0;
-  virtual UseColour::YesOrNo useColour() const = 0;
-  virtual std::vector<std::string> const& getSectionsToRun() const = 0;
-  virtual Verbosity verbosity() const = 0;
-
-  virtual bool benchmarkNoAnalysis() const = 0;
-  virtual int benchmarkSamples() const = 0;
-  virtual double benchmarkConfidenceInterval() const = 0;
-  virtual unsigned int benchmarkResamples() const = 0;
-  virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
-};
+    struct WarnAbout { enum What {
+        Nothing = 0x00,
+        NoAssertions = 0x01,
+        NoTests = 0x02
+    }; };
+
+    struct ShowDurations { enum OrNot {
+        DefaultForReporter,
+        Always,
+        Never
+    }; };
+    struct RunTests { enum InWhatOrder {
+        InDeclarationOrder,
+        InLexicographicalOrder,
+        InRandomOrder
+    }; };
+    struct UseColour { enum YesOrNo {
+        Auto,
+        Yes,
+        No
+    }; };
+    struct WaitForKeypress { enum When {
+        Never,
+        BeforeStart = 1,
+        BeforeExit = 2,
+        BeforeStartAndExit = BeforeStart | BeforeExit
+    }; };
+
+    class TestSpec;
+
+    struct IConfig : NonCopyable {
+
+        virtual ~IConfig();
+
+        virtual bool allowThrows() const = 0;
+        virtual std::ostream& stream() const = 0;
+        virtual std::string name() const = 0;
+        virtual bool includeSuccessfulResults() const = 0;
+        virtual bool shouldDebugBreak() const = 0;
+        virtual bool warnAboutMissingAssertions() const = 0;
+        virtual bool warnAboutNoTests() const = 0;
+        virtual int abortAfter() const = 0;
+        virtual bool showInvisibles() const = 0;
+        virtual ShowDurations::OrNot showDurations() const = 0;
+        virtual double minDuration() const = 0;
+        virtual TestSpec const& testSpec() const = 0;
+        virtual bool hasTestFilters() const = 0;
+        virtual std::vector<std::string> const& getTestsOrTags() const = 0;
+        virtual RunTests::InWhatOrder runOrder() const = 0;
+        virtual unsigned int rngSeed() const = 0;
+        virtual UseColour::YesOrNo useColour() const = 0;
+        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
+        virtual Verbosity verbosity() const = 0;
+
+        virtual bool benchmarkNoAnalysis() const = 0;
+        virtual int benchmarkSamples() const = 0;
+        virtual double benchmarkConfidenceInterval() const = 0;
+        virtual unsigned int benchmarkResamples() const = 0;
+        virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
+    };
 
-using IConfigPtr = std::shared_ptr<IConfig const>;
+    using IConfigPtr = std::shared_ptr<IConfig const>;
 }
 
 // end catch_interfaces_config.h
@@ -4540,46 +4550,46 @@ using IConfigPtr = std::shared_ptr<IConfig const>;
 
 namespace Catch {
 
-// This is a simple implementation of C++11 Uniform Random Number
-// Generator. It does not provide all operators, because Catch2
-// does not use it, but it should behave as expected inside stdlib's
-// distributions.
-// The implementation is based on the PCG family (http://pcg-random.org)
-class SimplePcg32 {
-  using state_type = std::uint64_t;
- public:
-  using result_type = std::uint32_t;
-  static constexpr result_type (min)() {
-    return 0;
-  }
-  static constexpr result_type (max)() {
-    return static_cast<result_type>(-1);
-  }
-
-  // Provide some default initial state for the default constructor
-  SimplePcg32():SimplePcg32(0xed743cc4U) {}
-
-  explicit SimplePcg32(result_type seed_);
+    // This is a simple implementation of C++11 Uniform Random Number
+    // Generator. It does not provide all operators, because Catch2
+    // does not use it, but it should behave as expected inside stdlib's
+    // distributions.
+    // The implementation is based on the PCG family (http://pcg-random.org)
+    class SimplePcg32 {
+        using state_type = std::uint64_t;
+    public:
+        using result_type = std::uint32_t;
+        static constexpr result_type (min)() {
+            return 0;
+        }
+        static constexpr result_type (max)() {
+            return static_cast<result_type>(-1);
+        }
 
-  void seed(result_type seed_);
-  void discard(uint64_t skip);
+        // Provide some default initial state for the default constructor
+        SimplePcg32():SimplePcg32(0xed743cc4U) {}
 
-  result_type operator()();
+        explicit SimplePcg32(result_type seed_);
 
- private:
-  friend bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
-  friend bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
+        void seed(result_type seed_);
+        void discard(uint64_t skip);
 
-  // In theory we also need operator<< and operator>>
-  // In practice we do not use them, so we will skip them for now
+        result_type operator()();
 
-  std::uint64_t m_state;
-  // This part of the state determines which "stream" of the numbers
-  // is chosen -- we take it as a constant for Catch2, so we only
-  // need to deal with seeding the main state.
-  // Picked by reading 8 bytes from `/dev/random` :-)
-  static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;
-};
+    private:
+        friend bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
+        friend bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
+
+        // In theory we also need operator<< and operator>>
+        // In practice we do not use them, so we will skip them for now
+
+        std::uint64_t m_state;
+        // This part of the state determines which "stream" of the numbers
+        // is chosen -- we take it as a constant for Catch2, so we only
+        // need to deal with seeding the main state.
+        // Picked by reading 8 bytes from `/dev/random` :-)
+        static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;
+    };
 
 } // end namespace Catch
 
@@ -4591,150 +4601,150 @@ namespace Generators {
 
 template <typename Float>
 class RandomFloatingGenerator final : public IGenerator<Float> {
-  Catch::SimplePcg32& m_rng;
-  std::uniform_real_distribution<Float> m_dist;
-  Float m_current_number;
- public:
-
-  RandomFloatingGenerator(Float a, Float b):
-      m_rng(rng()),
-      m_dist(a, b) {
-    static_cast<void>(next());
-  }
+    Catch::SimplePcg32& m_rng;
+    std::uniform_real_distribution<Float> m_dist;
+    Float m_current_number;
+public:
 
-  Float const& get() const override {
-    return m_current_number;
-  }
-  bool next() override {
-    m_current_number = m_dist(m_rng);
-    return true;
-  }
+    RandomFloatingGenerator(Float a, Float b):
+        m_rng(rng()),
+        m_dist(a, b) {
+        static_cast<void>(next());
+    }
+
+    Float const& get() const override {
+        return m_current_number;
+    }
+    bool next() override {
+        m_current_number = m_dist(m_rng);
+        return true;
+    }
 };
 
 template <typename Integer>
 class RandomIntegerGenerator final : public IGenerator<Integer> {
-  Catch::SimplePcg32& m_rng;
-  std::uniform_int_distribution<Integer> m_dist;
-  Integer m_current_number;
- public:
-
-  RandomIntegerGenerator(Integer a, Integer b):
-      m_rng(rng()),
-      m_dist(a, b) {
-    static_cast<void>(next());
-  }
+    Catch::SimplePcg32& m_rng;
+    std::uniform_int_distribution<Integer> m_dist;
+    Integer m_current_number;
+public:
 
-  Integer const& get() const override {
-    return m_current_number;
-  }
-  bool next() override {
-    m_current_number = m_dist(m_rng);
-    return true;
-  }
+    RandomIntegerGenerator(Integer a, Integer b):
+        m_rng(rng()),
+        m_dist(a, b) {
+        static_cast<void>(next());
+    }
+
+    Integer const& get() const override {
+        return m_current_number;
+    }
+    bool next() override {
+        m_current_number = m_dist(m_rng);
+        return true;
+    }
 };
 
 // TODO: Ideally this would be also constrained against the various char types,
 //       but I don't expect users to run into that in practice.
 template <typename T>
 typename std::enable_if<std::is_integral<T>::value && !std::is_same<T, bool>::value,
-    GeneratorWrapper<T>>::type
+GeneratorWrapper<T>>::type
 random(T a, T b) {
-  return GeneratorWrapper<T>(
-      pf::make_unique<RandomIntegerGenerator<T>>(a, b)
-  );
+    return GeneratorWrapper<T>(
+        pf::make_unique<RandomIntegerGenerator<T>>(a, b)
+    );
 }
 
 template <typename T>
 typename std::enable_if<std::is_floating_point<T>::value,
-    GeneratorWrapper<T>>::type
+GeneratorWrapper<T>>::type
 random(T a, T b) {
-  return GeneratorWrapper<T>(
-      pf::make_unique<RandomFloatingGenerator<T>>(a, b)
-  );
+    return GeneratorWrapper<T>(
+        pf::make_unique<RandomFloatingGenerator<T>>(a, b)
+    );
 }
 
 template <typename T>
 class RangeGenerator final : public IGenerator<T> {
-  T m_current;
-  T m_end;
-  T m_step;
-  bool m_positive;
-
- public:
-  RangeGenerator(T const& start, T const& end, T const& step):
-      m_current(start),
-      m_end(end),
-      m_step(step),
-      m_positive(m_step > T(0))
-  {
-    assert(m_current != m_end && "Range start and end cannot be equal");
-    assert(m_step != T(0) && "Step size cannot be zero");
-    assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");
-  }
+    T m_current;
+    T m_end;
+    T m_step;
+    bool m_positive;
+
+public:
+    RangeGenerator(T const& start, T const& end, T const& step):
+        m_current(start),
+        m_end(end),
+        m_step(step),
+        m_positive(m_step > T(0))
+    {
+        assert(m_current != m_end && "Range start and end cannot be equal");
+        assert(m_step != T(0) && "Step size cannot be zero");
+        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");
+    }
 
-  RangeGenerator(T const& start, T const& end):
-      RangeGenerator(start, end, (start < end) ? T(1) : T(-1))
-  {}
+    RangeGenerator(T const& start, T const& end):
+        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))
+    {}
 
-  T const& get() const override {
-    return m_current;
-  }
+    T const& get() const override {
+        return m_current;
+    }
 
-  bool next() override {
-    m_current += m_step;
-    return (m_positive) ? (m_current < m_end) : (m_current > m_end);
-  }
+    bool next() override {
+        m_current += m_step;
+        return (m_positive) ? (m_current < m_end) : (m_current > m_end);
+    }
 };
 
 template <typename T>
 GeneratorWrapper<T> range(T const& start, T const& end, T const& step) {
-  static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");
-  return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end, step));
+    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");
+    return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end, step));
 }
 
 template <typename T>
 GeneratorWrapper<T> range(T const& start, T const& end) {
-  static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");
-  return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end));
+    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");
+    return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end));
 }
 
 template <typename T>
 class IteratorGenerator final : public IGenerator<T> {
-  static_assert(!std::is_same<T, bool>::value,
-                "IteratorGenerator currently does not support bools"
-                "because of std::vector<bool> specialization");
-
-  std::vector<T> m_elems;
-  size_t m_current = 0;
- public:
-  template <typename InputIterator, typename InputSentinel>
-  IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
-    if (m_elems.empty()) {
-      Catch::throw_exception(GeneratorException("IteratorGenerator received no valid values"));
+    static_assert(!std::is_same<T, bool>::value,
+        "IteratorGenerator currently does not support bools"
+        "because of std::vector<bool> specialization");
+
+    std::vector<T> m_elems;
+    size_t m_current = 0;
+public:
+    template <typename InputIterator, typename InputSentinel>
+    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
+        if (m_elems.empty()) {
+            Catch::throw_exception(GeneratorException("IteratorGenerator received no valid values"));
+        }
     }
-  }
 
-  T const& get() const override {
-    return m_elems[m_current];
-  }
+    T const& get() const override {
+        return m_elems[m_current];
+    }
 
-  bool next() override {
-    ++m_current;
-    return m_current != m_elems.size();
-  }
+    bool next() override {
+        ++m_current;
+        return m_current != m_elems.size();
+    }
 };
 
 template <typename InputIterator,
-    typename InputSentinel,
-    typename ResultType = typename std::iterator_traits<InputIterator>::value_type>
+          typename InputSentinel,
+          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>
 GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) {
-  return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(from, to));
+    return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(from, to));
 }
 
 template <typename Container,
-    typename ResultType = typename Container::value_type>
+          typename ResultType = typename Container::value_type>
 GeneratorWrapper<ResultType> from_range(Container const& cnt) {
-  return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));
+    return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));
 }
 
 } // namespace Generators
@@ -4757,65 +4767,65 @@ GeneratorWrapper<ResultType> from_range(Container const& cnt) {
 
 namespace Catch {
 
-struct ITestInvoker;
-
-struct TestCaseInfo {
-  enum SpecialProperties{
-    None = 0,
-    IsHidden = 1 << 1,
-    ShouldFail = 1 << 2,
-    MayFail = 1 << 3,
-    Throws = 1 << 4,
-    NonPortable = 1 << 5,
-    Benchmark = 1 << 6
-  };
-
-  TestCaseInfo(   std::string const& _name,
-                  std::string const& _className,
-                  std::string const& _description,
-                  std::vector<std::string> const& _tags,
-                  SourceLineInfo const& _lineInfo );
-
-  friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );
-
-  bool isHidden() const;
-  bool throws() const;
-  bool okToFail() const;
-  bool expectedToFail() const;
-
-  std::string tagsAsString() const;
-
-  std::string name;
-  std::string className;
-  std::string description;
-  std::vector<std::string> tags;
-  std::vector<std::string> lcaseTags;
-  SourceLineInfo lineInfo;
-  SpecialProperties properties;
-};
+    struct ITestInvoker;
 
-class TestCase : public TestCaseInfo {
- public:
+    struct TestCaseInfo {
+        enum SpecialProperties{
+            None = 0,
+            IsHidden = 1 << 1,
+            ShouldFail = 1 << 2,
+            MayFail = 1 << 3,
+            Throws = 1 << 4,
+            NonPortable = 1 << 5,
+            Benchmark = 1 << 6
+        };
 
-  TestCase( ITestInvoker* testCase, TestCaseInfo&& info );
+        TestCaseInfo(   std::string const& _name,
+                        std::string const& _className,
+                        std::string const& _description,
+                        std::vector<std::string> const& _tags,
+                        SourceLineInfo const& _lineInfo );
 
-  TestCase withName( std::string const& _newName ) const;
+        friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );
 
-  void invoke() const;
+        bool isHidden() const;
+        bool throws() const;
+        bool okToFail() const;
+        bool expectedToFail() const;
 
-  TestCaseInfo const& getTestCaseInfo() const;
+        std::string tagsAsString() const;
 
-  bool operator == ( TestCase const& other ) const;
-  bool operator < ( TestCase const& other ) const;
+        std::string name;
+        std::string className;
+        std::string description;
+        std::vector<std::string> tags;
+        std::vector<std::string> lcaseTags;
+        SourceLineInfo lineInfo;
+        SpecialProperties properties;
+    };
 
- private:
-  std::shared_ptr<ITestInvoker> test;
-};
+    class TestCase : public TestCaseInfo {
+    public:
+
+        TestCase( ITestInvoker* testCase, TestCaseInfo&& info );
+
+        TestCase withName( std::string const& _newName ) const;
+
+        void invoke() const;
+
+        TestCaseInfo const& getTestCaseInfo() const;
+
+        bool operator == ( TestCase const& other ) const;
+        bool operator < ( TestCase const& other ) const;
+
+    private:
+        std::shared_ptr<ITestInvoker> test;
+    };
 
-TestCase makeTestCase(  ITestInvoker* testCase,
-                        std::string const& className,
-                        NameAndTags const& nameAndTags,
-                        SourceLineInfo const& lineInfo );
+    TestCase makeTestCase(  ITestInvoker* testCase,
+                            std::string const& className,
+                            NameAndTags const& nameAndTags,
+                            SourceLineInfo const& lineInfo );
 }
 
 #ifdef __clang__
@@ -4827,10 +4837,10 @@ TestCase makeTestCase(  ITestInvoker* testCase,
 
 namespace Catch {
 
-struct IRunner {
-  virtual ~IRunner();
-  virtual bool aborting() const = 0;
-};
+    struct IRunner {
+        virtual ~IRunner();
+        virtual bool aborting() const = 0;
+    };
 }
 
 // end catch_interfaces_runner.h
@@ -5455,6 +5465,8 @@ namespace Catch {
 } // namespace Catch
 
 // end catch_outlier_classification.hpp
+
+#include <iterator>
 #endif // CATCH_CONFIG_ENABLE_BENCHMARKING
 
 #include <string>
@@ -6339,9 +6351,10 @@ namespace Catch {
 
         void writeTestCase(TestCaseNode const& testCaseNode);
 
-        void writeSection(std::string const& className,
-                          std::string const& rootName,
-                          SectionNode const& sectionNode);
+        void writeSection( std::string const& className,
+                           std::string const& rootName,
+                           SectionNode const& sectionNode,
+                           bool testOkToFail );
 
         void writeAssertions(SectionNode const& sectionNode);
         void writeAssertion(AssertionStats const& stats);
@@ -6876,7 +6889,7 @@ namespace Catch {
                     }
                     iters *= 2;
                 }
-                throw optimized_away_error{};
+                Catch::throw_exception(optimized_away_error{});
             }
         } // namespace Detail
     } // namespace Benchmark
@@ -6884,6 +6897,7 @@ namespace Catch {
 
 // end catch_run_for_at_least.hpp
 #include <algorithm>
+#include <iterator>
 
 namespace Catch {
     namespace Benchmark {
@@ -7054,8 +7068,8 @@ namespace Catch {
                 double b2 = bias - z1;
                 double a1 = a(b1);
                 double a2 = a(b2);
-                auto lo = std::max(cumn(a1), 0);
-                auto hi = std::min(cumn(a2), n - 1);
+                auto lo = (std::max)(cumn(a1), 0);
+                auto hi = (std::min)(cumn(a2), n - 1);
 
                 return { point, resample[lo], resample[hi], confidence_level };
             }
@@ -7124,7 +7138,9 @@ namespace Catch {
             }
             template <typename Clock>
             EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {
-                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));
+                auto time_limit = (std::min)(
+                    resolution * clock_cost_estimation_tick_limit,
+                    FloatDuration<Clock>(clock_cost_estimation_time_limit));
                 auto time_clock = [](int k) {
                     return Detail::measure<Clock>([k] {
                         for (int i = 0; i < k; ++i) {
@@ -7379,8 +7395,6 @@ namespace Catch {
             template <typename T, bool Destruct>
             struct ObjectStorage
             {
-                using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;
-
                 ObjectStorage() : data() {}
 
                 ObjectStorage(const ObjectStorage& other)
@@ -7423,7 +7437,7 @@ namespace Catch {
                     return *static_cast<T*>(static_cast<void*>(&data));
                 }
 
-                TStorage data;
+                struct { alignas(T) unsigned char data[sizeof(T)]; }  data;
             };
         }
 
@@ -7771,7 +7785,7 @@ namespace Catch {
                 double sb = stddev.point;
                 double mn = mean.point / n;
                 double mg_min = mn / 2.;
-                double sg = std::min(mg_min / 4., sb / std::sqrt(n));
+                double sg = (std::min)(mg_min / 4., sb / std::sqrt(n));
                 double sg2 = sg * sg;
                 double sb2 = sb * sb;
 
@@ -7790,7 +7804,7 @@ namespace Catch {
                     return (nc / n) * (sb2 - nc * sg2);
                 };
 
-                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;
+                return (std::min)(var_out(1), var_out((std::min)(c_max(0.), c_max(mg_min)))) / sb2;
             }
 
             bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) {
@@ -7933,7 +7947,7 @@ namespace Catch {
     #if defined(__i386__) || defined(__x86_64__)
         #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
     #elif defined(__aarch64__)
-        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
+        #define CATCH_TRAP()  __asm__(".inst 0xd43e0000")
     #endif
 
 #elif defined(CATCH_PLATFORM_IPHONE)
@@ -7980,86 +7994,58 @@ namespace Catch {
 
 // start catch_fatal_condition.h
 
-// start catch_windows_h_proxy.h
-
-
-#if defined(CATCH_PLATFORM_WINDOWS)
-
-#if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
-#  define CATCH_DEFINED_NOMINMAX
-#  define NOMINMAX
-#endif
-#if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
-#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
-#  define WIN32_LEAN_AND_MEAN
-#endif
-
-#ifdef __AFXDLL
-#include <AfxWin.h>
-#else
-#include <windows.h>
-#endif
-
-#ifdef CATCH_DEFINED_NOMINMAX
-#  undef NOMINMAX
-#endif
-#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
-#  undef WIN32_LEAN_AND_MEAN
-#endif
-
-#endif // defined(CATCH_PLATFORM_WINDOWS)
-
-// end catch_windows_h_proxy.h
-#if defined( CATCH_CONFIG_WINDOWS_SEH )
+#include <cassert>
 
 namespace Catch {
 
-    struct FatalConditionHandler {
-
-        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);
+    // Wrapper for platform-specific fatal error (signals/SEH) handlers
+    //
+    // Tries to be cooperative with other handlers, and not step over
+    // other handlers. This means that unknown structured exceptions
+    // are passed on, previous signal handlers are called, and so on.
+    //
+    // Can only be instantiated once, and assumes that once a signal
+    // is caught, the binary will end up terminating. Thus, there
+    class FatalConditionHandler {
+        bool m_started = false;
+
+        // Install/disengage implementation for specific platform.
+        // Should be if-defed to work on current platform, can assume
+        // engage-disengage 1:1 pairing.
+        void engage_platform();
+        void disengage_platform();
+    public:
+        // Should also have platform-specific implementations as needed
         FatalConditionHandler();
-        static void reset();
         ~FatalConditionHandler();
 
-    private:
-        static bool isSet;
-        static ULONG guaranteeSize;
-        static PVOID exceptionHandlerHandle;
-    };
-
-} // namespace Catch
-
-#elif defined ( CATCH_CONFIG_POSIX_SIGNALS )
-
-#include <signal.h>
-
-namespace Catch {
-
-    struct FatalConditionHandler {
-
-        static bool isSet;
-        static struct sigaction oldSigActions[];
-        static stack_t oldSigStack;
-        static char altStackMem[];
-
-        static void handleSignal( int sig );
+        void engage() {
+            assert(!m_started && "Handler cannot be installed twice.");
+            m_started = true;
+            engage_platform();
+        }
 
-        FatalConditionHandler();
-        ~FatalConditionHandler();
-        static void reset();
+        void disengage() {
+            assert(m_started && "Handler cannot be uninstalled without being installed first");
+            m_started = false;
+            disengage_platform();
+        }
     };
 
-} // namespace Catch
-
-#else
-
-namespace Catch {
-    struct FatalConditionHandler {
-        void reset();
+    //! Simple RAII guard for (dis)engaging the FatalConditionHandler
+    class FatalConditionHandlerGuard {
+        FatalConditionHandler* m_handler;
+    public:
+        FatalConditionHandlerGuard(FatalConditionHandler* handler):
+            m_handler(handler) {
+            m_handler->engage();
+        }
+        ~FatalConditionHandlerGuard() {
+            m_handler->disengage();
+        }
     };
-}
 
-#endif
+} // end namespace Catch
 
 // end catch_fatal_condition.h
 #include <string>
@@ -8185,6 +8171,7 @@ namespace Catch {
         std::vector<SectionEndInfo> m_unfinishedSections;
         std::vector<ITracker*> m_activeSections;
         TrackerContext m_trackerContext;
+        FatalConditionHandler m_fatalConditionhandler;
         bool m_lastAssertionPassed = false;
         bool m_shouldReportUnexpected = true;
         bool m_includeSuccessfulResults;
@@ -10057,6 +10044,36 @@ namespace Catch {
 }
 
 // end catch_errno_guard.h
+// start catch_windows_h_proxy.h
+
+
+#if defined(CATCH_PLATFORM_WINDOWS)
+
+#if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
+#  define CATCH_DEFINED_NOMINMAX
+#  define NOMINMAX
+#endif
+#if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
+#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
+#  define WIN32_LEAN_AND_MEAN
+#endif
+
+#ifdef __AFXDLL
+#include <AfxWin.h>
+#else
+#include <windows.h>
+#endif
+
+#ifdef CATCH_DEFINED_NOMINMAX
+#  undef NOMINMAX
+#endif
+#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
+#  undef WIN32_LEAN_AND_MEAN
+#endif
+
+#endif // defined(CATCH_PLATFORM_WINDOWS)
+
+// end catch_windows_h_proxy.h
 #include <sstream>
 
 namespace Catch {
@@ -10573,7 +10590,7 @@ namespace Catch {
             // Extracts the actual name part of an enum instance
             // In other words, it returns the Blue part of Bikeshed::Colour::Blue
             StringRef extractInstanceName(StringRef enumInstance) {
-                // Find last occurence of ":"
+                // Find last occurrence of ":"
                 size_t name_start = enumInstance.size();
                 while (name_start > 0 && enumInstance[name_start - 1] != ':') {
                     --name_start;
@@ -10735,25 +10752,47 @@ namespace Catch {
 // end catch_exception_translator_registry.cpp
 // start catch_fatal_condition.cpp
 
-#if defined(__GNUC__)
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
-#endif
+#include <algorithm>
+
+#if !defined( CATCH_CONFIG_WINDOWS_SEH ) && !defined( CATCH_CONFIG_POSIX_SIGNALS )
+
+namespace Catch {
+
+    // If neither SEH nor signal handling is required, the handler impls
+    // do not have to do anything, and can be empty.
+    void FatalConditionHandler::engage_platform() {}
+    void FatalConditionHandler::disengage_platform() {}
+    FatalConditionHandler::FatalConditionHandler() = default;
+    FatalConditionHandler::~FatalConditionHandler() = default;
+
+} // end namespace Catch
+
+#endif // !CATCH_CONFIG_WINDOWS_SEH && !CATCH_CONFIG_POSIX_SIGNALS
+
+#if defined( CATCH_CONFIG_WINDOWS_SEH ) && defined( CATCH_CONFIG_POSIX_SIGNALS )
+#error "Inconsistent configuration: Windows' SEH handling and POSIX signals cannot be enabled at the same time"
+#endif // CATCH_CONFIG_WINDOWS_SEH && CATCH_CONFIG_POSIX_SIGNALS
 
 #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
 
 namespace {
-    // Report the error condition
+    //! Signals fatal error message to the run context
     void reportFatal( char const * const message ) {
         Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );
     }
-}
 
-#endif // signals/SEH handling
+    //! Minimal size Catch2 needs for its own fatal error handling.
+    //! Picked anecdotally, so it might not be sufficient on all
+    //! platforms, and for all configurations.
+    constexpr std::size_t minStackSizeForErrors = 32 * 1024;
+} // end unnamed namespace
+
+#endif // CATCH_CONFIG_WINDOWS_SEH || CATCH_CONFIG_POSIX_SIGNALS
 
 #if defined( CATCH_CONFIG_WINDOWS_SEH )
 
 namespace Catch {
+
     struct SignalDefs { DWORD id; const char* name; };
 
     // There is no 1-1 mapping between signals and windows exceptions.
@@ -10766,7 +10805,7 @@ namespace Catch {
         { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error" },
     };
 
-    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
+    static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
         for (auto const& def : signalDefs) {
             if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {
                 reportFatal(def.name);
@@ -10777,38 +10816,50 @@ namespace Catch {
         return EXCEPTION_CONTINUE_SEARCH;
     }
 
+    // Since we do not support multiple instantiations, we put these
+    // into global variables and rely on cleaning them up in outlined
+    // constructors/destructors
+    static PVOID exceptionHandlerHandle = nullptr;
+
+    // For MSVC, we reserve part of the stack memory for handling
+    // memory overflow structured exception.
     FatalConditionHandler::FatalConditionHandler() {
-        isSet = true;
-        // 32k seems enough for Catch to handle stack overflow,
-        // but the value was found experimentally, so there is no strong guarantee
-        guaranteeSize = 32 * 1024;
-        exceptionHandlerHandle = nullptr;
+        ULONG guaranteeSize = static_cast<ULONG>(minStackSizeForErrors);
+        if (!SetThreadStackGuarantee(&guaranteeSize)) {
+            // We do not want to fully error out, because needing
+            // the stack reserve should be rare enough anyway.
+            Catch::cerr()
+                << "Failed to reserve piece of stack."
+                << " Stack overflows will not be reported successfully.";
+        }
+    }
+
+    // We do not attempt to unset the stack guarantee, because
+    // Windows does not support lowering the stack size guarantee.
+    FatalConditionHandler::~FatalConditionHandler() = default;
+
+    void FatalConditionHandler::engage_platform() {
         // Register as first handler in current chain
         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
-        // Pass in guarantee size to be filled
-        SetThreadStackGuarantee(&guaranteeSize);
+        if (!exceptionHandlerHandle) {
+            CATCH_RUNTIME_ERROR("Could not register vectored exception handler");
+        }
     }
 
-    void FatalConditionHandler::reset() {
-        if (isSet) {
-            RemoveVectoredExceptionHandler(exceptionHandlerHandle);
-            SetThreadStackGuarantee(&guaranteeSize);
-            exceptionHandlerHandle = nullptr;
-            isSet = false;
+    void FatalConditionHandler::disengage_platform() {
+        if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {
+            CATCH_RUNTIME_ERROR("Could not unregister vectored exception handler");
         }
+        exceptionHandlerHandle = nullptr;
     }
 
-    FatalConditionHandler::~FatalConditionHandler() {
-        reset();
-    }
+} // end namespace Catch
 
-bool FatalConditionHandler::isSet = false;
-ULONG FatalConditionHandler::guaranteeSize = 0;
-PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;
+#endif // CATCH_CONFIG_WINDOWS_SEH
 
-} // namespace Catch
+#if defined( CATCH_CONFIG_POSIX_SIGNALS )
 
-#elif defined( CATCH_CONFIG_POSIX_SIGNALS )
+#include <signal.h>
 
 namespace Catch {
 
@@ -10817,10 +10868,6 @@ namespace Catch {
         const char* name;
     };
 
-    // 32kb for the alternate stack seems to be sufficient. However, this value
-    // is experimentally determined, so that's not guaranteed.
-    static constexpr std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;
-
     static SignalDefs signalDefs[] = {
         { SIGINT,  "SIGINT - Terminal interrupt signal" },
         { SIGILL,  "SIGILL - Illegal instruction signal" },
@@ -10830,7 +10877,32 @@ namespace Catch {
         { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
     };
 
-    void FatalConditionHandler::handleSignal( int sig ) {
+// Older GCCs trigger -Wmissing-field-initializers for T foo = {}
+// which is zero initialization, but not explicit. We want to avoid
+// that.
+#if defined(__GNUC__)
+#    pragma GCC diagnostic push
+#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
+#endif
+
+    static char* altStackMem = nullptr;
+    static std::size_t altStackSize = 0;
+    static stack_t oldSigStack{};
+    static struct sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]{};
+
+    static void restorePreviousSignalHandlers() {
+        // We set signal handlers back to the previous ones. Hopefully
+        // nobody overwrote them in the meantime, and doesn't expect
+        // their signal handlers to live past ours given that they
+        // installed them after ours..
+        for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
+            sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
+        }
+        // Return the old stack
+        sigaltstack(&oldSigStack, nullptr);
+    }
+
+    static void handleSignal( int sig ) {
         char const * name = "<unknown signal>";
         for (auto const& def : signalDefs) {
             if (sig == def.id) {
@@ -10838,16 +10910,33 @@ namespace Catch {
                 break;
             }
         }
-        reset();
-        reportFatal(name);
+        // We need to restore previous signal handlers and let them do
+        // their thing, so that the users can have the debugger break
+        // when a signal is raised, and so on.
+        restorePreviousSignalHandlers();
+        reportFatal( name );
         raise( sig );
     }
 
     FatalConditionHandler::FatalConditionHandler() {
-        isSet = true;
+        assert(!altStackMem && "Cannot initialize POSIX signal handler when one already exists");
+        if (altStackSize == 0) {
+            altStackSize = std::max(static_cast<size_t>(SIGSTKSZ), minStackSizeForErrors);
+        }
+        altStackMem = new char[altStackSize]();
+    }
+
+    FatalConditionHandler::~FatalConditionHandler() {
+        delete[] altStackMem;
+        // We signal that another instance can be constructed by zeroing
+        // out the pointer.
+        altStackMem = nullptr;
+    }
+
+    void FatalConditionHandler::engage_platform() {
         stack_t sigStack;
         sigStack.ss_sp = altStackMem;
-        sigStack.ss_size = sigStackSize;
+        sigStack.ss_size = altStackSize;
         sigStack.ss_flags = 0;
         sigaltstack(&sigStack, &oldSigStack);
         struct sigaction sa = { };
@@ -10859,40 +10948,17 @@ namespace Catch {
         }
     }
 
-    FatalConditionHandler::~FatalConditionHandler() {
-        reset();
-    }
+#if defined(__GNUC__)
+#    pragma GCC diagnostic pop
+#endif
 
-    void FatalConditionHandler::reset() {
-        if( isSet ) {
-            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
-            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
-                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
-            }
-            // Return the old stack
-            sigaltstack(&oldSigStack, nullptr);
-            isSet = false;
-        }
+    void FatalConditionHandler::disengage_platform() {
+        restorePreviousSignalHandlers();
     }
 
-    bool FatalConditionHandler::isSet = false;
-    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
-    stack_t FatalConditionHandler::oldSigStack = {};
-    char FatalConditionHandler::altStackMem[sigStackSize] = {};
-
-} // namespace Catch
-
-#else
-
-namespace Catch {
-    void FatalConditionHandler::reset() {}
-}
-
-#endif // signals/SEH handling
+} // end namespace Catch
 
-#if defined(__GNUC__)
-#    pragma GCC diagnostic pop
-#endif
+#endif // CATCH_CONFIG_POSIX_SIGNALS
 // end catch_fatal_condition.cpp
 // start catch_generators.cpp
 
@@ -11447,7 +11513,8 @@ namespace {
             return lhs == rhs;
         }
 
-        auto ulpDiff = std::abs(lc - rc);
+        // static cast as a workaround for IBM XLC
+        auto ulpDiff = std::abs(static_cast<FP>(lc - rc));
         return static_cast<uint64_t>(ulpDiff) <= maxUlpDiff;
     }
 
@@ -11621,7 +11688,6 @@ Floating::WithinRelMatcher WithinRel(float target) {
 
 } // namespace Matchers
 } // namespace Catch
-
 // end catch_matchers_floating.cpp
 // start catch_matchers_generic.cpp
 
@@ -12955,9 +13021,8 @@ namespace Catch {
     }
 
     void RunContext::invokeActiveTestCase() {
-        FatalConditionHandler fatalConditionHandler; // Handle signals
+        FatalConditionHandlerGuard _(&m_fatalConditionhandler);
         m_activeTestCase->invoke();
-        fatalConditionHandler.reset();
     }
 
     void RunContext::handleUnfinishedSections() {
@@ -13325,6 +13390,10 @@ namespace Catch {
                     filename.erase(0, lastSlash);
                     filename[0] = '#';
                 }
+                else
+                {
+                    filename.insert(0, "#");
+                }
 
                 auto lastDot = filename.find_last_of('.');
                 if (lastDot != std::string::npos) {
@@ -13487,7 +13556,7 @@ namespace Catch {
 
             // Handle list request
             if( Option<std::size_t> listed = list( m_config ) )
-                return static_cast<int>( *listed );
+                return (std::min) (MaxExitCode, static_cast<int>(*listed));
 
             TestGroup tests { m_config };
             auto const totals = tests.execute();
@@ -15320,7 +15389,7 @@ namespace Catch {
     }
 
     Version const& libraryVersion() {
-        static Version version( 2, 13, 4, "", 0 );
+        static Version version( 2, 13, 10, "", 0 );
         return version;
     }
 
@@ -16733,6 +16802,7 @@ CATCH_REGISTER_REPORTER("console", ConsoleReporter)
 #include <sstream>
 #include <ctime>
 #include <algorithm>
+#include <iomanip>
 
 namespace Catch {
 
@@ -16760,7 +16830,7 @@ namespace Catch {
 #else
             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
 #endif
-            return std::string(timeStamp);
+            return std::string(timeStamp, timeStampSize-1);
         }
 
         std::string fileNameTag(const std::vector<std::string> &tags) {
@@ -16771,6 +16841,17 @@ namespace Catch {
                 return it->substr(1);
             return std::string();
         }
+
+        // Formats the duration in seconds to 3 decimal places.
+        // This is done because some genius defined Maven Surefire schema
+        // in a way that only accepts 3 decimal places, and tools like
+        // Jenkins use that schema for validation JUnit reporter output.
+        std::string formatDuration( double seconds ) {
+            ReusableStringStream rss;
+            rss << std::fixed << std::setprecision( 3 ) << seconds;
+            return rss.str();
+        }
+
     } // anonymous namespace
 
     JunitReporter::JunitReporter( ReporterConfig const& _config )
@@ -16840,7 +16921,7 @@ namespace Catch {
         if( m_config->showDurations() == ShowDurations::Never )
             xml.writeAttribute( "time", "" );
         else
-            xml.writeAttribute( "time", suiteTime );
+            xml.writeAttribute( "time", formatDuration( suiteTime ) );
         xml.writeAttribute( "timestamp", getCurrentTimestamp() );
 
         // Write properties if there are any
@@ -16885,12 +16966,13 @@ namespace Catch {
         if ( !m_config->name().empty() )
             className = m_config->name() + "." + className;
 
-        writeSection( className, "", rootSection );
+        writeSection( className, "", rootSection, stats.testInfo.okToFail() );
     }
 
-    void JunitReporter::writeSection(  std::string const& className,
-                        std::string const& rootName,
-                        SectionNode const& sectionNode ) {
+    void JunitReporter::writeSection( std::string const& className,
+                                      std::string const& rootName,
+                                      SectionNode const& sectionNode,
+                                      bool testOkToFail) {
         std::string name = trim( sectionNode.stats.sectionInfo.name );
         if( !rootName.empty() )
             name = rootName + '/' + name;
@@ -16907,13 +16989,18 @@ namespace Catch {
                 xml.writeAttribute( "classname", className );
                 xml.writeAttribute( "name", name );
             }
-            xml.writeAttribute( "time", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );
+            xml.writeAttribute( "time", formatDuration( sectionNode.stats.durationInSeconds ) );
             // This is not ideal, but it should be enough to mimic gtest's
             // junit output.
             // Ideally the JUnit reporter would also handle `skipTest`
             // events and write those out appropriately.
             xml.writeAttribute( "status", "run" );
 
+            if (sectionNode.stats.assertions.failedButOk) {
+                xml.scopedElement("skipped")
+                    .writeAttribute("message", "TEST_CASE tagged with !mayfail");
+            }
+
             writeAssertions( sectionNode );
 
             if( !sectionNode.stdOut.empty() )
@@ -16923,9 +17010,9 @@ namespace Catch {
         }
         for( auto const& childNode : sectionNode.childSections )
             if( className.empty() )
-                writeSection( name, "", *childNode );
+                writeSection( name, "", *childNode, testOkToFail );
             else
-                writeSection( className, name, *childNode );
+                writeSection( className, name, *childNode, testOkToFail );
     }
 
     void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {
@@ -17437,12 +17524,20 @@ namespace Catch {
 
 #ifndef __OBJC__
 
+#ifndef CATCH_INTERNAL_CDECL
+#ifdef _MSC_VER
+#define CATCH_INTERNAL_CDECL __cdecl
+#else
+#define CATCH_INTERNAL_CDECL
+#endif
+#endif
+
 #if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
 // Standard C/C++ Win32 Unicode wmain entry point
-extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
+extern "C" int CATCH_INTERNAL_CDECL wmain (int argc, wchar_t * argv[], wchar_t * []) {
 #else
 // Standard C/C++ main entry point
-int main (int argc, char * argv[]) {
+int CATCH_INTERNAL_CDECL main (int argc, char * argv[]) {
 #endif
 
     return Catch::Session().run( argc, argv );
@@ -17570,9 +17665,9 @@ int main (int argc, char * const argv[]) {
 
 #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
 #define CATCH_BENCHMARK(...) \
-    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(C_A_T_C_H_B_E_N_C_H_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
 #define CATCH_BENCHMARK_ADVANCED(name) \
-    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(C_A_T_C_H_B_E_N_C_H_), name)
 #endif // CATCH_CONFIG_ENABLE_BENCHMARKING
 
 // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
@@ -17674,9 +17769,9 @@ int main (int argc, char * const argv[]) {
 
 #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
 #define BENCHMARK(...) \
-    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(C_A_T_C_H_B_E_N_C_H_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
 #define BENCHMARK_ADVANCED(name) \
-    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(C_A_T_C_H_B_E_N_C_H_), name)
 #endif // CATCH_CONFIG_ENABLE_BENCHMARKING
 
 using Catch::Detail::Approx;
@@ -17723,8 +17818,8 @@ using Catch::Detail::Approx;
 #define CATCH_WARN( msg )          (void)(0)
 #define CATCH_CAPTURE( msg )       (void)(0)
 
-#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
-#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
+#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
 #define CATCH_METHOD_AS_TEST_CASE( method, ... )
 #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
 #define CATCH_SECTION( ... )
@@ -17733,7 +17828,7 @@ using Catch::Detail::Approx;
 #define CATCH_FAIL_CHECK( ... ) (void)(0)
 #define CATCH_SUCCEED( ... ) (void)(0)
 
-#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
 #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
@@ -17756,8 +17851,8 @@ using Catch::Detail::Approx;
 #endif
 
 // "BDD-style" convenience wrappers
-#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
-#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
+#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
+#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ), className )
 #define CATCH_GIVEN( desc )
 #define CATCH_AND_GIVEN( desc )
 #define CATCH_WHEN( desc )
@@ -17805,10 +17900,10 @@ using Catch::Detail::Approx;
 #define INFO( msg ) (void)(0)
 #define UNSCOPED_INFO( msg ) (void)(0)
 #define WARN( msg ) (void)(0)
-#define CAPTURE( msg ) (void)(0)
+#define CAPTURE( ... ) (void)(0)
 
-#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
-#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
+#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
 #define METHOD_AS_TEST_CASE( method, ... )
 #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
 #define SECTION( ... )
@@ -17816,7 +17911,7 @@ using Catch::Detail::Approx;
 #define FAIL( ... ) (void)(0)
 #define FAIL_CHECK( ... ) (void)(0)
 #define SUCCEED( ... ) (void)(0)
-#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ))
 
 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
 #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
@@ -17846,8 +17941,8 @@ using Catch::Detail::Approx;
 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
 
 // "BDD-style" convenience wrappers
-#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
-#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
+#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ) )
+#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( C_A_T_C_H_T_E_S_T_ ), className )
 
 #define GIVEN( desc )
 #define AND_GIVEN( desc )
@@ -17878,3 +17973,4 @@ using Catch::Detail::Approx;
 // end catch_reenable_warnings.h
 // end catch.hpp
 #endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
+
