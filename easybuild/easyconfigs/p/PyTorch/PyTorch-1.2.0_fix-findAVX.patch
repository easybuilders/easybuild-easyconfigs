# original AVX and AVX2 tests were passed by icc compiler, the new code works well for both gcc and icc
# Based off PyTorch-0.3.1_fix_findAVX.patch by B. Hajgato (Free Univeristy Brussles - VUB)
# and updated for 1.1.1
--- pytorch-1.1.0/cmake/Modules/FindAVX.cmake.orig	2019-03-08 10:29:09.328112915 +0000
+++ pytorch-1.1.0/cmake/Modules/FindAVX.cmake	2019-03-08 10:30:41.538154961 +0000
@@ -6,8 +6,18 @@
 
   int main()
   {
-    __m256 a;
-    a = _mm256_set1_ps(0);
+    __m256 a, b, c;
+    const float src[8] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f };
+    float dst[8];
+    a = _mm256_loadu_ps( src );
+    b = _mm256_loadu_ps( src );
+    c = _mm256_add_ps( a, b );
+    _mm256_storeu_ps( dst, c );
+    for( int i = 0; i < 8; i++ ){
+      if( ( src[i] + src[i] ) != dst[i] ){
+        return -1;
+      }
+    }
     return 0;
   }
 ")
@@ -17,10 +27,20 @@
 
   int main()
   {
-    __m256i a = {0};
-    a = _mm256_abs_epi16(a);
+    __m256i a, b, c;
+    const int src[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
+    int dst[8];
+    a =  _mm256_loadu_si256( (__m256i*)src );
+    b =  _mm256_loadu_si256( (__m256i*)src );
+    c = _mm256_add_epi32( a, b );
+    _mm256_storeu_si256( (__m256i*)dst, c );
+    for( int i = 0; i < 8; i++ ){
+      if( ( src[i] + src[i] ) != dst[i] ){
+        return -1;
+      }
+    }
     __m256i x;
     _mm256_extract_epi64(x, 0); // we rely on this in our AVX2 code
     return 0;
   }
 ")
