commit 6f7381a409857db50d5dbb4b3b17789b7fb9ee36
Author: Louwrens van Dellen <lthvd@protonmail.com>
Date:   Sat Sep 14 18:40:13 2024 +0200

    bugfix install_helper.py for arbitrary build dir, simplify call
    
    The script bugged if choosing a CMAKE_BUILD_DIR other than a subdir of
    CMAKE_SOURCE_DIR.
    
    Also, make it a bit more readable.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 651d9ea..efe3090 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -38,9 +38,7 @@ endif()
 # SWIGIFY HEADERS
 # doing this with the origin python functions
 
-execute_process(COMMAND ${Python_EXECUTABLE} -c
-"import sys; sys.path.append('${CMAKE_SOURCE_DIR}'); \
-import install_helpers; install_helpers.swigify('${CMAKE_SOURCE_DIR}', '${Coin_INCLUDE_DIR}');")
+execute_process(COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/install_helpers.py ${CMAKE_SOURCE_DIR} ${Coin_INCLUDE_DIR})
 
 
 # copy the python module
diff --git a/install_helpers.py b/install_helpers.py
index e80388d..38155c2 100644
--- a/install_helpers.py
+++ b/install_helpers.py
@@ -10,63 +10,78 @@ PIVY_HEADER = """\
 
 """
 
-def copy_and_swigify_headers(includedir, dirname, files):
-        """Copy the header files to the local include directories. Add an
-        #include line at the beginning for the SWIG interface files..."""
-
-        for file in files:
-            if not os.path.isfile(os.path.join(dirname, file)):
-                continue
-
-            if file[-2:] == ".i":
-                file = os.path.join(dirname, file)
-
-                file_i = file.split(os.path.sep)
-                file_i = [i for i in file_i if i != ".."]
-                file_i = os.path.join(*file_i)
-
-                file_h = file_i[:-2] + ".h"
-                from_file = os.path.join(includedir, file_h)
-
-                file_h = file[:-2] + ".h"
-                to_file = os.path.abspath(file_h)
-
-                if os.path.exists(from_file):
-                    shutil.copyfile(from_file, to_file)
-                    sys.stdout.write('create swigified header: ' + to_file + '\n')
-                    fd = open(to_file, 'r+')
-                    contents = fd.readlines()
-
-                    ins_line_nr = -1
-                    for line in contents:
-                        ins_line_nr += 1
-                        if line.find("#include ") != -1:
-                            break
-
-                    if ins_line_nr != -1:
-                        contents.insert(ins_line_nr, PIVY_HEADER % (file_i))
-                        fd.seek(0)
-                        fd.writelines(contents)
-                    else:
-                        print("[failed]")
-                        sys.exit(1)
-                    fd.close
-            # fixes for SWIG 1.3.21 and upwards
-            # (mostly workarounding swig's preprocessor "function like macros"
-            # preprocessor bug when no parameters are provided which then results
-            # in no constructors being created in the wrapper)
-            elif file[-4:] == ".fix":
-                sys.stdout.write(' ' + os.path.join(dirname, file)[:-4])
-                shutil.copyfile(os.path.join(dirname, file),
-                                os.path.join(dirname, file)[:-4])
-            # had to introduce this because windows is a piece of crap
-            elif sys.platform == "win32" and file[-6:] == ".win32":
-                sys.stdout.write(' ' + os.path.join(dirname, file)[:-6])
-                shutil.copyfile(os.path.join(dirname, file),
-                                os.path.join(dirname, file)[:-6])
-
-
-def swigify(interface_dir, include_dir):
-    dir_gen = os.walk(os.path.relpath(os.path.join(interface_dir, "Inventor")))
-    for _dir, _, names in dir_gen:
-        copy_and_swigify_headers(include_dir, _dir, names)
\ No newline at end of file
+
+def swigify_header(header_file, include_file):
+    sys.stdout.write("create swigified header: " + header_file + "\n")
+
+    fd = open(header_file, "r+")
+    contents = fd.readlines()
+
+    ins_line_nr = -1
+    for line in contents:
+        ins_line_nr += 1
+        if line.find("#include ") != -1:
+            break
+
+    if ins_line_nr != -1:
+        contents.insert(ins_line_nr, PIVY_HEADER % (include_file))
+        fd.seek(0)
+        fd.writelines(contents)
+    else:
+        print("[failed]")
+        sys.exit(1)
+    fd.close
+
+
+def copy_and_swigify_header(interface_dir, include_dir, fname):
+    """Copy the header file to the local include directory. Add an
+    #include line at the beginning for the SWIG interface file..."""
+
+    if fname.endswith(".i"):  # consider ".i" files
+        fname_h = fname[:-2] + ".h"  # corresponding ".h" file
+        from_file = os.path.join(include_dir, fname_h)
+        to_file = os.path.join(interface_dir, fname_h)
+
+    elif fname.endswith(".fix"):  # just drop the suffix
+        # fixes for SWIG 1.3.21 and upwards
+        # (mostly workarounding swig's preprocessor "function like macros"
+        # preprocessor bug when no parameters are provided which then results
+        # in no constructors being created in the wrapper)
+        fname_nosuffix = fname[:-4]
+        from_file = os.path.join(interface_dir, fname)
+        to_file = os.path.join(interface_dir, fname_nosuffix)
+
+    elif sys.platform == "win32" and fname.endswith(".win32"):  # just drop the suffix
+        # had to introduce this because windows is a piece of crap
+        fname_nosuffix = fname[:-6]
+        from_file = os.path.join(interface_dir, fname)
+        to_file = os.path.join(interface_dir, fname_nosuffix)
+
+    else:  # ignore other extensions
+        return
+
+    if not os.path.isfile(os.path.join(from_file)):
+        return
+
+    # copy
+    shutil.copyfile(from_file, to_file)
+
+    # and swigify
+    if fname.endswith(".i"):  # consider ".i" files
+        swigify_header(to_file, fname)
+
+
+def swigify(interface_dir, include_dir, component="Inventor"):
+    """Prepare header files for SWIG"""
+
+    # find files within interface_dir/component
+    interface_walker = os.walk(os.path.join(interface_dir, component))
+    for dirpath, _, fnames in interface_walker:
+        for fname in fnames:
+            # only the filename relative to below interface_dir is needed
+            relative_fname = os.path.join(dirpath[1+len(interface_dir):], fname)
+            copy_and_swigify_header(interface_dir, include_dir, relative_fname)
+
+
+if __name__ == "__main__":
+    swigify(sys.argv[1], sys.argv[2])
