Override ctypes behavior to enable support for EB provided libraries. 
This should be only applied if LD_LIBRARY_PATH is disabled. 
Authors: Danilo Gonzalez (DoItNow group), Caspar van Leeuwen (SURF) and Alan O'cais (CECAM)
diff -ruN Python-3.11.5/Lib/ctypes/__init__.py Python-3.11.5.patched/Lib/ctypes/__init__.py
--- Python-3.11.5/Lib/ctypes/__init__.py	2023-08-24 14:09:18.000000000 +0200
+++ Python-3.11.5.patched/Lib/ctypes/__init__.py	2025-07-30 16:29:40.600331232 +0200
@@ -14,6 +14,9 @@
 
 from struct import calcsize as _calcsize
 
+# Add util to use find_library capabilities
+from ctypes import util
+
 if __version__ != _ctypes_version:
     raise Exception("Version number mismatch", __version__, _ctypes_version)
 
@@ -349,6 +352,12 @@
             flags |= _FUNCFLAG_USE_ERRNO
         if use_last_error:
             flags |= _FUNCFLAG_USE_LASTERROR
+        # define CDLL instance name as fullpath
+        if _os.name == "posix":
+            if name:
+                fullpath = util.find_library(name)
+                if fullpath is not None:
+                    self._name = fullpath
         if _sys.platform.startswith("aix"):
             """When the name contains ".a(" and ends with ")",
                e.g., "libFOO.a(libFOO.so)" - this is taken to be an
diff -ruN Python-3.11.5/Lib/ctypes/util.py Python-3.11.5.patched/Lib/ctypes/util.py
--- Python-3.11.5/Lib/ctypes/util.py	2023-08-24 14:09:18.000000000 +0200
+++ Python-3.11.5.patched/Lib/ctypes/util.py	2025-08-07 16:37:14.337414617 +0200
@@ -146,8 +146,60 @@
             # shared objects. See bpo-41976 for more details
             if not _is_elf(file):
                 continue
-            return os.fsdecode(file)
+            file = os.fsdecode(file)
+            if re.search(r'cuda.*stubs', file, re.IGNORECASE):
+                continue
+            return file
 
+    def _findLib_gcc_fullname(name):
+        # Run GCC's linker with the -t (aka --trace) option and examine the
+        # library name it prints out. The GCC command will fail because we
+        # haven't supplied a proper program with main(), but that does not
+        # matter. This function will return the full path of the requested library
+        expr = r'^[^\(\)\s]*%s[^\(\)\s]*' % re.escape(name)
+        c_compiler = shutil.which('gcc')
+        if not c_compiler:
+            c_compiler = shutil.which('cc')
+        if not c_compiler:
+            # No C compiler available, give up
+            return None
+
+        temp = tempfile.NamedTemporaryFile()
+        try:
+            args = [c_compiler, '-Wl,-t', '-o', temp.name, '-l:' + name]
+            # print(args)
+            env = dict(os.environ)
+            env['LC_ALL'] = 'C'
+            env['LANG'] = 'C'
+            try:
+                proc = subprocess.Popen(args,
+                                        stdout=subprocess.PIPE,
+                                        stderr=subprocess.STDOUT,
+                                        env=env)
+            except OSError:  # E.g. bad executable
+                return None
+            with proc:
+                trace = proc.stdout.read().decode()
+        finally:
+            try:
+                temp.close()
+            except FileNotFoundError:
+                # Raised if the file was already removed, which is the normal
+                # behaviour of GCC if linking fails
+                pass
+        res = re.findall(expr, trace, re.MULTILINE)
+        if not res:
+            return None
+
+        for file in res:
+            # Check if the given file is an elf file: gcc can report
+            # some files that are linker scripts and not actual
+            # shared objects. See bpo-41976 for more details
+            if not _is_elf(file):
+                continue
+            if re.search(r'cuda.*stubs', file, re.IGNORECASE):
+                continue
+            return file
 
     if sys.platform == "sunos5":
         # use /usr/ccs/bin/dump on solaris
@@ -283,7 +335,8 @@
             abi_type = mach_map.get(machine, 'libc6')
 
             # XXX assuming GLIBC's ldconfig (with option -p)
-            regex = r'\s+(lib%s\.[^\s]+)\s+\(%s'
+            # Regular expresion that captures complete line of ldconfig -p output that matches with library name. 
+            regex = r'\s+(lib%s\.[^\s]+)\s+\(%s\)\s+=>\s+(\S+)'
             regex = os.fsencode(regex % (re.escape(name), abi_type))
             try:
                 with subprocess.Popen(['/sbin/ldconfig', '-p'],
@@ -293,7 +346,8 @@
                                       env={'LC_ALL': 'C', 'LANG': 'C'}) as p:
                     res = re.search(regex, p.stdout.read())
                     if res:
-                        return os.fsdecode(res.group(1))
+                        # return the regex second group, that is the library fullpath
+                        return os.fsdecode(res.group(2))
             except OSError:
                 pass
 
@@ -301,10 +355,13 @@
             # See issue #9998 for why this is needed
             expr = r'[^\(\)\s]*lib%s\.[^\(\)\s]*' % re.escape(name)
             cmd = ['ld', '-t']
-            libpath = os.environ.get('LD_LIBRARY_PATH')
+            # use LIBRARY_PATH instead of LD_LIBRARY_PATH to use EB provided shared libraries
+            libpath = os.environ.get('LIBRARY_PATH')
             if libpath:
                 for d in libpath.split(':'):
-                    cmd.extend(['-L', d])
+                    # Needed to avoid searching on CUDA stubs
+                    if 'stubs' not in d.split('/'):
+                        cmd.extend(['-L', d])
             cmd.extend(['-o', os.devnull, '-l%s' % name])
             result = None
             try:
@@ -325,9 +382,15 @@
             return result
 
         def find_library(name):
-            # See issue #9998
-            return _findSoname_ldconfig(name) or \
-                   _get_soname(_findLib_gcc(name)) or _get_soname(_findLib_ld(name))
+            # Redefine find_library function, it will return the provided name if
+            # path exist, else it will use the set of functions to find the full library path. 
+            # it will return the one that has a match. 
+            if os.path.exists(name):
+                return name
+            else:
+                return _findSoname_ldconfig(name) or \
+                   _findLib_gcc(name) or _findLib_ld(name) or \
+                   _findLib_gcc_fullname(name) 
 
 ################################################################
 # test code
